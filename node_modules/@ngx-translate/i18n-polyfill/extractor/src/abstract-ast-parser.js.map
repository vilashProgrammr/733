{"version":3,"file":"abstract-ast-parser.js","sourceRoot":"","sources":["../../../lib/extractor/src/abstract-ast-parser.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AAGjC,4GAA4G;AAC5G;IAGY,iBAAiB,CAAC,IAAY,EAAE,QAAgB;QACxD,MAAM,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,EAAE,mBAAmB,CAAC,KAAK,CAAC,CAAC;IAC7F,CAAC;IAED;;OAEG;IACO,kBAAkB,CAAC,QAA2B;QACtD,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;YAC/B,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACvC,MAAM,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YACtB,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC;YACjC,KAAK,EAAE,CAAC,UAAU,CAAC,kBAAkB;gBACnC,MAAM,CAAC,CAAE,QAA6B,CAAC,IAAI,CAAC,CAAC;YAC/C,KAAK,EAAE,CAAC,UAAU,CAAC,sBAAsB;gBACvC,MAAM,CAAE,QAAsC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAyB,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC3G,KAAK,EAAE,CAAC,UAAU,CAAC,uBAAuB;gBACxC,MAAM,OAAO,GAAY,EAAC,KAAK,EAAE,EAAE,EAAC,CAAC;gBACpC,QAAuC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,IAA2B,EAAE,EAAE;oBAC1F,OAAO,CAAE,IAAI,CAAC,IAAsB,CAAC,IAAI,CAAC,GAAI,IAAI,CAAC,WAAgC,CAAC,IAAI,CAAC;gBAC3F,CAAC,CAAC,CAAC;gBACH,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;oBACnB,MAAM,IAAI,KAAK,CACb,4CAA4C,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,QAAQ,EAAE,CACpG,CAAC;gBACJ,CAAC;gBACD,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC;YACnB,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU;gBAC3B,OAAO,CAAC,GAAG,CAAC,6EAA6E,CAAC,CAAC;gBAC3F,KAAK,CAAC;YACR;gBACE,OAAO,CAAC,GAAG,CAAC,iCAAiC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QACpG,CAAC;QACD,MAAM,CAAC,EAAE,CAAC;IACZ,CAAC;IAED;;OAEG;IACO,UAAU,CAAC,IAAa,EAAE,IAAmB;QACrD,MAAM,aAAa,GAAc,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACpE,MAAM,YAAY,GAAc,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAEjE,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,MAAiB,EAAE,SAAkB,EAAE,EAAE;YACpE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;QACzD,CAAC,EAAE,YAAY,CAAC,CAAC;IACnB,CAAC;IAES,gBAAgB,CAAC,IAAmB;QAC5C,MAAM,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;CACF;AAzDD,8CAyDC","sourcesContent":["import * as ts from \"typescript\";\nimport {I18nDef} from \"../../src/i18n-polyfill\";\n\n// source: https://github.com/biesbjerg/ngx-translate-extract/blob/master/src/parsers/abstract-ast.parser.ts\nexport abstract class AbstractAstParser {\n  protected _sourceFile: ts.SourceFile;\n\n  protected _createSourceFile(path: string, contents: string): ts.SourceFile {\n    return ts.createSourceFile(path, contents, ts.ScriptTarget.ES5, /*setParentNodes */ false);\n  }\n\n  /**\n   * Get strings from function call's first argument\n   */\n  protected _getCallArgStrings(callNode: ts.CallExpression): (string | I18nDef)[] {\n    if (!callNode.arguments.length) {\n      return [];\n    }\n\n    const firstArg = callNode.arguments[0];\n    switch (firstArg.kind) {\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.FirstTemplateToken:\n        return [(firstArg as ts.StringLiteral).text];\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        return (firstArg as ts.ArrayLiteralExpression).elements.map((element: ts.StringLiteral) => element.text);\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        const i18nDef: I18nDef = {value: \"\"};\n        (firstArg as ts.ObjectLiteralExpression).properties.forEach((prop: ts.PropertyAssignment) => {\n          i18nDef[(prop.name as ts.Identifier).text] = (prop.initializer as ts.StringLiteral).text;\n        });\n        if (!i18nDef.value) {\n          throw new Error(\n            `An I18nDef requires a value property on '${this.syntaxKindToName(firstArg.kind)}' for ${firstArg}`\n          );\n        }\n        return [i18nDef];\n      case ts.SyntaxKind.Identifier:\n        console.log(\"WARNING: We cannot extract variable values passed to TranslateService (yet)\");\n        break;\n      default:\n        console.log(`SKIP: Unknown argument type: '${this.syntaxKindToName(firstArg.kind)}'`, firstArg);\n    }\n    return [];\n  }\n\n  /**\n   * Find all child nodes of a kind\n   */\n  protected _findNodes(node: ts.Node, kind: ts.SyntaxKind): ts.Node[] {\n    const childrenNodes: ts.Node[] = node.getChildren(this._sourceFile);\n    const initialValue: ts.Node[] = node.kind === kind ? [node] : [];\n\n    return childrenNodes.reduce((result: ts.Node[], childNode: ts.Node) => {\n      return result.concat(this._findNodes(childNode, kind));\n    }, initialValue);\n  }\n\n  protected syntaxKindToName(kind: ts.SyntaxKind): string {\n    return ts.SyntaxKind[kind];\n  }\n}\n"]}