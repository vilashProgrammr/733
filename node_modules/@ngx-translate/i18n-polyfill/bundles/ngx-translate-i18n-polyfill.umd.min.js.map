{"version":3,"sources":["null","ng://@ngx-translate/i18n-polyfill/src/ast/ast.ts","ng://@ngx-translate/i18n-polyfill/src/ast/i18n_ast.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parse_util.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xml_helper.ts","ng://@ngx-translate/i18n-polyfill/src/ast/interpolation_config.ts","ng://@ngx-translate/i18n-polyfill/src/ast/chars.ts","ng://@ngx-translate/i18n-polyfill/src/ast/tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parser.ts","ng://@ngx-translate/i18n-polyfill/src/ast/xml_tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/html_tags.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/serializer.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/digest.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff2.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xmb.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xtb.ts","ng://@ngx-translate/i18n-polyfill/src/parser/ast.ts","ng://@ngx-translate/i18n-polyfill/src/parser/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/parser/parser.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/placeholder.ts","ng://@ngx-translate/i18n-polyfill/src/parser/i18n.ts","ng://@ngx-translate/i18n-polyfill/src/parser/html.ts","ng://@ngx-translate/i18n-polyfill/src/i18n-polyfill.ts"],"names":["extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","Text","sourceSpan","visit","visitor","context","visitText","Expansion","switchValue","type","cases","switchValueSourceSpan","visitExpansion","ExpansionCase","expression","valueSourceSpan","expSourceSpan","visitExpansionCase","Attribute","name","valueSpan","visitAttribute","Element","attrs","children","startSourceSpan","endSourceSpan","visitElement","Comment","visitComment","visitAll","nodes","result","ast","forEach","astResult","Message","placeholders","placeholderToMessage","meaning","description","id","sources","filePath","start","file","url","startLine","line","startCol","col","endLine","end","endCol","Container","visitContainer","Icu","visitIcu","TagPlaceholder","tag","startName","closeName","isVoid","visitTagPlaceholder","Placeholder","visitPlaceholder","IcuPlaceholder","visitIcuPlaceholder","RecurseVisitor","text","container","_this","child","icu","keys","k","ph","ParseLocation","_super","CR","ws","join","tslib_1.__extends","offset","toString","getContext","maxChars","maxLines","content","startOffset","endOffset","ctxChars","ctxLines","before","substring","after","ParseSourceFile","ParseSourceSpan","details","ParseError","span","msg","level","ParseErrorLevel","ERROR","contextualMessage","ctx","I18nError","escapeRegExp","s","replace","DEFAULT_INTERPOLATION_CONFIG","$TAB","$LF","$VTAB","$FF","$CR","$SPACE","$DQ","$$","$SQ","$RPAREN","$PLUS","$COMMA","$MINUS","$0","$9","$A","$E","$F","$Z","$_","$a","$e","$f","$n","$r","$t","$v","$z","$LBRACE","$RBRACE","$NBSP","$BT","isWhitespace","code","isDigit","isAsciiLetter","splitNsName","elementName","colonIndex","indexOf","Error","slice","getNsPrefix","fullName","mergeNsAndName","prefix","localName","NAMED_ENTITIES","Aacute","aacute","Acirc","acirc","acute","AElig","aelig","Agrave","agrave","alefsym","Alpha","alpha","amp","and","ang","apos","Aring","aring","asymp","Atilde","atilde","Auml","auml","bdquo","Beta","beta","brvbar","bull","cap","Ccedil","ccedil","cedil","cent","Chi","chi","circ","clubs","cong","copy","crarr","cup","curren","dagger","Dagger","darr","dArr","deg","Delta","delta","diams","divide","Eacute","eacute","Ecirc","ecirc","Egrave","egrave","empty","emsp","ensp","Epsilon","epsilon","equiv","Eta","eta","ETH","eth","Euml","euml","euro","exist","fnof","forall","frac12","frac14","frac34","frasl","Gamma","gamma","ge","gt","harr","hArr","hearts","hellip","Iacute","iacute","Icirc","icirc","iexcl","Igrave","igrave","image","infin","int","Iota","iota","iquest","isin","Iuml","iuml","Kappa","kappa","Lambda","lambda","lang","laquo","larr","lArr","lceil","ldquo","le","lfloor","lowast","loz","lrm","lsaquo","lsquo","lt","macr","mdash","micro","middot","minus","Mu","mu","nabla","nbsp","ndash","ne","ni","not","notin","nsub","Ntilde","ntilde","Nu","nu","Oacute","oacute","Ocirc","ocirc","OElig","oelig","Ograve","ograve","oline","Omega","omega","Omicron","omicron","oplus","or","ordf","ordm","Oslash","oslash","Otilde","otilde","otimes","Ouml","ouml","para","permil","perp","Phi","phi","Pi","pi","piv","plusmn","pound","prime","Prime","prod","prop","Psi","psi","quot","radic","rang","raquo","rarr","rArr","rceil","rdquo","real","reg","rfloor","Rho","rho","rlm","rsaquo","rsquo","sbquo","Scaron","scaron","sdot","sect","shy","Sigma","sigma","sigmaf","sim","spades","sub","sube","sum","sup","sup1","sup2","sup3","supe","szlig","Tau","tau","there4","Theta","theta","thetasym","thinsp","THORN","thorn","tilde","times","trade","Uacute","uacute","uarr","uArr","Ucirc","ucirc","Ugrave","ugrave","uml","upsih","Upsilon","upsilon","Uuml","uuml","weierp","Xi","xi","Yacute","yacute","yen","yuml","Yuml","Zeta","zeta","zwj","zwnj","Token","parts","TokenError","errorMsg","tokenType","TokenizeResult","tokens","errors","_CR_OR_CRLF_REGEXP","_unexpectedCharacterErrorMsg","charCode","String","fromCharCode","_unknownEntityErrorMsg","entitySrc","ControlFlowError","Tokenizer","_file","_getTagDefinition","_tokenizeIcu","_interpolationConfig","_input","_length","_advance","_processCarriageReturns","tokenize","_peek","_getLocation","_attemptCharCode","_consumeCdata","chars.$MINUS","_consumeComment","_consumeDocType","_consumeTagClose","_consumeTagOpen","_tokenizeExpansionForm","_consumeText","_beginToken","TokenType","EOF","_endToken","srcTokens","dstTokens","lastDstToken","undefined","token","TEXT","mergeTextTokens","isExpansionFormStart","_index","_consumeExpansionFormStart","peek","chars.isAsciiLetter","chars.isDigit","_isInExpansionForm","_consumeExpansionCaseStart","chars.$RBRACE","_isInExpansionCase","_consumeExpansionCaseEnd","_consumeExpansionFormEnd","_line","_column","_getSpan","_currentTokenStart","_currentTokenType","_createError","chars.$LF","chars.$CR","charCodeAt","_nextPeek","_attemptCharCodeCaseInsensitive","code1","code2","toUpperCaseCharCode","_requireCharCode","location","_attemptStr","chars","len","initialPosition","_savePosition","_restorePosition","_attemptStrCaseInsensitive","_requireStr","_attemptCharCodeUntilFn","predicate","_requireCharCodeUntilFn","_attemptUntilChar","char","_readChar","decodeEntities","_decodeEntity","index","startPosition","isNamedEntityEnd","name_1","isHex","numberStart","isDigitEntityEnd","strNum","parseInt","entity","_consumeRawText","firstCharOfEnd","attemptEndRest","tagCloseStart","textStart","ESCAPABLE_RAW_TEXT","RAW_TEXT","COMMENT_START","textToken","COMMENT_END","CDATA_START","CDATA_END","DOC_TYPE","_consumePrefixAndName","nameStart","nameOrPrefixStart","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$0","chars.$9","isNameEnd","tagName","lowercaseTagName","savedPos","_consumeTagOpenStart","toLowerCase","isNotWhitespace","_consumeAttributeName","_consumeAttributeValue","_consumeTagOpenEnd","contentTokenType","contentType","TagContentType","_consumeRawTextWithTagClose","TAG_CLOSE","TAG_OPEN_START","ATTR_NAME","prefixAndName","ATTR_VALUE","chars.$SQ","chars.$DQ","quoteChar","valueStart","TAG_OPEN_END_VOID","TAG_OPEN_END","EXPANSION_FORM_START","chars.$LBRACE","_expansionCaseStack","condition","_readUntil","chars.$COMMA","EXPANSION_CASE_VALUE","trim","EXPANSION_CASE_EXP_START","EXPANSION_CASE_EXP_END","pop","EXPANSION_FORM_END","_inInterpolation","_isTextEnd","position","nbTokens","chars.isWhitespace","input","interpolationConfig","isInterpolationStart","TreeError","ParseTreeResult","rootNodes","Parser","getTagDefinition","parse","source","parseExpansionForms","tokenizeExpansionForms","tokensAndErrors","treeAndErrors","_TreeBuilder","build","lex.TokenType","_consumeStartTag","_consumeEndTag","_closeVoidElement","_consumeExpansion","_rootNodes","_errors","prev","_advanceIf","startToken","_addToParent","html.Comment","expCase","_parseExpansionCase","html.Expansion","exp","_collectExpansionExpTokens","lex.Token","parsedExp","html.ExpansionCase","expansionFormStack","lastOnStack","parent_1","_getParentElement","ignoreFirstLf","html.Text","el","_elementStack","startTagToken","_consumeAttr","_getElementFullName","selfClosing","tagDef","canSelfClose","html.Element","_pushElement","_popElement","parentEl","isClosedByChild","_a","_getParentElementSkippingContainers","parent","requireExtraParent","newParent","parentToAdd","_insertBeforeContainer","endTagToken","errMsg","stackIndex","splice","closedByParent","attrName","valueToken","html.Attribute","node","parentElement","stack","element","_TAG_DEFINITION","PARSABLE_DATA","XmlTagDefinition","currentParent","getXmlTagDefinition","HtmlTagDefinition","_b","closedByChildren","requiredParents","implicitNamespacePrefix","_c","_d","_e","_f","lcParent","TAG_DEFINITIONS","base","meta","area","embed","link","img","param","hr","br","track","wbr","thead","tbody","tfoot","tr","td","th","svg","math","li","dt","dd","rb","rt","rtc","rp","optgroup","option","pre","listing","style","script","title","textarea","_DEFAULT_TAG_DEFINITION","getHtmlTagDefinition","SimplePlaceholderMapper","message","mapName","toPublicName","internalName","internalToPublic","toInternalName","publicName","publicToInternal","visitPlaceholderName","nextId","publicToNextId","i18n.RecurseVisitor","i18nSelectPipe","I18nSelectPipe","SerializerVisitor","locale","params","i18nPluralPipe","I18nPluralPipe","NgLocaleLocalization","serializeNodes","attribute","comment","expansion","c","transform","expansionCase","map","a","digest","str","utf8","utf8Encode","words32","endian","wordAt","stringToWords32","Endian","Big","w","h0","h1","h2","h3","h4","j","rol32","fk","f","temp","reduce","add32","hex","byteAt","byteStringToHexString","words32ToByteString","sha1","serializerVisitor","strCases","SerializerIgnoreIcuExpVisitor","fingerprint","hash32","hi","lo","mix","Little","sub32","add32to64","low","high","count","word","word32ToByteString","addBigInt","x","y","Math","max","carry","tmpSum","numberTimesBigInt","num","product","bToThePower","encoded","codePoint","_UNIT_TAG","xliffLoadToI18n","XliffParser","msgIdToHtml","i18nMessagesById","converter","XmlToI18n","msgId","convert","i18nNodes","apply","xliffDigest","_unitMlString","_msgIdToHtml","parser","ml.visitAll","idAttr","find","attr","_addError","innerTextStart","innerTextEnd","innerText","xmlIcu","i18n.Text","nameAttr","i18n.Placeholder","caseMap","i18n.Container","i18n.Icu","icuCase","xliff2LoadToI18n","Xliff2Parser","i18nNodesByMsgId","xliff2Digest","ah","al","bh","bl","l","him","lom","decimal","toThePower","split","reverse","byteStringToDecString","computeMsgId","versionAttr","version","startAttr","endAttr","startId","endId","toUpperCase","_TRANSLATIONS_TAG","_TRANSLATION_TAG","xtbLoadToI18n","XtbParser","parseErrors","messages","valueFn","defineProperty","configurable","enumerable","get","set","_","xtbDigest","xtbMapper","xtb","_bundleDepth","xml","ParserError","errLocation","ctxLocation","ParseSpan","AST","Quote","uninterpretedExpression","visitQuote","EmptyExpr","ImplicitReceiver","visitImplicitReceiver","Chain","expressions","visitChain","Conditional","trueExp","falseExp","visitConditional","PropertyRead","receiver","visitPropertyRead","PropertyWrite","visitPropertyWrite","SafePropertyRead","visitSafePropertyRead","KeyedRead","obj","key","visitKeyedRead","KeyedWrite","visitKeyedWrite","BindingPipe","args","visitPipe","LiteralPrimitive","visitLiteralPrimitive","LiteralArray","visitLiteralArray","LiteralMap","values","visitLiteralMap","Interpolation","strings","visitInterpolation","Binary","operation","left","right","visitBinary","PrefixNot","visitPrefixNot","NonNullAssert","visitNonNullAssert","MethodCall","visitMethodCall","SafeMethodCall","visitSafeMethodCall","FunctionCall","target","visitFunctionCall","ASTWithSource","TemplateBinding","keyIsVar","KEYWORDS","Lexer","scanner","Scanner","scanToken","numValue","strValue","isCharacter","Character","isNumber","Number","isString","isOperator","operater","Operator","isIdentifier","Identifier","isKeyword","Keyword","isKeywordLet","isKeywordAs","isKeywordNull","isKeywordUndefined","isKeywordTrue","isKeywordFalse","isKeywordThis","isError","toNumber","newCharacterToken","newOperatorToken","advance","chars.$SPACE","isIdentifierStart","scanIdentifier","scanNumber","chars.$RPAREN","scanCharacter","scanString","chars.$PLUS","scanOperator","scanComplexOperator","chars.$NBSP","one","twoCode","two","threeCode","three","isIdentifierPart","simple","chars.$e","chars.$E","isNaN","parseIntAutoRadix","parseFloat","quote","buffer","marker","unescapedCode","test","unescape","last","chars.$_","chars.$$","chars.$n","chars.$f","chars.$FF","chars.$r","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","SplitInterpolation","offsets","TemplateBindingParseResult","templateBindings","warnings","_createInterpolateRegExp","config","pattern","RegExp","_lexer","parseAction","_checkNoInterpolation","sourceToLex","_stripComments","ParseAST","parseChain","parseBinding","_parseBindingAst","parseSimpleBinding","SimpleExpressionChecker","check","_reportError","_parseQuote","prefixSeparatorIndex","parseTemplateBindings","prefixToken","prefixTokens","t","unshift","parseInterpolation","splitInterpolation","expressionText","regexp","part","_findInterpolationErrorColumn","wrapLiteralPrimitive","_commentStart","outerQuote","nextChar","chars.$BT","partInErrIdx","inputLength","inputIndex","optionalCharacter","peekKeywordLet","peekKeywordAs","expectCharacter","optionalOperator","op","expectOperator","operator","expectIdentifierOrKeyword","expectIdentifierOrKeywordOrString","exprs","expr","parsePipe","parseExpression","parseConditional","parseLogicalOr","yes","no","parseLogicalAnd","parseEquality","parseRelational","parseAdditive","parseMultiplicative","parsePrefix","parseCallChain","parsePrimary","parseAccessMemberOrMethodCall","rbracketsExpected","rparensExpected","parseCallArguments","elements","parseExpressionList","parseLiteralMap","literalValue","terminator","rbracesExpected","quoted","isSafe","positionals","expectTemplateBindingKey","operatorFound","bindings","rawKey","name_2","letStart","st","letName","locationText","skip","asts","TAG_TO_PLACEHOLDER_NAMES","A","B","BR","EM","H1","H2","H3","H4","H5","H6","HR","I","LI","LINK","OL","P","Q","S","SMALL","SUB","SUP","TBODY","TD","TFOOT","TH","THEAD","TR","TT","U","UL","PlaceholderRegistry","getStartTagPlaceholderName","signature","_hashTag","_signatureToName","upperTag","baseName","_generateUniqueName","getCloseTagPlaceholderName","_hashClosingTag","getPlaceholderName","upperName","uniqueName","getUniquePlaceholder","sort","_placeHolderNameCounts","_expParser","I18nVisitor","_expressionParser","toI18nMessage","_isIcu","_icuDepth","_placeholderRegistry","_placeholderToContent","_placeholderToMessage","i18nodes","html.visitAll","i18n.Message","startPhName","closePhName","i18n.TagPlaceholder","_visitTextWithInterpolation","i18nIcuCases","i18nIcu","caze","expPh","expressionPlaceholder","phName","i18n.IcuPlaceholder","sDelimiter","eDelimiter","_CUSTOM_PH_EXP","lastStringIdx","HtmlParser","extractMessages","Visitor","wrapper","extract","mergeTranslations","translations","metadata","implicitTags","merge","ExtractionResult","TranslationBundle","missingTranslationStrategy","mapperFactory","console","i18nToHtml","I18nToHtmlVisitor","load","createNameMapper","loadFct","srcMsg","htmlRes","has","_i18nNodesByMsgId","_digest","_mapperFactory","_missingTranslationStrategy","_console","_contextStack","_params","_paramKeys","convertToText","htmlParser","_srcMsg","_mapper","convertToValue","mapper","MissingTranslationStrategy","Warning","warn","placeholder","Visitor$$1","_implicitTags","init","VisitorMode","Extract","inI18nBlock","Merge","translatedNode","mode","mayBeAddBlockChildren","wasInIcu","inIcu","isInTranslatableSection","addMessage","depth","wasInI18nNode","inI18nNode","wasInImplicitNode","inImplicitNode","childNodes","translatedChildNodes","i18nAttr","isImplicit","some","isTopLevelImplicit","translateMessage","isTranslatable","openTranslatableSection","_closeTranslatableSection","visited","msgCountAtSectionStart","createI18nMessage","blockStartDepth","blockChildren","directChildren","startIndex","MISSING_TRANSLATION_STRATEGY","InjectionToken","I18n","format","createMapper","translationsBundle","def","htmlParserResult","mergedNodes","Injectable","Inject","TRANSLATIONS_FORMAT","TRANSLATIONS","LOCALE_ID","decorators","Optional"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion implements Node {\n  constructor(\n    public switchValue: string,\n    public type: string,\n    public cases: ExpansionCase[],\n    public sourceSpan: ParseSourceSpan,\n    public switchValueSourceSpan: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements Node {\n  constructor(\n    public value: string,\n    public expression: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public valueSourceSpan: ParseSourceSpan,\n    public expSourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    public valueSpan?: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n    public name: string,\n    public attrs: Attribute[],\n    public children: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan | null = null,\n    public endSourceSpan: ParseSourceSpan | null = null\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements Node {\n  constructor(public value: string | null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit\n    ? (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context)\n    : (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport class Message {\n  sources: MessageSpan[];\n\n  /**\n   * @param source message AST\n   * @param placeholders maps placeholder names to static content\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param id\n   */\n  constructor(\n    public nodes: Node[],\n    public placeholders: {[phName: string]: string},\n    public placeholderToMessage: {[phName: string]: Message},\n    public meaning: string,\n    public description: string,\n    public id: string\n  ) {\n    if (nodes.length) {\n      this.sources = [\n        {\n          filePath: nodes[0].sourceSpan.start.file.url,\n          startLine: nodes[0].sourceSpan.start.line + 1,\n          startCol: nodes[0].sourceSpan.start.col + 1,\n          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n          endCol: nodes[0].sourceSpan.start.col + 1\n        }\n      ];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  public expressionPlaceholder: string;\n  constructor(\n    public expression: string,\n    public type: string,\n    public cases: {[k: string]: Node},\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n    public tag: string,\n    public attrs: {[k: string]: string},\n    public startName: string,\n    public closeName: string,\n    public children: Node[],\n    public isVoid: boolean,\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => (cases[key] = icu.cases[key].visit(this, context)));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n","import {I18nDef} from \"../i18n-polyfill\";\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParseLocation {\n  constructor(public file: ParseSourceFile, public offset: number, public line: number, public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.line}:${this.col}` : \"\";\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string; after: string} | null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url = \"\") {}\n}\n\nexport class ParseSourceSpan {\n  constructor(public start: ParseLocation, public end: ParseLocation, public details: string | null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR\n}\n\nexport class ParseError {\n  constructor(\n    public span: ParseSourceSpan,\n    public msg: string,\n    public level: ParseErrorLevel = ParseErrorLevel.ERROR\n  ) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? ` (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : \"\";\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : \"\";\n    return `${this.msg}${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n  constructor(span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport * as ml from \"../ast/ast\";\r\n\r\nexport interface IVisitor {\r\n  visitTag(tag: Tag): any;\r\n  visitElement(element: ml.Element): any;\r\n  visitText(text: Text): any;\r\n  visitDeclaration(decl: Declaration): any;\r\n  visitDoctype(doctype: Doctype): any;\r\n}\r\n\r\nclass Visitor implements IVisitor {\r\n  visitTag(tag: Tag): string {\r\n    const strAttrs = this._serializeAttributes(tag.attrs);\r\n    if (tag.children.length === 0) {\r\n      return `<${tag.name}${strAttrs}/>`;\r\n    }\r\n\r\n    const strChildren = tag.children.map(node => node.visit(this));\r\n    return `<${tag.name}${strAttrs}>${strChildren.join(\"\")}</${tag.name}>`;\r\n  }\r\n\r\n  visitText(text: Text): string {\r\n    return _escapeXml(text.value);\r\n  }\r\n\r\n  visitElement(element: ml.Element) {\r\n    const attrs = {};\r\n    element.attrs.forEach((attr: ml.Attribute) => {\r\n      attrs[attr.name] = attr.value;\r\n    });\r\n    const tag = new Tag(element.name, attrs, element.children as any);\r\n    return this.visitTag(tag);\r\n  }\r\n\r\n  visitDeclaration(decl: Declaration): string {\r\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\r\n  }\r\n\r\n  private _serializeAttributes(attrs: {[k: string]: string}) {\r\n    const strAttrs = Object.keys(attrs)\r\n      .map((name: string) => `${name}=\"${_escapeXml(attrs[name])}\"`)\r\n      .join(\" \");\r\n    return strAttrs.length > 0 ? \" \" + strAttrs : \"\";\r\n  }\r\n\r\n  visitDoctype(doctype: Doctype): any {\r\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\r\n  }\r\n}\r\n\r\nconst _visitor = new Visitor();\r\n\r\nexport function serialize(nodes: Node[]): string {\r\n  return nodes.map((node: Node): string => node.visit(_visitor)).join(\"\");\r\n}\r\n\r\nexport interface Node {\r\n  visit(visitor: IVisitor): any;\r\n}\r\n\r\nexport class Declaration implements Node {\r\n  constructor(public attrs: {[k: string]: string}) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDeclaration(this);\r\n  }\r\n}\r\n\r\nexport class Doctype implements Node {\r\n  constructor(public rootTag: string, public dtd: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDoctype(this);\r\n  }\r\n}\r\n\r\nexport class Tag implements Node {\r\n  constructor(public name: string, public attrs: {[k: string]: string} = {}, public children: Node[] = []) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitTag(this);\r\n  }\r\n}\r\n\r\nexport class Text implements Node {\r\n  constructor(public value: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitText(this);\r\n  }\r\n}\r\n\r\nexport class CR extends Text {\r\n  constructor(ws = 0) {\r\n    super(`\\n${new Array(ws + 1).join(\" \")}`);\r\n  }\r\n}\r\n\r\nconst _ESCAPED_CHARS: [RegExp, string][] = [\r\n  [/&/g, \"&amp;\"],\r\n  [/\"/g, \"&quot;\"],\r\n  [/'/g, \"&apos;\"],\r\n  [/</g, \"&lt;\"],\r\n  [/>/g, \"&gt;\"]\r\n];\r\n\r\nfunction _escapeXml(text: string): string {\r\n  return _ESCAPED_CHARS.reduce((str: string, entry: [RegExp, string]) => str.replace(entry[0], entry[1]), text);\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class InterpolationConfig {\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig = new InterpolationConfig(\"{{\", \"}}\");\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || code === $NBSP;\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return (code >= $a && code <= $z) || (code >= $A && code <= $Z);\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return (code >= $a && code <= $f) || (code >= $A && code <= $F) || isDigit(code);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string | null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n\n  requireExtraParent(currentParent: string): boolean;\n\n  isClosedByChild(name: string): boolean;\n}\n\nexport function splitNsName(elementName: string): [string | null, string] {\n  if (elementName[0] !== \":\") {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(\":\", 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-container\";\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-content\";\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-template\";\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string | null): string | null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\n\nexport const NAMED_ENTITIES: {[k: string]: string} = {\n  Aacute: \"\\u00C1\",\n  aacute: \"\\u00E1\",\n  Acirc: \"\\u00C2\",\n  acirc: \"\\u00E2\",\n  acute: \"\\u00B4\",\n  AElig: \"\\u00C6\",\n  aelig: \"\\u00E6\",\n  Agrave: \"\\u00C0\",\n  agrave: \"\\u00E0\",\n  alefsym: \"\\u2135\",\n  Alpha: \"\\u0391\",\n  alpha: \"\\u03B1\",\n  amp: \"&\",\n  and: \"\\u2227\",\n  ang: \"\\u2220\",\n  apos: \"\\u0027\",\n  Aring: \"\\u00C5\",\n  aring: \"\\u00E5\",\n  asymp: \"\\u2248\",\n  Atilde: \"\\u00C3\",\n  atilde: \"\\u00E3\",\n  Auml: \"\\u00C4\",\n  auml: \"\\u00E4\",\n  bdquo: \"\\u201E\",\n  Beta: \"\\u0392\",\n  beta: \"\\u03B2\",\n  brvbar: \"\\u00A6\",\n  bull: \"\\u2022\",\n  cap: \"\\u2229\",\n  Ccedil: \"\\u00C7\",\n  ccedil: \"\\u00E7\",\n  cedil: \"\\u00B8\",\n  cent: \"\\u00A2\",\n  Chi: \"\\u03A7\",\n  chi: \"\\u03C7\",\n  circ: \"\\u02C6\",\n  clubs: \"\\u2663\",\n  cong: \"\\u2245\",\n  copy: \"\\u00A9\",\n  crarr: \"\\u21B5\",\n  cup: \"\\u222A\",\n  curren: \"\\u00A4\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  darr: \"\\u2193\",\n  dArr: \"\\u21D3\",\n  deg: \"\\u00B0\",\n  Delta: \"\\u0394\",\n  delta: \"\\u03B4\",\n  diams: \"\\u2666\",\n  divide: \"\\u00F7\",\n  Eacute: \"\\u00C9\",\n  eacute: \"\\u00E9\",\n  Ecirc: \"\\u00CA\",\n  ecirc: \"\\u00EA\",\n  Egrave: \"\\u00C8\",\n  egrave: \"\\u00E8\",\n  empty: \"\\u2205\",\n  emsp: \"\\u2003\",\n  ensp: \"\\u2002\",\n  Epsilon: \"\\u0395\",\n  epsilon: \"\\u03B5\",\n  equiv: \"\\u2261\",\n  Eta: \"\\u0397\",\n  eta: \"\\u03B7\",\n  ETH: \"\\u00D0\",\n  eth: \"\\u00F0\",\n  Euml: \"\\u00CB\",\n  euml: \"\\u00EB\",\n  euro: \"\\u20AC\",\n  exist: \"\\u2203\",\n  fnof: \"\\u0192\",\n  forall: \"\\u2200\",\n  frac12: \"\\u00BD\",\n  frac14: \"\\u00BC\",\n  frac34: \"\\u00BE\",\n  frasl: \"\\u2044\",\n  Gamma: \"\\u0393\",\n  gamma: \"\\u03B3\",\n  ge: \"\\u2265\",\n  gt: \">\",\n  harr: \"\\u2194\",\n  hArr: \"\\u21D4\",\n  hearts: \"\\u2665\",\n  hellip: \"\\u2026\",\n  Iacute: \"\\u00CD\",\n  iacute: \"\\u00ED\",\n  Icirc: \"\\u00CE\",\n  icirc: \"\\u00EE\",\n  iexcl: \"\\u00A1\",\n  Igrave: \"\\u00CC\",\n  igrave: \"\\u00EC\",\n  image: \"\\u2111\",\n  infin: \"\\u221E\",\n  int: \"\\u222B\",\n  Iota: \"\\u0399\",\n  iota: \"\\u03B9\",\n  iquest: \"\\u00BF\",\n  isin: \"\\u2208\",\n  Iuml: \"\\u00CF\",\n  iuml: \"\\u00EF\",\n  Kappa: \"\\u039A\",\n  kappa: \"\\u03BA\",\n  Lambda: \"\\u039B\",\n  lambda: \"\\u03BB\",\n  lang: \"\\u27E8\",\n  laquo: \"\\u00AB\",\n  larr: \"\\u2190\",\n  lArr: \"\\u21D0\",\n  lceil: \"\\u2308\",\n  ldquo: \"\\u201C\",\n  le: \"\\u2264\",\n  lfloor: \"\\u230A\",\n  lowast: \"\\u2217\",\n  loz: \"\\u25CA\",\n  lrm: \"\\u200E\",\n  lsaquo: \"\\u2039\",\n  lsquo: \"\\u2018\",\n  lt: \"<\",\n  macr: \"\\u00AF\",\n  mdash: \"\\u2014\",\n  micro: \"\\u00B5\",\n  middot: \"\\u00B7\",\n  minus: \"\\u2212\",\n  Mu: \"\\u039C\",\n  mu: \"\\u03BC\",\n  nabla: \"\\u2207\",\n  nbsp: \"\\u00A0\",\n  ndash: \"\\u2013\",\n  ne: \"\\u2260\",\n  ni: \"\\u220B\",\n  not: \"\\u00AC\",\n  notin: \"\\u2209\",\n  nsub: \"\\u2284\",\n  Ntilde: \"\\u00D1\",\n  ntilde: \"\\u00F1\",\n  Nu: \"\\u039D\",\n  nu: \"\\u03BD\",\n  Oacute: \"\\u00D3\",\n  oacute: \"\\u00F3\",\n  Ocirc: \"\\u00D4\",\n  ocirc: \"\\u00F4\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Ograve: \"\\u00D2\",\n  ograve: \"\\u00F2\",\n  oline: \"\\u203E\",\n  Omega: \"\\u03A9\",\n  omega: \"\\u03C9\",\n  Omicron: \"\\u039F\",\n  omicron: \"\\u03BF\",\n  oplus: \"\\u2295\",\n  or: \"\\u2228\",\n  ordf: \"\\u00AA\",\n  ordm: \"\\u00BA\",\n  Oslash: \"\\u00D8\",\n  oslash: \"\\u00F8\",\n  Otilde: \"\\u00D5\",\n  otilde: \"\\u00F5\",\n  otimes: \"\\u2297\",\n  Ouml: \"\\u00D6\",\n  ouml: \"\\u00F6\",\n  para: \"\\u00B6\",\n  permil: \"\\u2030\",\n  perp: \"\\u22A5\",\n  Phi: \"\\u03A6\",\n  phi: \"\\u03C6\",\n  Pi: \"\\u03A0\",\n  pi: \"\\u03C0\",\n  piv: \"\\u03D6\",\n  plusmn: \"\\u00B1\",\n  pound: \"\\u00A3\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  prod: \"\\u220F\",\n  prop: \"\\u221D\",\n  Psi: \"\\u03A8\",\n  psi: \"\\u03C8\",\n  quot: \"\\u0022\",\n  radic: \"\\u221A\",\n  rang: \"\\u27E9\",\n  raquo: \"\\u00BB\",\n  rarr: \"\\u2192\",\n  rArr: \"\\u21D2\",\n  rceil: \"\\u2309\",\n  rdquo: \"\\u201D\",\n  real: \"\\u211C\",\n  reg: \"\\u00AE\",\n  rfloor: \"\\u230B\",\n  Rho: \"\\u03A1\",\n  rho: \"\\u03C1\",\n  rlm: \"\\u200F\",\n  rsaquo: \"\\u203A\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  sdot: \"\\u22C5\",\n  sect: \"\\u00A7\",\n  shy: \"\\u00AD\",\n  Sigma: \"\\u03A3\",\n  sigma: \"\\u03C3\",\n  sigmaf: \"\\u03C2\",\n  sim: \"\\u223C\",\n  spades: \"\\u2660\",\n  sub: \"\\u2282\",\n  sube: \"\\u2286\",\n  sum: \"\\u2211\",\n  sup: \"\\u2283\",\n  sup1: \"\\u00B9\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  supe: \"\\u2287\",\n  szlig: \"\\u00DF\",\n  Tau: \"\\u03A4\",\n  tau: \"\\u03C4\",\n  there4: \"\\u2234\",\n  Theta: \"\\u0398\",\n  theta: \"\\u03B8\",\n  thetasym: \"\\u03D1\",\n  thinsp: \"\\u2009\",\n  THORN: \"\\u00DE\",\n  thorn: \"\\u00FE\",\n  tilde: \"\\u02DC\",\n  times: \"\\u00D7\",\n  trade: \"\\u2122\",\n  Uacute: \"\\u00DA\",\n  uacute: \"\\u00FA\",\n  uarr: \"\\u2191\",\n  uArr: \"\\u21D1\",\n  Ucirc: \"\\u00DB\",\n  ucirc: \"\\u00FB\",\n  Ugrave: \"\\u00D9\",\n  ugrave: \"\\u00F9\",\n  uml: \"\\u00A8\",\n  upsih: \"\\u03D2\",\n  Upsilon: \"\\u03A5\",\n  upsilon: \"\\u03C5\",\n  Uuml: \"\\u00DC\",\n  uuml: \"\\u00FC\",\n  weierp: \"\\u2118\",\n  Xi: \"\\u039E\",\n  xi: \"\\u03BE\",\n  Yacute: \"\\u00DD\",\n  yacute: \"\\u00FD\",\n  yen: \"\\u00A5\",\n  yuml: \"\\u00FF\",\n  Yuml: \"\\u0178\",\n  Zeta: \"\\u0396\",\n  zeta: \"\\u03B6\",\n  zwj: \"\\u200D\",\n  zwnj: \"\\u200C\"\n};\n\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const NGSP_UNICODE = \"\\uE500\";\n\nNAMED_ENTITIES[\"ngsp\"] = NGSP_UNICODE;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport * as chars from \"./chars\";\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from \"./parse_util\";\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from \"./tags\";\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(public type: TokenType, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport function tokenize(\n  source: string,\n  url: string,\n  getTagDefinition: (tagName: string) => TagDefinition,\n  tokenizeExpansionForms = false,\n  interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n): TokenizeResult {\n  return new Tokenizer(\n    new ParseSourceFile(source, url),\n    getTagDefinition,\n    tokenizeExpansionForms,\n    interpolationConfig\n  ).tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? \"EOF\" : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass Tokenizer {\n  private _input: string;\n  private _length: number;\n  // Note: this is always lowercase!\n  private _peek = -1;\n  private _nextPeek = -1;\n  private _index = -1;\n  private _line = 0;\n  private _column = -1;\n  private _currentTokenStart: ParseLocation;\n  private _currentTokenType: TokenType;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation = false;\n\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source\n   * @param _getTagDefinition\n   * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n   * @param _interpolationConfig\n   */\n  constructor(\n    private _file: ParseSourceFile,\n    private _getTagDefinition: (tagName: string) => TagDefinition,\n    private _tokenizeIcu: boolean,\n    private _interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ) {\n    this._input = _file.content;\n    this._length = _file.content.length;\n    this._advance();\n  }\n\n  private _processCarriageReturns(content: string): string {\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, \"\\n\");\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._peek !== chars.$EOF) {\n      const start = this._getLocation();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        if (e instanceof ControlFlowError) {\n          this.errors.push(e.error);\n        } else {\n          throw e;\n        }\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._peek === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getLocation(): ParseLocation {\n    return new ParseLocation(this._file, this._index, this._line, this._column);\n  }\n\n  private _getSpan(\n    start: ParseLocation = this._getLocation(),\n    end: ParseLocation = this._getLocation()\n  ): ParseSourceSpan {\n    return new ParseSourceSpan(start, end);\n  }\n\n  private _beginToken(type: TokenType, start: ParseLocation = this._getLocation()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end: ParseLocation = this._getLocation()): Token {\n    const token = new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n    this.tokens.push(token);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return new ControlFlowError(error);\n  }\n\n  private _advance() {\n    if (this._index >= this._length) {\n      throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n    }\n    if (this._peek === chars.$LF) {\n      this._line++;\n      this._column = 0;\n    } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n      this._column++;\n    }\n    this._index++;\n    this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n    this._nextPeek = this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._peek === charCode) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._getLocation();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._index + len > this._length) {\n      return false;\n    }\n    const initialPosition = this._savePosition();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._restorePosition(initialPosition);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._getLocation();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._peek)) {\n      this._advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._getLocation();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._index - start.offset < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._peek !== char) {\n      this._advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._peek === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      const index = this._index;\n      this._advance();\n      return this._input[index];\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._getLocation();\n    this._advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const numberStart = this._getLocation().offset;\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      this._advance();\n      const strNum = this._input.substring(numberStart, this._index - 1);\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch (e) {\n        const entity = this._input.substring(start.offset + 1, this._index - 1);\n        throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n      }\n    } else {\n      const startPosition = this._savePosition();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        this._restorePosition(startPosition);\n        return \"&\";\n      }\n      this._advance();\n      const name = this._input.substring(start.offset + 1, this._index - 1);\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(decodeEntities: boolean, firstCharOfEnd: number, attemptEndRest: () => boolean): Token {\n    let tagCloseStart: ParseLocation;\n    const textStart = this._getLocation();\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n    const parts: string[] = [];\n    while (true) {\n      tagCloseStart = this._getLocation();\n      if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n        break;\n      }\n      if (this._index > tagCloseStart.offset) {\n        // add the characters consumed by the previous if statement to the output\n        parts.push(this._input.substring(tagCloseStart.offset, this._index));\n      }\n      while (this._peek !== firstCharOfEnd) {\n        parts.push(this._readChar(decodeEntities));\n      }\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(\"\"))], tagCloseStart);\n  }\n\n  private _consumeComment(start: ParseLocation) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr(\"->\"));\n    this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: ParseLocation) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr(\"CDATA[\");\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(\"]>\"));\n    this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: ParseLocation) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    this._attemptUntilChar(chars.$GT);\n    this._advance();\n    this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._index;\n    let prefix: string = null!;\n    while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n      this._advance();\n    }\n    let nameStart: number;\n    if (this._peek === chars.$COLON) {\n      this._advance();\n      prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n      nameStart = this._index;\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n    const name = this._input.substring(nameStart, this._index);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: ParseLocation) {\n    const savedPos = this._savePosition();\n    let tagName: string;\n    let lowercaseTagName: string;\n    try {\n      if (!chars.isAsciiLetter(this._peek)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      const nameStart = this._index;\n      this._consumeTagOpenStart(start);\n      tagName = this._input.substring(nameStart, this._index);\n      lowercaseTagName = tagName.toLowerCase();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof ControlFlowError) {\n        // When the start tag is invalid, assume we want a \"<\"\n        this._restorePosition(savedPos);\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken([\"<\"]);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(lowercaseTagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(lowercaseTagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n    this._endToken([null!, lowercaseTagName]);\n  }\n\n  private _consumeTagOpenStart(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    this._beginToken(TokenType.ATTR_VALUE);\n    let value: string;\n    if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n      const quoteChar = this._peek;\n      this._advance();\n      const parts: string[] = [];\n      while (this._peek !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join(\"\");\n      this._advance();\n    } else {\n      const valueStart = this._index;\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._input.substring(valueStart, this._index);\n    }\n    this._endToken([this._processCarriageReturns(value)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._getLocation();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n        this._interpolationConfig &&\n        this._inInterpolation &&\n        this._attemptStr(this._interpolationConfig.end)\n      ) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(\"\"))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _savePosition(): [number, number, number, number, number] {\n    return [this._peek, this._index, this._column, this._line, this.tokens.length];\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._index;\n    this._attemptUntilChar(char);\n    return this._input.substring(start, this._index);\n  }\n\n  private _restorePosition(position: [number, number, number, number, number]): void {\n    this._peek = position[0];\n    this._index = position[1];\n    this._column = position[2];\n    this._line = position[3];\n    const nbTokens = position[4];\n    if (nbTokens < this.tokens.length) {\n      // remove any extra tokens\n      this.tokens = this.tokens.slice(0, nbTokens);\n    }\n  }\n\n  private _isInExpansionCase(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START\n    );\n  }\n\n  private _isInExpansionForm(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START\n    );\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return (\n    chars.isWhitespace(code) ||\n    code === chars.$GT ||\n    code === chars.$SLASH ||\n    code === chars.$SQ ||\n    code === chars.$DQ ||\n    code === chars.$EQ\n  );\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (\n    (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) && (code < chars.$0 || code > chars.$9)\n  );\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionFormStart(input: string, offset: number, interpolationConfig: InterpolationConfig): boolean {\n  const isInterpolationStart = interpolationConfig\n    ? input.indexOf(interpolationConfig.start, offset) === offset\n    : false;\n\n  return input.charCodeAt(offset) === chars.$LBRACE && !isInterpolationStart;\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token | undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseError, ParseSourceSpan} from \"./parse_util\";\n\nimport * as html from \"./ast\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport * as lex from \"./lexer\";\nimport {TagDefinition, getNsPrefix, isNgContainer, mergeNsAndName} from \"./tags\";\n\nexport class TreeError extends ParseError {\n  static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string | null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(\n    source: string,\n    url: string,\n    parseExpansionForms = false,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ParseTreeResult {\n    const tokensAndErrors = lex.tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n\n    const treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n\n    return new ParseTreeResult(\n      treeAndErrors.rootNodes,\n      (tokensAndErrors.errors as ParseError[]).concat(treeAndErrors.errors)\n    );\n  }\n}\n\nclass _TreeBuilder {\n  private _index = -1;\n  private _peek: lex.Token;\n\n  private _rootNodes: html.Node[] = [];\n  private _errors: TreeError[] = [];\n\n  private _elementStack: html.Element[] = [];\n\n  constructor(private tokens: lex.Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): ParseTreeResult {\n    while (this._peek.type !== lex.TokenType.EOF) {\n      if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n        this._consumeStartTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === lex.TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n        this._peek.type === lex.TokenType.TEXT ||\n        this._peek.type === lex.TokenType.RAW_TEXT ||\n        this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT\n      ) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n    return new ParseTreeResult(this._rootNodes, this._errors);\n  }\n\n  private _advance(): lex.Token {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n\n  private _advanceIf(type: lex.TokenType): lex.Token | null {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n\n  private _consumeCdata(startToken: lex.Token) {\n    this._consumeText(this._advance());\n    this._advanceIf(lex.TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: lex.Token) {\n    const text = this._advanceIf(lex.TokenType.RAW_TEXT);\n    this._advanceIf(lex.TokenType.COMMENT_END);\n    const value = text !== null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: lex.Token) {\n    const switchValue = this._advance();\n\n    const type = this._advance();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) {\n        return;\n      } // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n    this._addToParent(\n      new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan)\n    );\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase | null {\n    const value = this._advance();\n\n    // read {\n    if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) {\n      return null;\n    }\n\n    const end = this._advance();\n    exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));\n\n    // parse everything in between { and }\n    const parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n    if (parsedExp.errors.length > 0) {\n      this._errors = this._errors.concat(parsedExp.errors as TreeError[]);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n    return new html.ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: lex.Token): lex.Token[] | null {\n    const exp: lex.Token[] = [];\n    const expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (\n        this._peek.type === lex.TokenType.EXPANSION_FORM_START ||\n        this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START\n      ) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) {\n            return exp;\n          }\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EOF) {\n        this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: lex.Token) {\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === \"\\n\") {\n      const parent = this._getParentElement();\n      if (parent !== null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n      }\n    }\n\n    if (text.length > 0) {\n      this._addToParent(new html.Text(text, token.sourceSpan));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: lex.Token) {\n    const prefix = startTagToken.parts[0];\n    const name = startTagToken.parts[1];\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === lex.TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this._errors.push(\n          TreeError.create(\n            fullName,\n            startTagToken.sourceSpan,\n            `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`\n          )\n        );\n      }\n    } else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.start;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n    const el = new html.Element(fullName, attrs, [], span, span, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      this._popElement(fullName);\n      el.endSourceSpan = span;\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    const tagDef = this.getTagDefinition(el.name);\n    const {parent, container} = this._getParentElementSkippingContainers();\n\n    if (parent && tagDef.requireExtraParent(parent.name)) {\n      const newParent = new html.Element(\n        tagDef.parentToAdd,\n        [],\n        [],\n        el.sourceSpan,\n        el.startSourceSpan,\n        el.endSourceSpan\n      );\n      this._insertBeforeContainer(parent, container, newParent);\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: lex.Token) {\n    const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this._getParentElement()) {\n      this._getParentElement()!.endSourceSpan = endTagToken.sourceSpan;\n    }\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this._errors.push(\n        TreeError.create(\n          fullName,\n          endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`\n        )\n      );\n    } else if (!this._popElement(fullName)) {\n      const errMsg = `Unexpected closing tag \"${\n        fullName\n      }\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _popElement(fullName: string): boolean {\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name === fullName) {\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return true;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: lex.Token): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let end = attrName.sourceSpan.end;\n    let value = \"\";\n    let valueSpan: ParseSourceSpan = undefined!;\n    if (this._peek.type === lex.TokenType.ATTR_VALUE) {\n      const valueToken = this._advance();\n      value = valueToken.parts[0];\n      end = valueToken.sourceSpan.end;\n      valueSpan = valueToken.sourceSpan;\n    }\n    return new html.Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n  }\n\n  private _getParentElement(): html.Element | null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  /**\n   * Returns the parent in the DOM and the container.\n   *\n   * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n   */\n  private _getParentElementSkippingContainers(): {parent: html.Element | null; container: html.Element | null} {\n    let container: html.Element | null = null;\n\n    for (let i = this._elementStack.length - 1; i >= 0; i--) {\n      if (!isNgContainer(this._elementStack[i].name)) {\n        return {parent: this._elementStack[i], container};\n      }\n      container = this._elementStack[i];\n    }\n\n    return {parent: null, container};\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent !== null) {\n      parent.children.push(node);\n    } else {\n      this._rootNodes.push(node);\n    }\n  }\n\n  /**\n   * Insert a node between the parent and the container.\n   * When no container is given, the node is appended as a child of the parent.\n   * Also updates the element stack accordingly.\n   *\n   * @internal\n   */\n  private _insertBeforeContainer(parent: html.Element, container: html.Element | null, node: html.Element) {\n    if (!container) {\n      this._addToParent(node);\n      this._elementStack.push(node);\n    } else {\n      if (parent) {\n        // replace the container with the new node in the children\n        const index = parent.children.indexOf(container);\n        parent.children[index] = node;\n      } else {\n        this._rootNodes.push(node);\n      }\n      node.children.push(container);\n      this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element | null): string {\n    if (prefix === null) {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix!;\n      if (prefix === null && parentElement !== null) {\n        prefix = getNsPrefix(parentElement.name);\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from \"./tags\";\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string;\n  contentType: TagContentType = TagContentType.PARSABLE_DATA;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n\n  closedByParent: boolean = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string|null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n\n  constructor(\n      {closedByChildren, requiredParents, implicitNamespacePrefix,\n       contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false,\n       ignoreFirstLf = false}: {\n        closedByChildren?: string[],\n        closedByParent?: boolean,\n        requiredParents?: string[],\n        implicitNamespacePrefix?: string,\n        contentType?: TagContentType,\n        isVoid?: boolean,\n        ignoreFirstLf?: boolean\n      } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    if (requiredParents && requiredParents.length > 0) {\n      this.requiredParents = {};\n      // The first parent is the list is automatically when none of the listed parents are present\n      this.parentToAdd = requiredParents[0];\n      requiredParents.forEach(tagName => this.requiredParents[tagName] = true);\n    }\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n  }\n\n  requireExtraParent(currentParent: string): boolean {\n    if (!this.requiredParents) {\n      return false;\n    }\n\n    if (!currentParent) {\n      return true;\n    }\n\n    const lcParent = currentParent.toLowerCase();\n    const isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n    return !isParentTemplate && this.requiredParents[lcParent] !== true;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nconst TAG_DEFINITIONS: {[key: string]: HtmlTagDefinition} = {\n  'base': new HtmlTagDefinition({isVoid: true}),\n  'meta': new HtmlTagDefinition({isVoid: true}),\n  'area': new HtmlTagDefinition({isVoid: true}),\n  'embed': new HtmlTagDefinition({isVoid: true}),\n  'link': new HtmlTagDefinition({isVoid: true}),\n  'img': new HtmlTagDefinition({isVoid: true}),\n  'input': new HtmlTagDefinition({isVoid: true}),\n  'param': new HtmlTagDefinition({isVoid: true}),\n  'hr': new HtmlTagDefinition({isVoid: true}),\n  'br': new HtmlTagDefinition({isVoid: true}),\n  'source': new HtmlTagDefinition({isVoid: true}),\n  'track': new HtmlTagDefinition({isVoid: true}),\n  'wbr': new HtmlTagDefinition({isVoid: true}),\n  'p': new HtmlTagDefinition({\n    closedByChildren: [\n      'address', 'article', 'aside', 'blockquote', 'div', 'dl',      'fieldset', 'footer', 'form',\n      'h1',      'h2',      'h3',    'h4',         'h5',  'h6',      'header',   'hgroup', 'hr',\n      'main',    'nav',     'ol',    'p',          'pre', 'section', 'table',    'ul'\n    ],\n    closedByParent: true\n  }),\n  'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n  'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n  'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n  'tr': new HtmlTagDefinition({\n    closedByChildren: ['tr'],\n    requiredParents: ['tbody', 'tfoot', 'thead'],\n    closedByParent: true\n  }),\n  'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'col': new HtmlTagDefinition({requiredParents: ['colgroup'], isVoid: true}),\n  'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n  'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n  'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n  'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n  'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n  'rb': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rt': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n  'rp': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n  'option': new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n  'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'title': new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT}),\n  'textarea':\n      new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n};\n\nconst _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nPluralPipe, I18nSelectPipe, NgLocaleLocalization} from \"@angular/common\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport * as xml from \"./xml_helper\";\n\nexport interface I18nMessagesById {\n  [msgId: string]: i18n.Node[];\n}\n\nexport interface XmlMessagesById {\n  [id: string]: xml.Node;\n}\n\nexport interface IcuContent {\n  cases: {[value: string]: html.Node[]};\n  expression: string;\n  type: string;\n}\n\nexport interface IcuContentStr {\n  cases: {[value: string]: string};\n  expression: string;\n  type: string;\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string | null;\n\n  toInternalName(publicName: string): string | null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string | null {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n\n  toInternalName(publicName: string): string | null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n\n  visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n\nconst i18nSelectPipe = new I18nSelectPipe();\nclass SerializerVisitor implements html.Visitor {\n  private i18nPluralPipe: I18nPluralPipe;\n  constructor(locale: string, private params: {[key: string]: any}) {\n    this.i18nPluralPipe = new I18nPluralPipe(new NgLocaleLocalization(locale));\n  }\n  visitElement(element: html.Element, context: any): any {\n    if (getHtmlTagDefinition(element.name).isVoid) {\n      return `<${element.name}${this.serializeNodes(element.attrs, \" \")}/>`;\n    }\n\n    return `<${element.name}${this.serializeNodes(element.attrs, \" \")}>${this.serializeNodes(element.children)}</${\n      element.name\n    }>`;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return `${attribute.name}=\"${attribute.value}\"`;\n  }\n\n  visitText(text: html.Text, context: any): any {\n    return text.value;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return `<!--${comment.value}-->`;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    const cases = {};\n    expansion.cases.forEach(c => (cases[c.value] = this.serializeNodes(c.expression)));\n\n    switch (expansion.type) {\n      case \"select\":\n        return i18nSelectPipe.transform(this.params[expansion.switchValue] || \"\", cases);\n      case \"plural\":\n        return this.i18nPluralPipe.transform(this.params[expansion.switchValue], cases);\n    }\n    throw new Error(`Unknown expansion type \"${expansion.type}\"`);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return ` ${expansionCase.value} {${this.serializeNodes(expansionCase.expression)}}`;\n  }\n\n  private serializeNodes(nodes: html.Node[], join = \"\"): string {\n    if (nodes.length === 0) {\n      return \"\";\n    }\n    return join + nodes.map(a => a.visit(this, null)).join(join);\n  }\n}\n\nexport function serializeNodes(nodes: html.Node[], locale: string, params: {[key: string]: any}): string[] {\n  return nodes.map(node => node.visit(new SerializerVisitor(locale, params), null));\n}\n\nexport class HtmlToXmlParser implements html.Visitor {\n  private errors: I18nError[];\n  private xmlMessagesById: {[id: string]: xml.Node};\n\n  constructor(private MESSAGE_TAG: string) {}\n\n  parse(content: string) {\n    this.xmlMessagesById = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this.errors = parser.errors;\n    html.visitAll(this, parser.rootNodes, null);\n\n    return {\n      xmlMessagesById: this.xmlMessagesById,\n      errors: this.errors\n    };\n  }\n\n  visitElement(element: html.Element, context: any): any {\n    switch (element.name) {\n      case this.MESSAGE_TAG:\n        const id = element.attrs.find(attr => attr.name === \"id\");\n        if (id) {\n          this.xmlMessagesById[id.value] = (element as any) as xml.Node;\n        }\n        break;\n      default:\n        html.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {}\n\n  visitText(text: html.Text, context: any): any {}\n\n  visitComment(comment: html.Comment, context: any): any {}\n\n  visitExpansion(expansion: html.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\n\nexport function digest(message: i18n.Message): string {\n  return message.id || sha1(serializeNodes(message.nodes).join(\"\") + `[${message.meaning}]`);\n}\n\nexport function decimalDigest(message: i18n.Message): string {\n  if (message.id) {\n    return message.id;\n  }\n\n  const visitor = new SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(\"\"), message.meaning);\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(\", \")}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(\", \")}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(\", \")}</ph name=\"${\n          ph.closeName\n        }\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass SerializerIgnoreIcuExpVisitor extends SerializerVisitor {\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(\", \")}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = stringToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Array(80);\n  let [a, b, c, d, e]: number[] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const [h0, h1, h2, h3, h4]: number[] = [a, b, c, d, e];\n\n    for (let j = 0; j < 80; j++) {\n      /* tslint:disable-next-line */\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const [f, k] = fk(j, b, c, d);\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];\n    }\n\n    [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];\n  }\n\n  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let [hi, lo] = [hash32(utf8, 0), hash32(utf8, 102072)];\n\n  if (hi === 0 && (lo === 0 || lo === 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string): string {\n  let [hi, lo] = fingerprint(msg);\n\n  if (meaning) {\n    const [him, lom] = fingerprint(meaning);\n    [hi, lo] = add64(rol64([hi, lo], 1), [him, lom]);\n  }\n\n  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n\nfunction hash32(str: string, c: number): number {\n  let [a, b] = [0x9e3779b9, 0x9e3779b9];\n  let i: number;\n\n  const len = str.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    c = add32(c, wordAt(str, i + 8, Endian.Little));\n    [a, b, c] = mix([a, b, c]);\n  }\n\n  a = add32(a, wordAt(str, i, Endian.Little));\n  b = add32(b, wordAt(str, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n\n  return mix([a, b, c])[2];\n}\n\n// clang-format off\nfunction mix([a, b, c]: [number, number, number]): [number, number, number] {\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 13;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 8;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 13;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 12;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 16;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 5;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 3;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 10;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64([ah, al]: [number, number], [bh, bl]: [number, number]): [number, number] {\n  const [carry, l] = add32to64(al, bl);\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64([hi, lo]: [number, number], count: number): [number, number] {\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction stringToWords32(str: string, endian: Endian): number[] {\n  const words32 = Array((str.length + 3) >>> 2);\n\n  for (let i = 0; i < words32.length; i++) {\n    words32[i] = wordAt(str, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(str: string, index: number): number {\n  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n\nfunction wordAt(str: string, index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): string {\n  return words32.reduce((str, word) => str + word32ToByteString(word), \"\");\n}\n\nfunction word32ToByteString(word: number): string {\n  let str = \"\";\n  for (let i = 0; i < 4; i++) {\n    str += String.fromCharCode((word >>> (8 * (3 - i))) & 0xff);\n  }\n  return str;\n}\n\nfunction byteStringToHexString(str: string): string {\n  let hex = \"\";\n  for (let i = 0; i < str.length; i++) {\n    const b = byteAt(str, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str: string): string {\n  let decimal = \"\";\n  let toThePower = \"1\";\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n    toThePower = numberTimesBigInt(256, toThePower);\n  }\n\n  return decimal\n    .split(\"\")\n    .reverse()\n    .join(\"\");\n}\n\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x: string, y: string): string {\n  let sum = \"\";\n  const len = Math.max(x.length, y.length);\n  for (let i = 0, carry = 0; i < len || carry; i++) {\n    const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n    if (tmpSum >= 10) {\n      carry = 1;\n      sum += tmpSum - 10;\n    } else {\n      carry = 0;\n      sum += tmpSum;\n    }\n  }\n\n  return sum;\n}\n\nfunction numberTimesBigInt(num: number, b: string): string {\n  let product = \"\";\n  let bToThePower = b;\n  for (; num !== 0; num = num >>> 1) {\n    if (num & 1) {\n      product = addBigInt(product, bToThePower);\n    }\n    bToThePower = addBigInt(bToThePower, bToThePower);\n  }\n  return product;\n}\n\nfunction utf8Encode(str: string): string {\n  let encoded = \"\";\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(((codePoint >> 6) & 0x1f) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(\n        (codePoint >> 12) | 0xe0,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(\n        ((codePoint >> 18) & 0x07) | 0xf0,\n        ((codePoint >> 12) & 0x3f) | 0x80,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    }\n  }\n\n  return encoded;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\n\nconst _VERSION = \"1.2\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:1.2\";\nconst _PLACEHOLDER_TAG = \"x\";\nconst _FILE_TAG = \"file\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"trans-unit\";\nconst _CONTEXT_GROUP_TAG = \"context-group\";\nconst _CONTEXT_TAG = \"context\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\n\nexport function xliffLoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliffParser = new XliffParser();\n  const {msgIdToHtml, errors} = xliffParser.parse(content);\n\n  // xml nodes to i18n messages\n  const i18nMessagesById: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nMessagesById[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nMessagesById;\n}\n\n// used to merge translations when extracting\nexport function xliffLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\n// http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport function xliffWrite(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const transUnits: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(6), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const contextTags: xml.Node[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      const contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: \"location\"});\n      contextGroupTag.children.push(\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"sourcefile\"}, [new xml.Text(source.filePath)]),\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"linenumber\"}, [new xml.Text(`${source.startLine}`)]),\n        new xml.CR(8)\n      );\n      contextTags.push(new xml.CR(8), contextGroupTag);\n    });\n\n    const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: \"html\"});\n    transUnit.children.push(\n      new xml.CR(8),\n      new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n      ...contextTags\n    );\n\n    if (message.description) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"description\"}, [new xml.Text(message.description)])\n      );\n    }\n\n    if (message.meaning) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"meaning\"}, [new xml.Text(message.meaning)])\n      );\n    }\n\n    transUnit.children.push(new xml.CR(6));\n\n    transUnits.push(new xml.CR(6), transUnit);\n  });\n\n  const body = new xml.Tag(\"body\", {}, [...transUnits, new xml.CR(4)]);\n  const file = new xml.Tag(\n    \"file\",\n    {\n      \"source-language\": locale || _DEFAULT_SOURCE_LANG,\n      datatype: \"plaintext\",\n      original: \"ng2.template\"\n    },\n    [new xml.CR(4), body, new xml.CR(2)]\n  );\n  const xliff = new xml.Tag(\"xliff\", {version: _VERSION, xmlns: _XMLNS}, [new xml.CR(2), file, new xml.CR()]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliffDigest = digest;\n\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"id\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}/>`})];\n    }\n\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}>`});\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, \"equiv-text\": `</${ph.tag}>`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": `{{${ph.value}}}`})];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \")}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n      return \"lb\";\n    case \"img\":\n      return \"image\";\n    default:\n      return `x-${tag}`;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {decimalDigest} from \"./digest\";\n\nconst _VERSION = \"2.0\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:2.0\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _PLACEHOLDER_SPANNING_TAG = \"pc\";\nconst _XLIFF_TAG = \"xliff\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"unit\";\nconst _NOTES_TAG = \"notes\";\nconst _NOTE_TAG = \"note\";\nconst _SEGMENT_TAG = \"segment\";\nconst _FILE_TAG = \"file\";\n\n// http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport function xliff2LoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliff2Parser = new Xliff2Parser();\n  const {msgIdToHtml, errors} = xliff2Parser.parse(content);\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nNodesByMsgId[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nNodesByMsgId;\n}\n\n// used to merge translations when extracting\nexport function xliff2LoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xliff2Write(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const units: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(4), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n    const notes = new xml.Tag(_NOTES_TAG);\n\n    if (message.description || message.meaning) {\n      if (message.description) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"description\"}, [new xml.Text(message.description)])\n        );\n      }\n\n      if (message.meaning) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"meaning\"}, [new xml.Text(message.meaning)])\n        );\n      }\n    }\n\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      notes.children.push(\n        new xml.CR(8),\n        new xml.Tag(_NOTE_TAG, {category: \"location\"}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    notes.children.push(new xml.CR(6));\n    unit.children.push(new xml.CR(6), notes);\n\n    const segment = new xml.Tag(_SEGMENT_TAG);\n\n    segment.children.push(new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new xml.CR(6));\n\n    unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n    units.push(new xml.CR(4), unit);\n  });\n\n  const file = new xml.Tag(_FILE_TAG, {original: \"ng.template\", id: \"ngi18n\"}, [...units, new xml.CR(2)]);\n\n  const xliff = new xml.Tag(_XLIFF_TAG, {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG}, [\n    new xml.CR(2),\n    file,\n    new xml.CR()\n  ]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliff2Digest = decimalDigest;\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const versionAttr = element.attrs.find(attr => attr.name === \"version\");\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== \"2.0\") {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[] | null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find(attr => attr.name === \"equiv\");\n        if (nameAttr) {\n          return [new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === \"equivStart\");\n        const endAttr = el.attrs.find(attr => attr.name === \"equivEnd\");\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n            new i18n.Placeholder(\"\", startId, el.sourceSpan),\n            ...el.children.map(node => node.visit(this, null)),\n            new i18n.Placeholder(\"\", endId, el.sourceSpan)\n          );\n        }\n        break;\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression))\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  private _nextPlaceholderId: number;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(\"\"));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{{${ph.value}}}`\n      })\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \");\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n      })\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n    case \"b\":\n    case \"i\":\n    case \"u\":\n      return \"fmt\";\n    case \"img\":\n      return \"image\";\n    case \"a\":\n      return \"link\";\n    default:\n      return \"other\";\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as ml from \"../ast/ast\";\nimport * as xml from \"./xml_helper\";\nimport {decimalDigest} from \"./digest\";\nimport {HtmlToXmlParser, PlaceholderMapper, SimplePlaceholderMapper, XmlMessagesById} from \"./serializer\";\n\nconst _MESSAGES_TAG = \"messagebundle\";\nconst _MESSAGE_TAG = \"msg\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _EXEMPLE_TAG = \"ex\";\nconst _SOURCE_TAG = \"source\";\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\n// used to merge translations when extracting\nexport function xmbLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_MESSAGE_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xmb parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xmbWrite(messages: i18n.Message[], locale: string | null, existingNodes: xml.Node[] = []): string {\n  const exampleVisitor = new ExampleVisitor();\n  const visitor = new Visitor();\n  const rootNode = new xml.Tag(_MESSAGES_TAG);\n\n  existingNodes.forEach(node => {\n    rootNode.children.push(new xml.CR(2), node);\n  });\n\n  // console.log(existingNodes);\n  messages.forEach(message => {\n    const attrs: {[k: string]: string} = {id: message.id};\n\n    if (message.description) {\n      attrs[\"desc\"] = message.description;\n    }\n\n    if (message.meaning) {\n      attrs[\"meaning\"] = message.meaning;\n    }\n\n    const sourceTags: xml.Tag[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      sourceTags.push(\n        new xml.Tag(_SOURCE_TAG, {}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    rootNode.children.push(\n      new xml.CR(2),\n      new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)])\n    );\n  });\n\n  rootNode.children.push(new xml.CR());\n\n  return xml.serialize([\n    new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}),\n    new xml.CR(),\n    new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n    new xml.CR(),\n    exampleVisitor.addDefaultExamples(rootNode),\n    new xml.CR()\n  ]);\n}\n\nexport function xmbDigest(message: i18n.Message): string {\n  return digest(message);\n}\n\nexport function xmbMapper(message: i18n.Message): PlaceholderMapper {\n  return new SimplePlaceholderMapper(message, toPublicName);\n}\n\nclass Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`<${ph.tag}>`)]);\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`</${ph.tag}>`)]);\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`{{${ph.value}}}`)]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [\n      new xml.Text(\n        `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n          .map((value: string) => value + \" {...}\")\n          .join(\" \")}}`\n      )\n    ]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length === 0) {\n        const exText = new xml.Text(tag.attrs[\"name\"] || \"...\");\n        tag.children = [new xml.Tag(_EXEMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: ml.Element): any {\n    const attrs = {};\n    element.attrs.forEach((attr: ml.Attribute) => {\n      attrs[attr.name] = attr.value;\n    });\n    const tag = new xml.Tag(element.name, attrs, element.children as any);\n    return this.visitTag(tag);\n  }\n\n  visitText(text: xml.Text): void {}\n\n  visitDeclaration(decl: xml.Declaration): void {}\n\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, \"_\");\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\nimport {xmbMapper} from \"./xmb\";\n\nconst _TRANSLATIONS_TAG = \"translationbundle\";\nconst _TRANSLATION_TAG = \"translation\";\nconst _PLACEHOLDER_TAG = \"ph\";\n\nexport function xtbLoadToI18n(content: string): I18nMessagesById {\n  // xtb to xml nodes\n  const xtbParser = new XtbParser();\n  const {msgIdToHtml, errors: parseErrors} = xtbParser.parse(content);\n\n  if (parseErrors.length) {\n    throw new Error(`xtb parse errors:\\n${parseErrors.join(\"\\n\")}`);\n  }\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  // Because we should be able to load xtb files that rely on features not supported by angular,\n  // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n  // converted\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const valueFn = () => {\n      const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId]);\n      if (errors.length) {\n        throw new Error(`xtb parse errors:\\n${errors.join(\"\\n\")}`);\n      }\n      return i18nNodes;\n    };\n    createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n  });\n\n  return i18nNodesByMsgId;\n}\n\nexport const xtbDigest = digest;\n\nexport const xtbMapper = xmbMapper;\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: _ => {\n      throw new Error(\"Could not overwrite an XTB translation\");\n    }\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  private _bundleDepth: number;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(xtb: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new Parser(getXmlTagDefinition).parse(xtb, \"\", false);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan!.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan!.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, \"Unexpected tag\");\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"name\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParserError {\n  public message: string;\n  constructor(message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n  constructor(public span: ParseSpan) {}\n  visit(visitor: AstVisitor, context: any = null): any {\n    return null;\n  }\n  toString(): string {\n    return \"AST\";\n  }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(span: ParseSpan, public prefix: string, public uninterpretedExpression: string, public location: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitQuote(this, context);\n  }\n  toString(): string {\n    return \"Quote\";\n  }\n}\n\nexport class EmptyExpr extends AST {\n  visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends AST {\n  constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, public value: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport interface LiteralMapKey {\n  key: string;\n  quoted: boolean;\n}\n\nexport class LiteralMap extends AST {\n  constructor(span: ParseSpan, public keys: LiteralMapKey[], public values: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(span: ParseSpan, public strings: any[], public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class MethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitMethodCall(this, context);\n  }\n}\n\nexport class SafeMethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeMethodCall(this, context);\n  }\n}\n\nexport class FunctionCall extends AST {\n  constructor(span: ParseSpan, public target: AST | null, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitFunctionCall(this, context);\n  }\n}\n\nexport class ASTWithSource extends AST {\n  constructor(public ast: AST, public source: string | null, public location: string, public errors: ParserError[]) {\n    super(new ParseSpan(0, source == null ? 0 : source.length));\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return this.ast.visit(visitor, context);\n  }\n  toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\nexport class TemplateBinding {\n  constructor(\n    public span: ParseSpan,\n    public key: string,\n    public keyIsVar: boolean,\n    public name: string,\n    public expression: ASTWithSource\n  ) {}\n}\n\nexport interface AstVisitor {\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  visitFunctionCall(ast: FunctionCall, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitMethodCall(ast: MethodCall, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visitBinary(ast: Binary, context: any): any {\n    ast.left.visit(this);\n    ast.right.visit(this);\n    return null;\n  }\n  visitChain(ast: Chain, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    ast.condition.visit(this);\n    ast.trueExp.visit(this);\n    ast.falseExp.visit(this);\n    return null;\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitFunctionCall(ast: FunctionCall, context: any): any {\n    ast.target!.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n    return null;\n  }\n  visitInterpolation(ast: Interpolation, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    return null;\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    return this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n    return null;\n  }\n  visitMethodCall(ast: MethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    ast.receiver.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitAll(asts: AST[], context: any): any {\n    asts.forEach(ast => ast.visit(this, context));\n    return null;\n  }\n  visitQuote(ast: Quote, context: any): any {\n    return null;\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    return new FunctionCall(ast.span, ast.target!.visit(this), this.visitAll(ast.args));\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = new Array(asts.length);\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(public index: number, public type: TokenType, public numValue: number, public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n\n  isNumber(): boolean {\n    return this.type === TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type === TokenType.String;\n  }\n\n  isOperator(operater: string): boolean {\n    return this.type === TokenType.Operator && this.strValue === operater;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === TokenType.Identifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type === TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"let\";\n  }\n\n  isKeywordAs(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"as\";\n  }\n\n  isKeywordNull(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"null\";\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"undefined\";\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"true\";\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"false\";\n  }\n\n  isKeywordThis(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"this\";\n  }\n\n  isError(): boolean {\n    return this.type === TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string | null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, \"\");\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, \"\");\n\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token | null {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (chars.isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, \"?\", chars.$PERIOD, \".\");\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\");\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\", chars.$EQ, \"=\");\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, \"&\", chars.$AMPERSAND, \"&\");\n      case chars.$BAR:\n        return this.scanComplexOperator(start, \"|\", chars.$BAR, \"|\");\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) {\n          this.advance();\n        }\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n    start: number,\n    one: string,\n    twoCode: number,\n    two: string,\n    threeCode?: number,\n    three?: string\n  ): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek === twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek === threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) {\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = this.index === start;\n    this.advance(); // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) {\n          this.advance();\n        }\n        if (!chars.isDigit(this.peek)) {\n          return this.error(\"Invalid exponent\", -1);\n        }\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance(); // Skip initial quote.\n\n    let buffer = \"\";\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek !== quote) {\n      if (this.peek === chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek === chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek === chars.$EOF) {\n        return this.error(\"Unterminated quote\", 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance(); // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (\n    (chars.$a <= code && code <= chars.$z) ||\n    (chars.$A <= code && code <= chars.$Z) ||\n    code === chars.$_ ||\n    code === chars.$$\n  );\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length === 0) {\n    return false;\n  }\n  const scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) {\n    return false;\n  }\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) {\n      return false;\n    }\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_ || code === chars.$$;\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code === chars.$e || code === chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code === chars.$MINUS || code === chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text, 10);\n  if (isNaN(result)) {\n    throw new Error(\"Invalid integer literal when parsing \" + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {escapeRegExp} from \"../ast/parse_util\";\n\nimport {\n  AST,\n  ASTWithSource,\n  AstVisitor,\n  Binary,\n  BindingPipe,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  FunctionCall,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  KeyedWrite,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  MethodCall,\n  NonNullAssert,\n  ParseSpan,\n  ParserError,\n  PrefixNot,\n  PropertyRead,\n  PropertyWrite,\n  Quote,\n  SafeMethodCall,\n  SafePropertyRead,\n  TemplateBinding\n} from \"./ast\";\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from \"./lexer\";\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(public templateBindings: TemplateBinding[], public warnings: string[], public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + \"([\\\\s\\\\S]*?)\" + escapeRegExp(config.end);\n  return new RegExp(pattern, \"g\");\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      true,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(`Host binding expression cannot contain ${errors.join(\" \")}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      false,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n  }\n\n  private _parseQuote(input: string | null, location: any): AST | null {\n    if (input === null) {\n      return null;\n    }\n    const prefixSeparatorIndex = input.indexOf(\":\");\n    if (prefixSeparatorIndex === -1) {\n      return null;\n    }\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) {\n      return null;\n    }\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(prefixToken: string | null, input: string, location: any): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new ParseAST(input, location, tokens, input.length, false, this.errors, 0).parseTemplateBindings();\n  }\n\n  parseInterpolation(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource | null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split === null) {\n      return null;\n    }\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new ParseAST(\n        input,\n        location,\n        tokens,\n        sourceToLex.length,\n        false,\n        this.errors,\n        split.offsets[i] + (expressionText.length - sourceToLex.length)\n      ).parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n      new Interpolation(new ParseSpan(0, input === null ? 0 : input.length), split.strings, expressions),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  splitInterpolation(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): SplitInterpolation | null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n          \"Blank expressions are not allowed in interpolated strings\",\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n          location\n        );\n        expressions.push(\"$implict\");\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource {\n    return new ASTWithSource(\n      new LiteralPrimitive(new ParseSpan(0, input === null ? 0 : input.length), input),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar === chars.$SLASH && outerQuote === null) {\n        return i;\n      }\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote === null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n        `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n        input,\n        `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n        location\n      );\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n    parts: string[],\n    partInErrIdx: number,\n    interpolationConfig: InterpolationConfig\n  ): number {\n    let errLocation = \"\";\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ? parts[j] : `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index = 0;\n\n  constructor(\n    public input: string,\n    public location: any,\n    public tokens: Token[],\n    public inputLength: number,\n    public parseAction: boolean,\n    private errors: ParserError[],\n    private offset: number\n  ) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  get inputIndex(): number {\n    return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n  }\n\n  span(start: number) {\n    return new ParseSpan(start, this.inputIndex);\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) {\n      return;\n    }\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) {\n      return;\n    }\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error(\"Binding expression cannot contain chained expression\");\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length === 0) {\n      return new EmptyExpr(this.span(start));\n    }\n    if (exprs.length === 1) {\n      return exprs[0];\n    }\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator(\"|\")) {\n      if (this.parseAction) {\n        this.error(\"Cannot have a pipe in an action expression\");\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator(\"|\"));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator(\"?\")) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator(\"||\")) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), \"||\", result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator(\"&&\")) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), \"&&\", result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"==\":\n        case \"===\":\n        case \"!=\":\n        case \"!==\":\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"<\":\n        case \">\":\n        case \"<=\":\n        case \">=\":\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"+\":\n        case \"-\":\n          this.advance();\n          const right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"*\":\n        case \"%\":\n        case \"/\":\n          this.advance();\n          const right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type === TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case \"+\":\n          this.advance();\n          return this.parsePrefix();\n        case \"-\":\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n        case \"!\":\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n      } else if (this.optionalOperator(\"?.\")) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator(\"=\")) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n      } else if (this.optionalOperator(\"!\")) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) : new MethodCall(span, receiver, id, args);\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator(\"=\")) {\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) {\n            this.error(\"Bindings cannot contain assignments\");\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) {\n      return [];\n    }\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` inbetween.\n   */\n  expectTemplateBindingKey(): string {\n    let result = \"\";\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator(\"-\");\n      if (operatorFound) {\n        result += \"-\";\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  parseTemplateBindings(): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n    let prefix: string = null!;\n    const warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const start = this.inputIndex;\n      let keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      const rawKey = this.expectTemplateBindingKey();\n      let key = rawKey;\n      if (!keyIsVar) {\n        if (prefix === null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let name: string = null!;\n      let expression: ASTWithSource = null!;\n      if (keyIsVar) {\n        if (this.optionalOperator(\"=\")) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = \"$implicit\";\n        }\n      } else if (this.peekKeywordAs()) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey(); // read local var name\n        keyIsVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const st = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(st - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (this.peekKeywordAs() && !keyIsVar) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        const letName = this.expectTemplateBindingKey(); // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null!));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number | null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number | null = null) {\n    if (index === null) {\n      index = this.index;\n    }\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) {\n    this.visitAll(ast.expressions);\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any) {\n    this.visitAll(ast.values);\n  }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) {\n    this.errors.push(\"pipes\");\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] {\n    return asts.map(node => node.visit(this));\n  }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * @internal\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string { return this._hashTag(`/${tag}`, {}, false); }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {InterpolationConfig} from \"../ast/interpolation_config\";\nimport {Parser} from \"./parser\";\nimport {Lexer} from \"./lexer\";\nimport {PlaceholderRegistry} from \"../serializers/placeholder\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {ParseSourceSpan} from \"../ast/parse_util\";\n\nconst _expParser = new Parser(new Lexer());\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(\n  interpolationConfig: InterpolationConfig\n): (nodes: html.Node[], meaning: string, description: string, id: string) => i18n.Message {\n  const visitor = new I18nVisitor(_expParser, interpolationConfig);\n\n  return (nodes: html.Node[], meaning: string, description: string, id: string) =>\n    visitor.toI18nMessage(nodes, meaning, description, id);\n}\n\nclass I18nVisitor implements html.Visitor {\n  private _isIcu: boolean;\n  private _icuDepth: number;\n  private _placeholderRegistry: PlaceholderRegistry;\n  private _placeholderToContent: {[phName: string]: string};\n  private _placeholderToMessage: {[phName: string]: i18n.Message};\n\n  constructor(private _expressionParser: Parser, private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(nodes: html.Node[], meaning: string, description: string, id: string): i18n.Message {\n    this._isIcu = nodes.length === 1 && nodes[0] instanceof html.Expansion;\n    this._icuDepth = 0;\n    this._placeholderRegistry = new PlaceholderRegistry();\n    this._placeholderToContent = {};\n    this._placeholderToMessage = {};\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, {});\n\n    return new i18n.Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n  }\n\n  visitElement(el: html.Element, context: any): i18n.Node {\n    const children = html.visitAll(this, el.children);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    this._placeholderToContent[startPhName] = el.sourceSpan ? el.sourceSpan!.toString() : \"\";\n\n    let closePhName = \"\";\n\n    if (!isVoid) {\n      closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      this._placeholderToContent[closePhName] = `</${el.name}>`;\n    }\n\n    return new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan!);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan!);\n  }\n\n  visitComment(comment: html.Comment, context: any): i18n.Node | null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): i18n.Node {\n    this._icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n        caze.expression.map(node => node.visit(this, {})),\n        caze.expSourceSpan\n      );\n    });\n    this._icuDepth--;\n\n    if (this._isIcu || this._icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      this._placeholderToContent[expPh] = icu.switchValue;\n\n      return i18nIcu;\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations. We need to create a new visitor (they are not re-entrant) to compute the\n    // message id.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = this._placeholderRegistry.getPlaceholderName(\"ICU\", icu.sourceSpan.toString());\n    const visitor = new I18nVisitor(this._expressionParser, this._interpolationConfig);\n    this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], \"\", \"\", \"\");\n    return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): i18n.Node {\n    throw new Error(\"Unreachable code\");\n  }\n\n  private _visitTextWithInterpolation(text: string, sourceSpan: ParseSourceSpan): i18n.Node {\n    const splitInterpolation = this._expressionParser.splitInterpolation(\n      text,\n      sourceSpan.start.toString(),\n      this._interpolationConfig\n    );\n\n    if (!splitInterpolation) {\n      // No expression, return a single text\n      return new i18n.Text(text, sourceSpan);\n    }\n\n    // Return a group of text + expressions\n    const nodes: i18n.Node[] = [];\n    const container = new i18n.Container(nodes, sourceSpan);\n    const {start: sDelimiter, end: eDelimiter} = this._interpolationConfig;\n\n    for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {\n      const expression = splitInterpolation.expressions[i];\n      const baseName = extractPlaceholderName(expression) || \"INTERPOLATION\";\n      const phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n\n      if (splitInterpolation.strings[i].length) {\n        // No need to add empty strings\n        nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));\n      }\n\n      nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));\n      this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n    }\n\n    // The last index contains no expression\n    const lastStringIdx = splitInterpolation.strings.length - 1;\n    if (splitInterpolation.strings[lastStringIdx].length) {\n      nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));\n    }\n    return container;\n  }\n}\n\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {createI18nMessageFactory} from \"./i18n\";\nimport {Parser, ParseTreeResult} from \"../ast/parser\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nMessagesById, PlaceholderMapper} from \"../serializers/serializer\";\nimport {MissingTranslationStrategy} from \"@angular/core\";\n\nconst _I18N_ATTR = \"i18n\";\n\nexport interface MessageMetadata {\n  meaning?: string;\n  description?: string;\n  id?: string;\n}\n\nexport class HtmlParser extends Parser {\n  constructor(private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    super(getHtmlTagDefinition);\n  }\n\n  parse(source: string, url: string, parseExpansionForms = false): ParseTreeResult {\n    return super.parse(source, url, parseExpansionForms, this.interpolationConfig);\n  }\n\n  /**\n   * Extract translatable messages from an html AST\n   */\n  extractMessages(nodes: html.Node[]): ExtractionResult {\n    const visitor = new Visitor([\"wrapper\"]);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.extract(wrapper, this.interpolationConfig);\n  }\n\n  mergeTranslations(\n    nodes: html.Node[],\n    translations: TranslationBundle,\n    params: {[key: string]: any},\n    metadata?: MessageMetadata,\n    implicitTags: string[] = []\n  ): ParseTreeResult {\n    const visitor = new Visitor(implicitTags);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.merge(wrapper, translations, this.interpolationConfig, params, metadata);\n  }\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n    private i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    public digest: (m: i18n.Message) => string,\n    interpolationConfig: InterpolationConfig,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n    console?: Console\n  ) {\n    this.i18nToHtml = new I18nToHtmlVisitor(\n      i18nNodesByMsgId,\n      digest,\n      mapperFactory!,\n      missingTranslationStrategy,\n      interpolationConfig,\n      console\n    );\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n    content: string,\n    url: string,\n    digest: (message: i18n.Message) => string,\n    createNameMapper: (message: i18n.Message) => PlaceholderMapper | null,\n    loadFct: (content: string, url: string) => I18nMessagesById,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): TranslationBundle {\n    const i18nNodesByMsgId = loadFct(content, url);\n    const digestFn = (m: i18n.Message) => digest(m);\n    const mapperFactory = (m: i18n.Message) => createNameMapper(m)!;\n    return new TranslationBundle(\n      i18nNodesByMsgId,\n      digestFn,\n      interpolationConfig,\n      missingTranslationStrategy,\n      mapperFactory,\n      console\n    );\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message, params): html.Node[] {\n    const htmlRes = this.i18nToHtml.convert(srcMsg, params);\n    if (htmlRes.errors.length) {\n      throw new Error(htmlRes.errors.join(\"\\n\"));\n    }\n\n    return htmlRes.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this.i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  private _srcMsg: i18n.Message;\n  private _contextStack: {msg: i18n.Message; mapper: (name: string) => string}[] = [];\n  private _errors: I18nError[] = [];\n  private _mapper: (name: string) => string;\n  private _params: {[key: string]: any};\n  private _paramKeys: string[];\n\n  constructor(\n    private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    private _digest: (m: i18n.Message) => string,\n    private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n    private _missingTranslationStrategy: MissingTranslationStrategy,\n    private _interpolationConfig?: InterpolationConfig,\n    private _console?: Console\n  ) {}\n\n  convert(srcMsg: i18n.Message, params: {[key: string]: any}): {nodes: html.Node[]; errors: I18nError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    this._params = params;\n    this._paramKeys = Object.keys(params);\n\n    // i18n to text\n    const text = this.convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const htmlParser = new HtmlParser().parse(text, url, true);\n\n    return {\n      nodes: htmlParser.rootNodes,\n      errors: [...this._errors, ...htmlParser.errors]\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map(n => n.visit(this)).join(\"\");\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression)\n      ? this._srcMsg.placeholders[icu.expression]\n      : icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(\" \")}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this.convertToValue(this._srcMsg.placeholders[phName]);\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this.convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return \"\";\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs)\n      .map(name => `${name}=\"${ph.attrs[name]}\"`)\n      .join(\" \");\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join(\"\");\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this.convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => (mapper ? mapper.toInternalName(name)! : name);\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        this._console.warn(`Missing translation for message \"${id}\"`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join(\"\");\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private convertToValue(placeholder: string): string {\n    const param = placeholder.replace(this._interpolationConfig.start, \"\").replace(this._interpolationConfig.end, \"\");\n    return this._paramKeys.indexOf(param) !== -1 ? this._params[param] : placeholder;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new I18nError(el.sourceSpan, msg));\n  }\n}\n\nenum VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass Visitor implements html.Visitor {\n  private depth: number;\n\n  // <el i18n>...</el>\n  private inI18nNode: boolean;\n  private inImplicitNode: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  private inI18nBlock: boolean;\n  private blockChildren: html.Node[] = [];\n  private blockStartDepth: number;\n\n  // {<icu message>}\n  private inIcu: boolean;\n\n  // set to void 0 when not in a section\n  private msgCountAtSectionStart: number | undefined;\n  private errors: I18nError[];\n  private mode: VisitorMode;\n\n  // VisitorMode.Extract only\n  private messages: i18n.Message[];\n\n  // VisitorMode.Merge only\n  private translations: TranslationBundle;\n  private createI18nMessage: (msg: html.Node[], meaning: string, description: string, id: string) => i18n.Message;\n  private metadata: MessageMetadata;\n  private params: {[key: string]: any};\n\n  constructor(private _implicitTags: string[] = []) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(node: html.Node, interpolationConfig: InterpolationConfig): ExtractionResult {\n    this.init(VisitorMode.Extract, interpolationConfig);\n\n    node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ExtractionResult(this.messages, this.errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n    node: html.Node,\n    translations: TranslationBundle,\n    interpolationConfig: InterpolationConfig,\n    params: {[key: string]: any},\n    metadata: MessageMetadata = {}\n  ): ParseTreeResult {\n    this.init(VisitorMode.Merge, interpolationConfig, params);\n    this.translations = translations;\n    this.metadata = metadata;\n\n    const translatedNode = node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ParseTreeResult(translatedNode.children, this.errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.ExpansionCase(\n        icuCase.value,\n        expression,\n        icuCase.sourceSpan,\n        icuCase.valueSourceSpan,\n        icuCase.expSourceSpan\n      );\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this.mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this.inIcu;\n\n    if (!this.inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this.isInTranslatableSection) {\n        this.addMessage([icu]);\n      }\n      this.inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this.inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return;\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this.isInTranslatableSection) {\n      this.mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element | null {\n    this.mayBeAddBlockChildren(el);\n    this.depth++;\n    const wasInI18nNode = this.inI18nNode;\n    const wasInImplicitNode = this.inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = getI18nAttr(el);\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this.inIcu && !this.isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this.inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this.isInTranslatableSection && !this.inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this.inI18nNode = true;\n        const message = this.addMessage(el.children, this.metadata)!;\n        translatedChildNodes = this.translateMessage(el, message);\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) {\n          this.openTranslatableSection(el);\n        }\n        html.visitAll(this, el.children);\n        if (isTranslatable) {\n          this._closeTranslatableSection(el, el.children);\n        }\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(el, \"Could not mark an element as translatable inside a translatable section\");\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this.mode === VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this.isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this.depth--;\n    this.inI18nNode = wasInI18nNode;\n    this.inImplicitNode = wasInImplicitNode;\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.Element(el.name, [], childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error(\"unreachable code\");\n  }\n\n  private init(mode: VisitorMode, interpolationConfig: InterpolationConfig, params: {[key: string]: any} = {}): void {\n    this.mode = mode;\n    this.inI18nBlock = false;\n    this.inI18nNode = false;\n    this.depth = 0;\n    this.inIcu = false;\n    this.msgCountAtSectionStart = undefined;\n    this.errors = [];\n    this.messages = [];\n    this.inImplicitNode = false;\n    this.createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    this.params = params;\n  }\n\n  // add a translatable message\n  private addMessage(ast: html.Node[], {meaning = \"\", description = \"\", id = \"\"} = {}): i18n.Message | null {\n    if (\n      ast.length === 0 ||\n      (ast.length === 1 && ast[0] instanceof html.Attribute && !(ast[0] as html.Attribute).value)\n    ) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const message = this.createI18nMessage(ast, meaning, description, id);\n    this.messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this.mode === VisitorMode.Merge) {\n      const nodes = this.translations.get(message, this.params);\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(el, `Translation unavailable for message id=\"${this.translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private mayBeAddBlockChildren(node: html.Node): void {\n    if (this.inI18nBlock && !this.inIcu && this.depth === this.blockStartDepth) {\n      this.blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private openTranslatableSection(node: html.Node): void {\n    if (this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section start\");\n    } else {\n      this.msgCountAtSectionStart = this.messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get isInTranslatableSection(): boolean {\n    return this.msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section end\");\n      return;\n    }\n\n    const startIndex = this.msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n      (count: number, n: html.Node): number => count + (n instanceof html.Comment ? 0 : 1),\n      0\n    );\n\n    if (significantChildren === 1) {\n      for (let i = this.messages.length - 1; i >= startIndex!; i--) {\n        const ast = this.messages[i].nodes;\n        if (!(ast.length === 1 && ast[0] instanceof i18n.Text)) {\n          this.messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this.msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this.errors.push(new I18nError(node.sourceSpan!, msg));\n  }\n}\n\nfunction getI18nAttr(p: html.Element): html.Attribute | null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n","import {\n  Inject,\n  Injectable,\n  InjectionToken,\n  LOCALE_ID,\n  MissingTranslationStrategy,\n  Optional,\n  TRANSLATIONS,\n  TRANSLATIONS_FORMAT\n} from \"@angular/core\";\nimport {xliffDigest, xliffLoadToI18n} from \"./serializers/xliff\";\nimport {xliff2Digest, xliff2LoadToI18n} from \"./serializers/xliff2\";\nimport {xtbDigest, xtbLoadToI18n, xtbMapper} from \"./serializers/xtb\";\nimport {HtmlParser, TranslationBundle} from \"./parser/html\";\nimport {I18nMessagesById, serializeNodes} from \"./serializers/serializer\";\nimport {Message} from \"./ast/i18n_ast\";\n\nexport declare interface I18n {\n  (def: string | I18nDef, params?: {[key: string]: any}): string;\n}\n\nexport interface I18nDef {\n  value: string;\n  id?: string;\n  meaning?: string;\n  description?: string;\n}\n\nexport const MISSING_TRANSLATION_STRATEGY = new InjectionToken<MissingTranslationStrategy>(\n  \"MissingTranslationStrategy\"\n);\n\n/**\n * A speculative polyfill to use i18n code translations\n */\n@Injectable()\nexport class I18n {\n  constructor(\n    @Inject(TRANSLATIONS_FORMAT) format: string,\n    @Inject(TRANSLATIONS) translations: string,\n    @Inject(LOCALE_ID) locale: string,\n    @Optional()\n    @Inject(MISSING_TRANSLATION_STRATEGY)\n    missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning\n  ) {\n    let loadFct: (content: string, url: string) => I18nMessagesById;\n    let digest: (message: Message) => string;\n    let createMapper = (message: Message) => null;\n    format = (format || \"xlf\").toLowerCase();\n    switch (format) {\n      case \"xtb\":\n        loadFct = xtbLoadToI18n;\n        digest = xtbDigest;\n        createMapper = xtbMapper;\n        break;\n      case \"xliff2\":\n      case \"xlf2\":\n        loadFct = xliff2LoadToI18n;\n        digest = xliff2Digest;\n        break;\n      case \"xliff\":\n      case \"xlf\":\n        loadFct = xliffLoadToI18n;\n        digest = xliffDigest;\n        break;\n      default:\n        throw new Error(`Unknown translations format ${format}`);\n    }\n    const htmlParser = new HtmlParser();\n\n    const translationsBundle = TranslationBundle.load(\n      translations,\n      \"i18n\",\n      digest,\n      createMapper,\n      loadFct,\n      missingTranslationStrategy\n    );\n\n    // todo use interpolation config\n    return (def: string | I18nDef, params: {[key: string]: any} = {}) => {\n      const content = typeof def === \"string\" ? def : def.value;\n      const metadata = {};\n      if (typeof def === \"object\") {\n        metadata[\"id\"] = def.id;\n        metadata[\"meaning\"] = def.meaning;\n        metadata[\"description\"] = def.description;\n      }\n      const htmlParserResult = htmlParser.parse(content, \"\", true);\n\n      if (htmlParserResult.errors.length) {\n        throw htmlParserResult.errors;\n      }\n\n      const mergedNodes = htmlParser.mergeTranslations(\n        htmlParserResult.rootNodes,\n        translationsBundle,\n        params,\n        metadata,\n        [\"wrapper\"]\n      );\n\n      return serializeNodes(mergedNodes.rootNodes, locale, params).join(\"\");\n    };\n  }\n}\n"]}