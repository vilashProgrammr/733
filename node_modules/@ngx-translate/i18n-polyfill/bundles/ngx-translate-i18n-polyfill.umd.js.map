{"version":3,"file":"ngx-translate-i18n-polyfill.umd.js.map","sources":[null,"ng://@ngx-translate/i18n-polyfill/src/ast/ast.ts","ng://@ngx-translate/i18n-polyfill/src/ast/i18n_ast.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xml_helper.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parse_util.ts","ng://@ngx-translate/i18n-polyfill/src/ast/interpolation_config.ts","ng://@ngx-translate/i18n-polyfill/src/ast/chars.ts","ng://@ngx-translate/i18n-polyfill/src/ast/tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parser.ts","ng://@ngx-translate/i18n-polyfill/src/ast/xml_tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/html_tags.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/serializer.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/digest.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff2.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xmb.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xtb.ts","ng://@ngx-translate/i18n-polyfill/src/parser/ast.ts","ng://@ngx-translate/i18n-polyfill/src/parser/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/parser/parser.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/placeholder.ts","ng://@ngx-translate/i18n-polyfill/src/parser/i18n.ts","ng://@ngx-translate/i18n-polyfill/src/parser/html.ts","ng://@ngx-translate/i18n-polyfill/src/i18n-polyfill.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion implements Node {\n  constructor(\n    public switchValue: string,\n    public type: string,\n    public cases: ExpansionCase[],\n    public sourceSpan: ParseSourceSpan,\n    public switchValueSourceSpan: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements Node {\n  constructor(\n    public value: string,\n    public expression: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public valueSourceSpan: ParseSourceSpan,\n    public expSourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    public valueSpan?: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n    public name: string,\n    public attrs: Attribute[],\n    public children: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan | null = null,\n    public endSourceSpan: ParseSourceSpan | null = null\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements Node {\n  constructor(public value: string | null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit\n    ? (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context)\n    : (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport class Message {\n  sources: MessageSpan[];\n\n  /**\n   * @param source message AST\n   * @param placeholders maps placeholder names to static content\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param id\n   */\n  constructor(\n    public nodes: Node[],\n    public placeholders: {[phName: string]: string},\n    public placeholderToMessage: {[phName: string]: Message},\n    public meaning: string,\n    public description: string,\n    public id: string\n  ) {\n    if (nodes.length) {\n      this.sources = [\n        {\n          filePath: nodes[0].sourceSpan.start.file.url,\n          startLine: nodes[0].sourceSpan.start.line + 1,\n          startCol: nodes[0].sourceSpan.start.col + 1,\n          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n          endCol: nodes[0].sourceSpan.start.col + 1\n        }\n      ];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  public expressionPlaceholder: string;\n  constructor(\n    public expression: string,\n    public type: string,\n    public cases: {[k: string]: Node},\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n    public tag: string,\n    public attrs: {[k: string]: string},\n    public startName: string,\n    public closeName: string,\n    public children: Node[],\n    public isVoid: boolean,\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => (cases[key] = icu.cases[key].visit(this, context)));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport * as ml from \"../ast/ast\";\r\n\r\nexport interface IVisitor {\r\n  visitTag(tag: Tag): any;\r\n  visitElement(element: ml.Element): any;\r\n  visitText(text: Text): any;\r\n  visitDeclaration(decl: Declaration): any;\r\n  visitDoctype(doctype: Doctype): any;\r\n}\r\n\r\nclass Visitor implements IVisitor {\r\n  visitTag(tag: Tag): string {\r\n    const strAttrs = this._serializeAttributes(tag.attrs);\r\n    if (tag.children.length === 0) {\r\n      return `<${tag.name}${strAttrs}/>`;\r\n    }\r\n\r\n    const strChildren = tag.children.map(node => node.visit(this));\r\n    return `<${tag.name}${strAttrs}>${strChildren.join(\"\")}</${tag.name}>`;\r\n  }\r\n\r\n  visitText(text: Text): string {\r\n    return _escapeXml(text.value);\r\n  }\r\n\r\n  visitElement(element: ml.Element) {\r\n    const attrs = {};\r\n    element.attrs.forEach((attr: ml.Attribute) => {\r\n      attrs[attr.name] = attr.value;\r\n    });\r\n    const tag = new Tag(element.name, attrs, element.children as any);\r\n    return this.visitTag(tag);\r\n  }\r\n\r\n  visitDeclaration(decl: Declaration): string {\r\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\r\n  }\r\n\r\n  private _serializeAttributes(attrs: {[k: string]: string}) {\r\n    const strAttrs = Object.keys(attrs)\r\n      .map((name: string) => `${name}=\"${_escapeXml(attrs[name])}\"`)\r\n      .join(\" \");\r\n    return strAttrs.length > 0 ? \" \" + strAttrs : \"\";\r\n  }\r\n\r\n  visitDoctype(doctype: Doctype): any {\r\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\r\n  }\r\n}\r\n\r\nconst _visitor = new Visitor();\r\n\r\nexport function serialize(nodes: Node[]): string {\r\n  return nodes.map((node: Node): string => node.visit(_visitor)).join(\"\");\r\n}\r\n\r\nexport interface Node {\r\n  visit(visitor: IVisitor): any;\r\n}\r\n\r\nexport class Declaration implements Node {\r\n  constructor(public attrs: {[k: string]: string}) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDeclaration(this);\r\n  }\r\n}\r\n\r\nexport class Doctype implements Node {\r\n  constructor(public rootTag: string, public dtd: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDoctype(this);\r\n  }\r\n}\r\n\r\nexport class Tag implements Node {\r\n  constructor(public name: string, public attrs: {[k: string]: string} = {}, public children: Node[] = []) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitTag(this);\r\n  }\r\n}\r\n\r\nexport class Text implements Node {\r\n  constructor(public value: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitText(this);\r\n  }\r\n}\r\n\r\nexport class CR extends Text {\r\n  constructor(ws = 0) {\r\n    super(`\\n${new Array(ws + 1).join(\" \")}`);\r\n  }\r\n}\r\n\r\nconst _ESCAPED_CHARS: [RegExp, string][] = [\r\n  [/&/g, \"&amp;\"],\r\n  [/\"/g, \"&quot;\"],\r\n  [/'/g, \"&apos;\"],\r\n  [/</g, \"&lt;\"],\r\n  [/>/g, \"&gt;\"]\r\n];\r\n\r\nfunction _escapeXml(text: string): string {\r\n  return _ESCAPED_CHARS.reduce((str: string, entry: [RegExp, string]) => str.replace(entry[0], entry[1]), text);\r\n}\r\n","import {I18nDef} from \"../i18n-polyfill\";\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParseLocation {\n  constructor(public file: ParseSourceFile, public offset: number, public line: number, public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.line}:${this.col}` : \"\";\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string; after: string} | null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url = \"\") {}\n}\n\nexport class ParseSourceSpan {\n  constructor(public start: ParseLocation, public end: ParseLocation, public details: string | null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR\n}\n\nexport class ParseError {\n  constructor(\n    public span: ParseSourceSpan,\n    public msg: string,\n    public level: ParseErrorLevel = ParseErrorLevel.ERROR\n  ) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? ` (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : \"\";\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : \"\";\n    return `${this.msg}${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n  constructor(span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class InterpolationConfig {\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig = new InterpolationConfig(\"{{\", \"}}\");\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || code === $NBSP;\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return (code >= $a && code <= $z) || (code >= $A && code <= $Z);\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return (code >= $a && code <= $f) || (code >= $A && code <= $F) || isDigit(code);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string | null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n\n  requireExtraParent(currentParent: string): boolean;\n\n  isClosedByChild(name: string): boolean;\n}\n\nexport function splitNsName(elementName: string): [string | null, string] {\n  if (elementName[0] !== \":\") {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(\":\", 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-container\";\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-content\";\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-template\";\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string | null): string | null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\n\nexport const NAMED_ENTITIES: {[k: string]: string} = {\n  Aacute: \"\\u00C1\",\n  aacute: \"\\u00E1\",\n  Acirc: \"\\u00C2\",\n  acirc: \"\\u00E2\",\n  acute: \"\\u00B4\",\n  AElig: \"\\u00C6\",\n  aelig: \"\\u00E6\",\n  Agrave: \"\\u00C0\",\n  agrave: \"\\u00E0\",\n  alefsym: \"\\u2135\",\n  Alpha: \"\\u0391\",\n  alpha: \"\\u03B1\",\n  amp: \"&\",\n  and: \"\\u2227\",\n  ang: \"\\u2220\",\n  apos: \"\\u0027\",\n  Aring: \"\\u00C5\",\n  aring: \"\\u00E5\",\n  asymp: \"\\u2248\",\n  Atilde: \"\\u00C3\",\n  atilde: \"\\u00E3\",\n  Auml: \"\\u00C4\",\n  auml: \"\\u00E4\",\n  bdquo: \"\\u201E\",\n  Beta: \"\\u0392\",\n  beta: \"\\u03B2\",\n  brvbar: \"\\u00A6\",\n  bull: \"\\u2022\",\n  cap: \"\\u2229\",\n  Ccedil: \"\\u00C7\",\n  ccedil: \"\\u00E7\",\n  cedil: \"\\u00B8\",\n  cent: \"\\u00A2\",\n  Chi: \"\\u03A7\",\n  chi: \"\\u03C7\",\n  circ: \"\\u02C6\",\n  clubs: \"\\u2663\",\n  cong: \"\\u2245\",\n  copy: \"\\u00A9\",\n  crarr: \"\\u21B5\",\n  cup: \"\\u222A\",\n  curren: \"\\u00A4\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  darr: \"\\u2193\",\n  dArr: \"\\u21D3\",\n  deg: \"\\u00B0\",\n  Delta: \"\\u0394\",\n  delta: \"\\u03B4\",\n  diams: \"\\u2666\",\n  divide: \"\\u00F7\",\n  Eacute: \"\\u00C9\",\n  eacute: \"\\u00E9\",\n  Ecirc: \"\\u00CA\",\n  ecirc: \"\\u00EA\",\n  Egrave: \"\\u00C8\",\n  egrave: \"\\u00E8\",\n  empty: \"\\u2205\",\n  emsp: \"\\u2003\",\n  ensp: \"\\u2002\",\n  Epsilon: \"\\u0395\",\n  epsilon: \"\\u03B5\",\n  equiv: \"\\u2261\",\n  Eta: \"\\u0397\",\n  eta: \"\\u03B7\",\n  ETH: \"\\u00D0\",\n  eth: \"\\u00F0\",\n  Euml: \"\\u00CB\",\n  euml: \"\\u00EB\",\n  euro: \"\\u20AC\",\n  exist: \"\\u2203\",\n  fnof: \"\\u0192\",\n  forall: \"\\u2200\",\n  frac12: \"\\u00BD\",\n  frac14: \"\\u00BC\",\n  frac34: \"\\u00BE\",\n  frasl: \"\\u2044\",\n  Gamma: \"\\u0393\",\n  gamma: \"\\u03B3\",\n  ge: \"\\u2265\",\n  gt: \">\",\n  harr: \"\\u2194\",\n  hArr: \"\\u21D4\",\n  hearts: \"\\u2665\",\n  hellip: \"\\u2026\",\n  Iacute: \"\\u00CD\",\n  iacute: \"\\u00ED\",\n  Icirc: \"\\u00CE\",\n  icirc: \"\\u00EE\",\n  iexcl: \"\\u00A1\",\n  Igrave: \"\\u00CC\",\n  igrave: \"\\u00EC\",\n  image: \"\\u2111\",\n  infin: \"\\u221E\",\n  int: \"\\u222B\",\n  Iota: \"\\u0399\",\n  iota: \"\\u03B9\",\n  iquest: \"\\u00BF\",\n  isin: \"\\u2208\",\n  Iuml: \"\\u00CF\",\n  iuml: \"\\u00EF\",\n  Kappa: \"\\u039A\",\n  kappa: \"\\u03BA\",\n  Lambda: \"\\u039B\",\n  lambda: \"\\u03BB\",\n  lang: \"\\u27E8\",\n  laquo: \"\\u00AB\",\n  larr: \"\\u2190\",\n  lArr: \"\\u21D0\",\n  lceil: \"\\u2308\",\n  ldquo: \"\\u201C\",\n  le: \"\\u2264\",\n  lfloor: \"\\u230A\",\n  lowast: \"\\u2217\",\n  loz: \"\\u25CA\",\n  lrm: \"\\u200E\",\n  lsaquo: \"\\u2039\",\n  lsquo: \"\\u2018\",\n  lt: \"<\",\n  macr: \"\\u00AF\",\n  mdash: \"\\u2014\",\n  micro: \"\\u00B5\",\n  middot: \"\\u00B7\",\n  minus: \"\\u2212\",\n  Mu: \"\\u039C\",\n  mu: \"\\u03BC\",\n  nabla: \"\\u2207\",\n  nbsp: \"\\u00A0\",\n  ndash: \"\\u2013\",\n  ne: \"\\u2260\",\n  ni: \"\\u220B\",\n  not: \"\\u00AC\",\n  notin: \"\\u2209\",\n  nsub: \"\\u2284\",\n  Ntilde: \"\\u00D1\",\n  ntilde: \"\\u00F1\",\n  Nu: \"\\u039D\",\n  nu: \"\\u03BD\",\n  Oacute: \"\\u00D3\",\n  oacute: \"\\u00F3\",\n  Ocirc: \"\\u00D4\",\n  ocirc: \"\\u00F4\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Ograve: \"\\u00D2\",\n  ograve: \"\\u00F2\",\n  oline: \"\\u203E\",\n  Omega: \"\\u03A9\",\n  omega: \"\\u03C9\",\n  Omicron: \"\\u039F\",\n  omicron: \"\\u03BF\",\n  oplus: \"\\u2295\",\n  or: \"\\u2228\",\n  ordf: \"\\u00AA\",\n  ordm: \"\\u00BA\",\n  Oslash: \"\\u00D8\",\n  oslash: \"\\u00F8\",\n  Otilde: \"\\u00D5\",\n  otilde: \"\\u00F5\",\n  otimes: \"\\u2297\",\n  Ouml: \"\\u00D6\",\n  ouml: \"\\u00F6\",\n  para: \"\\u00B6\",\n  permil: \"\\u2030\",\n  perp: \"\\u22A5\",\n  Phi: \"\\u03A6\",\n  phi: \"\\u03C6\",\n  Pi: \"\\u03A0\",\n  pi: \"\\u03C0\",\n  piv: \"\\u03D6\",\n  plusmn: \"\\u00B1\",\n  pound: \"\\u00A3\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  prod: \"\\u220F\",\n  prop: \"\\u221D\",\n  Psi: \"\\u03A8\",\n  psi: \"\\u03C8\",\n  quot: \"\\u0022\",\n  radic: \"\\u221A\",\n  rang: \"\\u27E9\",\n  raquo: \"\\u00BB\",\n  rarr: \"\\u2192\",\n  rArr: \"\\u21D2\",\n  rceil: \"\\u2309\",\n  rdquo: \"\\u201D\",\n  real: \"\\u211C\",\n  reg: \"\\u00AE\",\n  rfloor: \"\\u230B\",\n  Rho: \"\\u03A1\",\n  rho: \"\\u03C1\",\n  rlm: \"\\u200F\",\n  rsaquo: \"\\u203A\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  sdot: \"\\u22C5\",\n  sect: \"\\u00A7\",\n  shy: \"\\u00AD\",\n  Sigma: \"\\u03A3\",\n  sigma: \"\\u03C3\",\n  sigmaf: \"\\u03C2\",\n  sim: \"\\u223C\",\n  spades: \"\\u2660\",\n  sub: \"\\u2282\",\n  sube: \"\\u2286\",\n  sum: \"\\u2211\",\n  sup: \"\\u2283\",\n  sup1: \"\\u00B9\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  supe: \"\\u2287\",\n  szlig: \"\\u00DF\",\n  Tau: \"\\u03A4\",\n  tau: \"\\u03C4\",\n  there4: \"\\u2234\",\n  Theta: \"\\u0398\",\n  theta: \"\\u03B8\",\n  thetasym: \"\\u03D1\",\n  thinsp: \"\\u2009\",\n  THORN: \"\\u00DE\",\n  thorn: \"\\u00FE\",\n  tilde: \"\\u02DC\",\n  times: \"\\u00D7\",\n  trade: \"\\u2122\",\n  Uacute: \"\\u00DA\",\n  uacute: \"\\u00FA\",\n  uarr: \"\\u2191\",\n  uArr: \"\\u21D1\",\n  Ucirc: \"\\u00DB\",\n  ucirc: \"\\u00FB\",\n  Ugrave: \"\\u00D9\",\n  ugrave: \"\\u00F9\",\n  uml: \"\\u00A8\",\n  upsih: \"\\u03D2\",\n  Upsilon: \"\\u03A5\",\n  upsilon: \"\\u03C5\",\n  Uuml: \"\\u00DC\",\n  uuml: \"\\u00FC\",\n  weierp: \"\\u2118\",\n  Xi: \"\\u039E\",\n  xi: \"\\u03BE\",\n  Yacute: \"\\u00DD\",\n  yacute: \"\\u00FD\",\n  yen: \"\\u00A5\",\n  yuml: \"\\u00FF\",\n  Yuml: \"\\u0178\",\n  Zeta: \"\\u0396\",\n  zeta: \"\\u03B6\",\n  zwj: \"\\u200D\",\n  zwnj: \"\\u200C\"\n};\n\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const NGSP_UNICODE = \"\\uE500\";\n\nNAMED_ENTITIES[\"ngsp\"] = NGSP_UNICODE;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport * as chars from \"./chars\";\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from \"./parse_util\";\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from \"./tags\";\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(public type: TokenType, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport function tokenize(\n  source: string,\n  url: string,\n  getTagDefinition: (tagName: string) => TagDefinition,\n  tokenizeExpansionForms = false,\n  interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n): TokenizeResult {\n  return new Tokenizer(\n    new ParseSourceFile(source, url),\n    getTagDefinition,\n    tokenizeExpansionForms,\n    interpolationConfig\n  ).tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? \"EOF\" : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass Tokenizer {\n  private _input: string;\n  private _length: number;\n  // Note: this is always lowercase!\n  private _peek = -1;\n  private _nextPeek = -1;\n  private _index = -1;\n  private _line = 0;\n  private _column = -1;\n  private _currentTokenStart: ParseLocation;\n  private _currentTokenType: TokenType;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation = false;\n\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source\n   * @param _getTagDefinition\n   * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n   * @param _interpolationConfig\n   */\n  constructor(\n    private _file: ParseSourceFile,\n    private _getTagDefinition: (tagName: string) => TagDefinition,\n    private _tokenizeIcu: boolean,\n    private _interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ) {\n    this._input = _file.content;\n    this._length = _file.content.length;\n    this._advance();\n  }\n\n  private _processCarriageReturns(content: string): string {\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, \"\\n\");\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._peek !== chars.$EOF) {\n      const start = this._getLocation();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        if (e instanceof ControlFlowError) {\n          this.errors.push(e.error);\n        } else {\n          throw e;\n        }\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._peek === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getLocation(): ParseLocation {\n    return new ParseLocation(this._file, this._index, this._line, this._column);\n  }\n\n  private _getSpan(\n    start: ParseLocation = this._getLocation(),\n    end: ParseLocation = this._getLocation()\n  ): ParseSourceSpan {\n    return new ParseSourceSpan(start, end);\n  }\n\n  private _beginToken(type: TokenType, start: ParseLocation = this._getLocation()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end: ParseLocation = this._getLocation()): Token {\n    const token = new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n    this.tokens.push(token);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return new ControlFlowError(error);\n  }\n\n  private _advance() {\n    if (this._index >= this._length) {\n      throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n    }\n    if (this._peek === chars.$LF) {\n      this._line++;\n      this._column = 0;\n    } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n      this._column++;\n    }\n    this._index++;\n    this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n    this._nextPeek = this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._peek === charCode) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._getLocation();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._index + len > this._length) {\n      return false;\n    }\n    const initialPosition = this._savePosition();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._restorePosition(initialPosition);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._getLocation();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._peek)) {\n      this._advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._getLocation();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._index - start.offset < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._peek !== char) {\n      this._advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._peek === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      const index = this._index;\n      this._advance();\n      return this._input[index];\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._getLocation();\n    this._advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const numberStart = this._getLocation().offset;\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      this._advance();\n      const strNum = this._input.substring(numberStart, this._index - 1);\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch (e) {\n        const entity = this._input.substring(start.offset + 1, this._index - 1);\n        throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n      }\n    } else {\n      const startPosition = this._savePosition();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        this._restorePosition(startPosition);\n        return \"&\";\n      }\n      this._advance();\n      const name = this._input.substring(start.offset + 1, this._index - 1);\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(decodeEntities: boolean, firstCharOfEnd: number, attemptEndRest: () => boolean): Token {\n    let tagCloseStart: ParseLocation;\n    const textStart = this._getLocation();\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n    const parts: string[] = [];\n    while (true) {\n      tagCloseStart = this._getLocation();\n      if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n        break;\n      }\n      if (this._index > tagCloseStart.offset) {\n        // add the characters consumed by the previous if statement to the output\n        parts.push(this._input.substring(tagCloseStart.offset, this._index));\n      }\n      while (this._peek !== firstCharOfEnd) {\n        parts.push(this._readChar(decodeEntities));\n      }\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(\"\"))], tagCloseStart);\n  }\n\n  private _consumeComment(start: ParseLocation) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr(\"->\"));\n    this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: ParseLocation) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr(\"CDATA[\");\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(\"]>\"));\n    this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: ParseLocation) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    this._attemptUntilChar(chars.$GT);\n    this._advance();\n    this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._index;\n    let prefix: string = null!;\n    while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n      this._advance();\n    }\n    let nameStart: number;\n    if (this._peek === chars.$COLON) {\n      this._advance();\n      prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n      nameStart = this._index;\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n    const name = this._input.substring(nameStart, this._index);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: ParseLocation) {\n    const savedPos = this._savePosition();\n    let tagName: string;\n    let lowercaseTagName: string;\n    try {\n      if (!chars.isAsciiLetter(this._peek)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      const nameStart = this._index;\n      this._consumeTagOpenStart(start);\n      tagName = this._input.substring(nameStart, this._index);\n      lowercaseTagName = tagName.toLowerCase();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof ControlFlowError) {\n        // When the start tag is invalid, assume we want a \"<\"\n        this._restorePosition(savedPos);\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken([\"<\"]);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(lowercaseTagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(lowercaseTagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n    this._endToken([null!, lowercaseTagName]);\n  }\n\n  private _consumeTagOpenStart(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    this._beginToken(TokenType.ATTR_VALUE);\n    let value: string;\n    if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n      const quoteChar = this._peek;\n      this._advance();\n      const parts: string[] = [];\n      while (this._peek !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join(\"\");\n      this._advance();\n    } else {\n      const valueStart = this._index;\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._input.substring(valueStart, this._index);\n    }\n    this._endToken([this._processCarriageReturns(value)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._getLocation();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n        this._interpolationConfig &&\n        this._inInterpolation &&\n        this._attemptStr(this._interpolationConfig.end)\n      ) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(\"\"))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _savePosition(): [number, number, number, number, number] {\n    return [this._peek, this._index, this._column, this._line, this.tokens.length];\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._index;\n    this._attemptUntilChar(char);\n    return this._input.substring(start, this._index);\n  }\n\n  private _restorePosition(position: [number, number, number, number, number]): void {\n    this._peek = position[0];\n    this._index = position[1];\n    this._column = position[2];\n    this._line = position[3];\n    const nbTokens = position[4];\n    if (nbTokens < this.tokens.length) {\n      // remove any extra tokens\n      this.tokens = this.tokens.slice(0, nbTokens);\n    }\n  }\n\n  private _isInExpansionCase(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START\n    );\n  }\n\n  private _isInExpansionForm(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START\n    );\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return (\n    chars.isWhitespace(code) ||\n    code === chars.$GT ||\n    code === chars.$SLASH ||\n    code === chars.$SQ ||\n    code === chars.$DQ ||\n    code === chars.$EQ\n  );\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (\n    (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) && (code < chars.$0 || code > chars.$9)\n  );\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionFormStart(input: string, offset: number, interpolationConfig: InterpolationConfig): boolean {\n  const isInterpolationStart = interpolationConfig\n    ? input.indexOf(interpolationConfig.start, offset) === offset\n    : false;\n\n  return input.charCodeAt(offset) === chars.$LBRACE && !isInterpolationStart;\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token | undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseError, ParseSourceSpan} from \"./parse_util\";\n\nimport * as html from \"./ast\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport * as lex from \"./lexer\";\nimport {TagDefinition, getNsPrefix, isNgContainer, mergeNsAndName} from \"./tags\";\n\nexport class TreeError extends ParseError {\n  static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string | null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(\n    source: string,\n    url: string,\n    parseExpansionForms = false,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ParseTreeResult {\n    const tokensAndErrors = lex.tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n\n    const treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n\n    return new ParseTreeResult(\n      treeAndErrors.rootNodes,\n      (tokensAndErrors.errors as ParseError[]).concat(treeAndErrors.errors)\n    );\n  }\n}\n\nclass _TreeBuilder {\n  private _index = -1;\n  private _peek: lex.Token;\n\n  private _rootNodes: html.Node[] = [];\n  private _errors: TreeError[] = [];\n\n  private _elementStack: html.Element[] = [];\n\n  constructor(private tokens: lex.Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): ParseTreeResult {\n    while (this._peek.type !== lex.TokenType.EOF) {\n      if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n        this._consumeStartTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === lex.TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n        this._peek.type === lex.TokenType.TEXT ||\n        this._peek.type === lex.TokenType.RAW_TEXT ||\n        this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT\n      ) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n    return new ParseTreeResult(this._rootNodes, this._errors);\n  }\n\n  private _advance(): lex.Token {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n\n  private _advanceIf(type: lex.TokenType): lex.Token | null {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n\n  private _consumeCdata(startToken: lex.Token) {\n    this._consumeText(this._advance());\n    this._advanceIf(lex.TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: lex.Token) {\n    const text = this._advanceIf(lex.TokenType.RAW_TEXT);\n    this._advanceIf(lex.TokenType.COMMENT_END);\n    const value = text !== null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: lex.Token) {\n    const switchValue = this._advance();\n\n    const type = this._advance();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) {\n        return;\n      } // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n    this._addToParent(\n      new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan)\n    );\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase | null {\n    const value = this._advance();\n\n    // read {\n    if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) {\n      return null;\n    }\n\n    const end = this._advance();\n    exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));\n\n    // parse everything in between { and }\n    const parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n    if (parsedExp.errors.length > 0) {\n      this._errors = this._errors.concat(parsedExp.errors as TreeError[]);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n    return new html.ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: lex.Token): lex.Token[] | null {\n    const exp: lex.Token[] = [];\n    const expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (\n        this._peek.type === lex.TokenType.EXPANSION_FORM_START ||\n        this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START\n      ) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) {\n            return exp;\n          }\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EOF) {\n        this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: lex.Token) {\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === \"\\n\") {\n      const parent = this._getParentElement();\n      if (parent !== null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n      }\n    }\n\n    if (text.length > 0) {\n      this._addToParent(new html.Text(text, token.sourceSpan));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: lex.Token) {\n    const prefix = startTagToken.parts[0];\n    const name = startTagToken.parts[1];\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === lex.TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this._errors.push(\n          TreeError.create(\n            fullName,\n            startTagToken.sourceSpan,\n            `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`\n          )\n        );\n      }\n    } else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.start;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n    const el = new html.Element(fullName, attrs, [], span, span, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      this._popElement(fullName);\n      el.endSourceSpan = span;\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    const tagDef = this.getTagDefinition(el.name);\n    const {parent, container} = this._getParentElementSkippingContainers();\n\n    if (parent && tagDef.requireExtraParent(parent.name)) {\n      const newParent = new html.Element(\n        tagDef.parentToAdd,\n        [],\n        [],\n        el.sourceSpan,\n        el.startSourceSpan,\n        el.endSourceSpan\n      );\n      this._insertBeforeContainer(parent, container, newParent);\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: lex.Token) {\n    const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this._getParentElement()) {\n      this._getParentElement()!.endSourceSpan = endTagToken.sourceSpan;\n    }\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this._errors.push(\n        TreeError.create(\n          fullName,\n          endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`\n        )\n      );\n    } else if (!this._popElement(fullName)) {\n      const errMsg = `Unexpected closing tag \"${\n        fullName\n      }\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _popElement(fullName: string): boolean {\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name === fullName) {\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return true;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: lex.Token): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let end = attrName.sourceSpan.end;\n    let value = \"\";\n    let valueSpan: ParseSourceSpan = undefined!;\n    if (this._peek.type === lex.TokenType.ATTR_VALUE) {\n      const valueToken = this._advance();\n      value = valueToken.parts[0];\n      end = valueToken.sourceSpan.end;\n      valueSpan = valueToken.sourceSpan;\n    }\n    return new html.Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n  }\n\n  private _getParentElement(): html.Element | null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  /**\n   * Returns the parent in the DOM and the container.\n   *\n   * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n   */\n  private _getParentElementSkippingContainers(): {parent: html.Element | null; container: html.Element | null} {\n    let container: html.Element | null = null;\n\n    for (let i = this._elementStack.length - 1; i >= 0; i--) {\n      if (!isNgContainer(this._elementStack[i].name)) {\n        return {parent: this._elementStack[i], container};\n      }\n      container = this._elementStack[i];\n    }\n\n    return {parent: null, container};\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent !== null) {\n      parent.children.push(node);\n    } else {\n      this._rootNodes.push(node);\n    }\n  }\n\n  /**\n   * Insert a node between the parent and the container.\n   * When no container is given, the node is appended as a child of the parent.\n   * Also updates the element stack accordingly.\n   *\n   * @internal\n   */\n  private _insertBeforeContainer(parent: html.Element, container: html.Element | null, node: html.Element) {\n    if (!container) {\n      this._addToParent(node);\n      this._elementStack.push(node);\n    } else {\n      if (parent) {\n        // replace the container with the new node in the children\n        const index = parent.children.indexOf(container);\n        parent.children[index] = node;\n      } else {\n        this._rootNodes.push(node);\n      }\n      node.children.push(container);\n      this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element | null): string {\n    if (prefix === null) {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix!;\n      if (prefix === null && parentElement !== null) {\n        prefix = getNsPrefix(parentElement.name);\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from \"./tags\";\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string;\n  contentType: TagContentType = TagContentType.PARSABLE_DATA;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n\n  closedByParent: boolean = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string|null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n\n  constructor(\n      {closedByChildren, requiredParents, implicitNamespacePrefix,\n       contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false,\n       ignoreFirstLf = false}: {\n        closedByChildren?: string[],\n        closedByParent?: boolean,\n        requiredParents?: string[],\n        implicitNamespacePrefix?: string,\n        contentType?: TagContentType,\n        isVoid?: boolean,\n        ignoreFirstLf?: boolean\n      } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    if (requiredParents && requiredParents.length > 0) {\n      this.requiredParents = {};\n      // The first parent is the list is automatically when none of the listed parents are present\n      this.parentToAdd = requiredParents[0];\n      requiredParents.forEach(tagName => this.requiredParents[tagName] = true);\n    }\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n  }\n\n  requireExtraParent(currentParent: string): boolean {\n    if (!this.requiredParents) {\n      return false;\n    }\n\n    if (!currentParent) {\n      return true;\n    }\n\n    const lcParent = currentParent.toLowerCase();\n    const isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n    return !isParentTemplate && this.requiredParents[lcParent] !== true;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nconst TAG_DEFINITIONS: {[key: string]: HtmlTagDefinition} = {\n  'base': new HtmlTagDefinition({isVoid: true}),\n  'meta': new HtmlTagDefinition({isVoid: true}),\n  'area': new HtmlTagDefinition({isVoid: true}),\n  'embed': new HtmlTagDefinition({isVoid: true}),\n  'link': new HtmlTagDefinition({isVoid: true}),\n  'img': new HtmlTagDefinition({isVoid: true}),\n  'input': new HtmlTagDefinition({isVoid: true}),\n  'param': new HtmlTagDefinition({isVoid: true}),\n  'hr': new HtmlTagDefinition({isVoid: true}),\n  'br': new HtmlTagDefinition({isVoid: true}),\n  'source': new HtmlTagDefinition({isVoid: true}),\n  'track': new HtmlTagDefinition({isVoid: true}),\n  'wbr': new HtmlTagDefinition({isVoid: true}),\n  'p': new HtmlTagDefinition({\n    closedByChildren: [\n      'address', 'article', 'aside', 'blockquote', 'div', 'dl',      'fieldset', 'footer', 'form',\n      'h1',      'h2',      'h3',    'h4',         'h5',  'h6',      'header',   'hgroup', 'hr',\n      'main',    'nav',     'ol',    'p',          'pre', 'section', 'table',    'ul'\n    ],\n    closedByParent: true\n  }),\n  'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n  'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n  'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n  'tr': new HtmlTagDefinition({\n    closedByChildren: ['tr'],\n    requiredParents: ['tbody', 'tfoot', 'thead'],\n    closedByParent: true\n  }),\n  'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'col': new HtmlTagDefinition({requiredParents: ['colgroup'], isVoid: true}),\n  'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n  'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n  'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n  'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n  'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n  'rb': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rt': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n  'rp': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n  'option': new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n  'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'title': new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT}),\n  'textarea':\n      new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n};\n\nconst _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nPluralPipe, I18nSelectPipe, NgLocaleLocalization} from \"@angular/common\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport * as xml from \"./xml_helper\";\n\nexport interface I18nMessagesById {\n  [msgId: string]: i18n.Node[];\n}\n\nexport interface XmlMessagesById {\n  [id: string]: xml.Node;\n}\n\nexport interface IcuContent {\n  cases: {[value: string]: html.Node[]};\n  expression: string;\n  type: string;\n}\n\nexport interface IcuContentStr {\n  cases: {[value: string]: string};\n  expression: string;\n  type: string;\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string | null;\n\n  toInternalName(publicName: string): string | null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string | null {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n\n  toInternalName(publicName: string): string | null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n\n  visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n\nconst i18nSelectPipe = new I18nSelectPipe();\nclass SerializerVisitor implements html.Visitor {\n  private i18nPluralPipe: I18nPluralPipe;\n  constructor(locale: string, private params: {[key: string]: any}) {\n    this.i18nPluralPipe = new I18nPluralPipe(new NgLocaleLocalization(locale));\n  }\n  visitElement(element: html.Element, context: any): any {\n    if (getHtmlTagDefinition(element.name).isVoid) {\n      return `<${element.name}${this.serializeNodes(element.attrs, \" \")}/>`;\n    }\n\n    return `<${element.name}${this.serializeNodes(element.attrs, \" \")}>${this.serializeNodes(element.children)}</${\n      element.name\n    }>`;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return `${attribute.name}=\"${attribute.value}\"`;\n  }\n\n  visitText(text: html.Text, context: any): any {\n    return text.value;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return `<!--${comment.value}-->`;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    const cases = {};\n    expansion.cases.forEach(c => (cases[c.value] = this.serializeNodes(c.expression)));\n\n    switch (expansion.type) {\n      case \"select\":\n        return i18nSelectPipe.transform(this.params[expansion.switchValue] || \"\", cases);\n      case \"plural\":\n        return this.i18nPluralPipe.transform(this.params[expansion.switchValue], cases);\n    }\n    throw new Error(`Unknown expansion type \"${expansion.type}\"`);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return ` ${expansionCase.value} {${this.serializeNodes(expansionCase.expression)}}`;\n  }\n\n  private serializeNodes(nodes: html.Node[], join = \"\"): string {\n    if (nodes.length === 0) {\n      return \"\";\n    }\n    return join + nodes.map(a => a.visit(this, null)).join(join);\n  }\n}\n\nexport function serializeNodes(nodes: html.Node[], locale: string, params: {[key: string]: any}): string[] {\n  return nodes.map(node => node.visit(new SerializerVisitor(locale, params), null));\n}\n\nexport class HtmlToXmlParser implements html.Visitor {\n  private errors: I18nError[];\n  private xmlMessagesById: {[id: string]: xml.Node};\n\n  constructor(private MESSAGE_TAG: string) {}\n\n  parse(content: string) {\n    this.xmlMessagesById = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this.errors = parser.errors;\n    html.visitAll(this, parser.rootNodes, null);\n\n    return {\n      xmlMessagesById: this.xmlMessagesById,\n      errors: this.errors\n    };\n  }\n\n  visitElement(element: html.Element, context: any): any {\n    switch (element.name) {\n      case this.MESSAGE_TAG:\n        const id = element.attrs.find(attr => attr.name === \"id\");\n        if (id) {\n          this.xmlMessagesById[id.value] = (element as any) as xml.Node;\n        }\n        break;\n      default:\n        html.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {}\n\n  visitText(text: html.Text, context: any): any {}\n\n  visitComment(comment: html.Comment, context: any): any {}\n\n  visitExpansion(expansion: html.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\n\nexport function digest(message: i18n.Message): string {\n  return message.id || sha1(serializeNodes(message.nodes).join(\"\") + `[${message.meaning}]`);\n}\n\nexport function decimalDigest(message: i18n.Message): string {\n  if (message.id) {\n    return message.id;\n  }\n\n  const visitor = new SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(\"\"), message.meaning);\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(\", \")}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(\", \")}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(\", \")}</ph name=\"${\n          ph.closeName\n        }\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass SerializerIgnoreIcuExpVisitor extends SerializerVisitor {\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(\", \")}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = stringToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Array(80);\n  let [a, b, c, d, e]: number[] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const [h0, h1, h2, h3, h4]: number[] = [a, b, c, d, e];\n\n    for (let j = 0; j < 80; j++) {\n      /* tslint:disable-next-line */\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const [f, k] = fk(j, b, c, d);\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];\n    }\n\n    [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];\n  }\n\n  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let [hi, lo] = [hash32(utf8, 0), hash32(utf8, 102072)];\n\n  if (hi === 0 && (lo === 0 || lo === 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string): string {\n  let [hi, lo] = fingerprint(msg);\n\n  if (meaning) {\n    const [him, lom] = fingerprint(meaning);\n    [hi, lo] = add64(rol64([hi, lo], 1), [him, lom]);\n  }\n\n  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n\nfunction hash32(str: string, c: number): number {\n  let [a, b] = [0x9e3779b9, 0x9e3779b9];\n  let i: number;\n\n  const len = str.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    c = add32(c, wordAt(str, i + 8, Endian.Little));\n    [a, b, c] = mix([a, b, c]);\n  }\n\n  a = add32(a, wordAt(str, i, Endian.Little));\n  b = add32(b, wordAt(str, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n\n  return mix([a, b, c])[2];\n}\n\n// clang-format off\nfunction mix([a, b, c]: [number, number, number]): [number, number, number] {\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 13;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 8;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 13;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 12;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 16;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 5;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 3;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 10;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64([ah, al]: [number, number], [bh, bl]: [number, number]): [number, number] {\n  const [carry, l] = add32to64(al, bl);\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64([hi, lo]: [number, number], count: number): [number, number] {\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction stringToWords32(str: string, endian: Endian): number[] {\n  const words32 = Array((str.length + 3) >>> 2);\n\n  for (let i = 0; i < words32.length; i++) {\n    words32[i] = wordAt(str, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(str: string, index: number): number {\n  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n\nfunction wordAt(str: string, index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): string {\n  return words32.reduce((str, word) => str + word32ToByteString(word), \"\");\n}\n\nfunction word32ToByteString(word: number): string {\n  let str = \"\";\n  for (let i = 0; i < 4; i++) {\n    str += String.fromCharCode((word >>> (8 * (3 - i))) & 0xff);\n  }\n  return str;\n}\n\nfunction byteStringToHexString(str: string): string {\n  let hex = \"\";\n  for (let i = 0; i < str.length; i++) {\n    const b = byteAt(str, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str: string): string {\n  let decimal = \"\";\n  let toThePower = \"1\";\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n    toThePower = numberTimesBigInt(256, toThePower);\n  }\n\n  return decimal\n    .split(\"\")\n    .reverse()\n    .join(\"\");\n}\n\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x: string, y: string): string {\n  let sum = \"\";\n  const len = Math.max(x.length, y.length);\n  for (let i = 0, carry = 0; i < len || carry; i++) {\n    const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n    if (tmpSum >= 10) {\n      carry = 1;\n      sum += tmpSum - 10;\n    } else {\n      carry = 0;\n      sum += tmpSum;\n    }\n  }\n\n  return sum;\n}\n\nfunction numberTimesBigInt(num: number, b: string): string {\n  let product = \"\";\n  let bToThePower = b;\n  for (; num !== 0; num = num >>> 1) {\n    if (num & 1) {\n      product = addBigInt(product, bToThePower);\n    }\n    bToThePower = addBigInt(bToThePower, bToThePower);\n  }\n  return product;\n}\n\nfunction utf8Encode(str: string): string {\n  let encoded = \"\";\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(((codePoint >> 6) & 0x1f) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(\n        (codePoint >> 12) | 0xe0,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(\n        ((codePoint >> 18) & 0x07) | 0xf0,\n        ((codePoint >> 12) & 0x3f) | 0x80,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    }\n  }\n\n  return encoded;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\n\nconst _VERSION = \"1.2\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:1.2\";\nconst _PLACEHOLDER_TAG = \"x\";\nconst _FILE_TAG = \"file\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"trans-unit\";\nconst _CONTEXT_GROUP_TAG = \"context-group\";\nconst _CONTEXT_TAG = \"context\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\n\nexport function xliffLoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliffParser = new XliffParser();\n  const {msgIdToHtml, errors} = xliffParser.parse(content);\n\n  // xml nodes to i18n messages\n  const i18nMessagesById: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nMessagesById[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nMessagesById;\n}\n\n// used to merge translations when extracting\nexport function xliffLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\n// http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport function xliffWrite(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const transUnits: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(6), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const contextTags: xml.Node[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      const contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: \"location\"});\n      contextGroupTag.children.push(\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"sourcefile\"}, [new xml.Text(source.filePath)]),\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"linenumber\"}, [new xml.Text(`${source.startLine}`)]),\n        new xml.CR(8)\n      );\n      contextTags.push(new xml.CR(8), contextGroupTag);\n    });\n\n    const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: \"html\"});\n    transUnit.children.push(\n      new xml.CR(8),\n      new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n      ...contextTags\n    );\n\n    if (message.description) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"description\"}, [new xml.Text(message.description)])\n      );\n    }\n\n    if (message.meaning) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"meaning\"}, [new xml.Text(message.meaning)])\n      );\n    }\n\n    transUnit.children.push(new xml.CR(6));\n\n    transUnits.push(new xml.CR(6), transUnit);\n  });\n\n  const body = new xml.Tag(\"body\", {}, [...transUnits, new xml.CR(4)]);\n  const file = new xml.Tag(\n    \"file\",\n    {\n      \"source-language\": locale || _DEFAULT_SOURCE_LANG,\n      datatype: \"plaintext\",\n      original: \"ng2.template\"\n    },\n    [new xml.CR(4), body, new xml.CR(2)]\n  );\n  const xliff = new xml.Tag(\"xliff\", {version: _VERSION, xmlns: _XMLNS}, [new xml.CR(2), file, new xml.CR()]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliffDigest = digest;\n\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"id\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}/>`})];\n    }\n\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}>`});\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, \"equiv-text\": `</${ph.tag}>`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": `{{${ph.value}}}`})];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \")}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n      return \"lb\";\n    case \"img\":\n      return \"image\";\n    default:\n      return `x-${tag}`;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {decimalDigest} from \"./digest\";\n\nconst _VERSION = \"2.0\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:2.0\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _PLACEHOLDER_SPANNING_TAG = \"pc\";\nconst _XLIFF_TAG = \"xliff\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"unit\";\nconst _NOTES_TAG = \"notes\";\nconst _NOTE_TAG = \"note\";\nconst _SEGMENT_TAG = \"segment\";\nconst _FILE_TAG = \"file\";\n\n// http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport function xliff2LoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliff2Parser = new Xliff2Parser();\n  const {msgIdToHtml, errors} = xliff2Parser.parse(content);\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nNodesByMsgId[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nNodesByMsgId;\n}\n\n// used to merge translations when extracting\nexport function xliff2LoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xliff2Write(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const units: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(4), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n    const notes = new xml.Tag(_NOTES_TAG);\n\n    if (message.description || message.meaning) {\n      if (message.description) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"description\"}, [new xml.Text(message.description)])\n        );\n      }\n\n      if (message.meaning) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"meaning\"}, [new xml.Text(message.meaning)])\n        );\n      }\n    }\n\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      notes.children.push(\n        new xml.CR(8),\n        new xml.Tag(_NOTE_TAG, {category: \"location\"}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    notes.children.push(new xml.CR(6));\n    unit.children.push(new xml.CR(6), notes);\n\n    const segment = new xml.Tag(_SEGMENT_TAG);\n\n    segment.children.push(new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new xml.CR(6));\n\n    unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n    units.push(new xml.CR(4), unit);\n  });\n\n  const file = new xml.Tag(_FILE_TAG, {original: \"ng.template\", id: \"ngi18n\"}, [...units, new xml.CR(2)]);\n\n  const xliff = new xml.Tag(_XLIFF_TAG, {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG}, [\n    new xml.CR(2),\n    file,\n    new xml.CR()\n  ]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliff2Digest = decimalDigest;\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const versionAttr = element.attrs.find(attr => attr.name === \"version\");\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== \"2.0\") {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[] | null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find(attr => attr.name === \"equiv\");\n        if (nameAttr) {\n          return [new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === \"equivStart\");\n        const endAttr = el.attrs.find(attr => attr.name === \"equivEnd\");\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n            new i18n.Placeholder(\"\", startId, el.sourceSpan),\n            ...el.children.map(node => node.visit(this, null)),\n            new i18n.Placeholder(\"\", endId, el.sourceSpan)\n          );\n        }\n        break;\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression))\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  private _nextPlaceholderId: number;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(\"\"));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{{${ph.value}}}`\n      })\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \");\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n      })\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n    case \"b\":\n    case \"i\":\n    case \"u\":\n      return \"fmt\";\n    case \"img\":\n      return \"image\";\n    case \"a\":\n      return \"link\";\n    default:\n      return \"other\";\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as ml from \"../ast/ast\";\nimport * as xml from \"./xml_helper\";\nimport {decimalDigest} from \"./digest\";\nimport {HtmlToXmlParser, PlaceholderMapper, SimplePlaceholderMapper, XmlMessagesById} from \"./serializer\";\n\nconst _MESSAGES_TAG = \"messagebundle\";\nconst _MESSAGE_TAG = \"msg\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _EXEMPLE_TAG = \"ex\";\nconst _SOURCE_TAG = \"source\";\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\n// used to merge translations when extracting\nexport function xmbLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_MESSAGE_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xmb parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xmbWrite(messages: i18n.Message[], locale: string | null, existingNodes: xml.Node[] = []): string {\n  const exampleVisitor = new ExampleVisitor();\n  const visitor = new Visitor();\n  const rootNode = new xml.Tag(_MESSAGES_TAG);\n\n  existingNodes.forEach(node => {\n    rootNode.children.push(new xml.CR(2), node);\n  });\n\n  // console.log(existingNodes);\n  messages.forEach(message => {\n    const attrs: {[k: string]: string} = {id: message.id};\n\n    if (message.description) {\n      attrs[\"desc\"] = message.description;\n    }\n\n    if (message.meaning) {\n      attrs[\"meaning\"] = message.meaning;\n    }\n\n    const sourceTags: xml.Tag[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      sourceTags.push(\n        new xml.Tag(_SOURCE_TAG, {}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    rootNode.children.push(\n      new xml.CR(2),\n      new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)])\n    );\n  });\n\n  rootNode.children.push(new xml.CR());\n\n  return xml.serialize([\n    new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}),\n    new xml.CR(),\n    new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n    new xml.CR(),\n    exampleVisitor.addDefaultExamples(rootNode),\n    new xml.CR()\n  ]);\n}\n\nexport function xmbDigest(message: i18n.Message): string {\n  return digest(message);\n}\n\nexport function xmbMapper(message: i18n.Message): PlaceholderMapper {\n  return new SimplePlaceholderMapper(message, toPublicName);\n}\n\nclass Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`<${ph.tag}>`)]);\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`</${ph.tag}>`)]);\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`{{${ph.value}}}`)]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [\n      new xml.Text(\n        `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n          .map((value: string) => value + \" {...}\")\n          .join(\" \")}}`\n      )\n    ]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length === 0) {\n        const exText = new xml.Text(tag.attrs[\"name\"] || \"...\");\n        tag.children = [new xml.Tag(_EXEMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: ml.Element): any {\n    const attrs = {};\n    element.attrs.forEach((attr: ml.Attribute) => {\n      attrs[attr.name] = attr.value;\n    });\n    const tag = new xml.Tag(element.name, attrs, element.children as any);\n    return this.visitTag(tag);\n  }\n\n  visitText(text: xml.Text): void {}\n\n  visitDeclaration(decl: xml.Declaration): void {}\n\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, \"_\");\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\nimport {xmbMapper} from \"./xmb\";\n\nconst _TRANSLATIONS_TAG = \"translationbundle\";\nconst _TRANSLATION_TAG = \"translation\";\nconst _PLACEHOLDER_TAG = \"ph\";\n\nexport function xtbLoadToI18n(content: string): I18nMessagesById {\n  // xtb to xml nodes\n  const xtbParser = new XtbParser();\n  const {msgIdToHtml, errors: parseErrors} = xtbParser.parse(content);\n\n  if (parseErrors.length) {\n    throw new Error(`xtb parse errors:\\n${parseErrors.join(\"\\n\")}`);\n  }\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  // Because we should be able to load xtb files that rely on features not supported by angular,\n  // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n  // converted\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const valueFn = () => {\n      const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId]);\n      if (errors.length) {\n        throw new Error(`xtb parse errors:\\n${errors.join(\"\\n\")}`);\n      }\n      return i18nNodes;\n    };\n    createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n  });\n\n  return i18nNodesByMsgId;\n}\n\nexport const xtbDigest = digest;\n\nexport const xtbMapper = xmbMapper;\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: _ => {\n      throw new Error(\"Could not overwrite an XTB translation\");\n    }\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  private _bundleDepth: number;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(xtb: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new Parser(getXmlTagDefinition).parse(xtb, \"\", false);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan!.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan!.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, \"Unexpected tag\");\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"name\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParserError {\n  public message: string;\n  constructor(message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n  constructor(public span: ParseSpan) {}\n  visit(visitor: AstVisitor, context: any = null): any {\n    return null;\n  }\n  toString(): string {\n    return \"AST\";\n  }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(span: ParseSpan, public prefix: string, public uninterpretedExpression: string, public location: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitQuote(this, context);\n  }\n  toString(): string {\n    return \"Quote\";\n  }\n}\n\nexport class EmptyExpr extends AST {\n  visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends AST {\n  constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, public value: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport interface LiteralMapKey {\n  key: string;\n  quoted: boolean;\n}\n\nexport class LiteralMap extends AST {\n  constructor(span: ParseSpan, public keys: LiteralMapKey[], public values: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(span: ParseSpan, public strings: any[], public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class MethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitMethodCall(this, context);\n  }\n}\n\nexport class SafeMethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeMethodCall(this, context);\n  }\n}\n\nexport class FunctionCall extends AST {\n  constructor(span: ParseSpan, public target: AST | null, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitFunctionCall(this, context);\n  }\n}\n\nexport class ASTWithSource extends AST {\n  constructor(public ast: AST, public source: string | null, public location: string, public errors: ParserError[]) {\n    super(new ParseSpan(0, source == null ? 0 : source.length));\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return this.ast.visit(visitor, context);\n  }\n  toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\nexport class TemplateBinding {\n  constructor(\n    public span: ParseSpan,\n    public key: string,\n    public keyIsVar: boolean,\n    public name: string,\n    public expression: ASTWithSource\n  ) {}\n}\n\nexport interface AstVisitor {\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  visitFunctionCall(ast: FunctionCall, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitMethodCall(ast: MethodCall, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visitBinary(ast: Binary, context: any): any {\n    ast.left.visit(this);\n    ast.right.visit(this);\n    return null;\n  }\n  visitChain(ast: Chain, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    ast.condition.visit(this);\n    ast.trueExp.visit(this);\n    ast.falseExp.visit(this);\n    return null;\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitFunctionCall(ast: FunctionCall, context: any): any {\n    ast.target!.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n    return null;\n  }\n  visitInterpolation(ast: Interpolation, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    return null;\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    return this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n    return null;\n  }\n  visitMethodCall(ast: MethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    ast.receiver.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitAll(asts: AST[], context: any): any {\n    asts.forEach(ast => ast.visit(this, context));\n    return null;\n  }\n  visitQuote(ast: Quote, context: any): any {\n    return null;\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    return new FunctionCall(ast.span, ast.target!.visit(this), this.visitAll(ast.args));\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = new Array(asts.length);\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(public index: number, public type: TokenType, public numValue: number, public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n\n  isNumber(): boolean {\n    return this.type === TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type === TokenType.String;\n  }\n\n  isOperator(operater: string): boolean {\n    return this.type === TokenType.Operator && this.strValue === operater;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === TokenType.Identifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type === TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"let\";\n  }\n\n  isKeywordAs(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"as\";\n  }\n\n  isKeywordNull(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"null\";\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"undefined\";\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"true\";\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"false\";\n  }\n\n  isKeywordThis(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"this\";\n  }\n\n  isError(): boolean {\n    return this.type === TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string | null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, \"\");\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, \"\");\n\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token | null {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (chars.isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, \"?\", chars.$PERIOD, \".\");\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\");\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\", chars.$EQ, \"=\");\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, \"&\", chars.$AMPERSAND, \"&\");\n      case chars.$BAR:\n        return this.scanComplexOperator(start, \"|\", chars.$BAR, \"|\");\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) {\n          this.advance();\n        }\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n    start: number,\n    one: string,\n    twoCode: number,\n    two: string,\n    threeCode?: number,\n    three?: string\n  ): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek === twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek === threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) {\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = this.index === start;\n    this.advance(); // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) {\n          this.advance();\n        }\n        if (!chars.isDigit(this.peek)) {\n          return this.error(\"Invalid exponent\", -1);\n        }\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance(); // Skip initial quote.\n\n    let buffer = \"\";\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek !== quote) {\n      if (this.peek === chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek === chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek === chars.$EOF) {\n        return this.error(\"Unterminated quote\", 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance(); // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (\n    (chars.$a <= code && code <= chars.$z) ||\n    (chars.$A <= code && code <= chars.$Z) ||\n    code === chars.$_ ||\n    code === chars.$$\n  );\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length === 0) {\n    return false;\n  }\n  const scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) {\n    return false;\n  }\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) {\n      return false;\n    }\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_ || code === chars.$$;\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code === chars.$e || code === chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code === chars.$MINUS || code === chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text, 10);\n  if (isNaN(result)) {\n    throw new Error(\"Invalid integer literal when parsing \" + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {escapeRegExp} from \"../ast/parse_util\";\n\nimport {\n  AST,\n  ASTWithSource,\n  AstVisitor,\n  Binary,\n  BindingPipe,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  FunctionCall,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  KeyedWrite,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  MethodCall,\n  NonNullAssert,\n  ParseSpan,\n  ParserError,\n  PrefixNot,\n  PropertyRead,\n  PropertyWrite,\n  Quote,\n  SafeMethodCall,\n  SafePropertyRead,\n  TemplateBinding\n} from \"./ast\";\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from \"./lexer\";\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(public templateBindings: TemplateBinding[], public warnings: string[], public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + \"([\\\\s\\\\S]*?)\" + escapeRegExp(config.end);\n  return new RegExp(pattern, \"g\");\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      true,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(`Host binding expression cannot contain ${errors.join(\" \")}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      false,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n  }\n\n  private _parseQuote(input: string | null, location: any): AST | null {\n    if (input === null) {\n      return null;\n    }\n    const prefixSeparatorIndex = input.indexOf(\":\");\n    if (prefixSeparatorIndex === -1) {\n      return null;\n    }\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) {\n      return null;\n    }\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(prefixToken: string | null, input: string, location: any): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new ParseAST(input, location, tokens, input.length, false, this.errors, 0).parseTemplateBindings();\n  }\n\n  parseInterpolation(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource | null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split === null) {\n      return null;\n    }\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new ParseAST(\n        input,\n        location,\n        tokens,\n        sourceToLex.length,\n        false,\n        this.errors,\n        split.offsets[i] + (expressionText.length - sourceToLex.length)\n      ).parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n      new Interpolation(new ParseSpan(0, input === null ? 0 : input.length), split.strings, expressions),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  splitInterpolation(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): SplitInterpolation | null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n          \"Blank expressions are not allowed in interpolated strings\",\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n          location\n        );\n        expressions.push(\"$implict\");\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource {\n    return new ASTWithSource(\n      new LiteralPrimitive(new ParseSpan(0, input === null ? 0 : input.length), input),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar === chars.$SLASH && outerQuote === null) {\n        return i;\n      }\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote === null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n        `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n        input,\n        `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n        location\n      );\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n    parts: string[],\n    partInErrIdx: number,\n    interpolationConfig: InterpolationConfig\n  ): number {\n    let errLocation = \"\";\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ? parts[j] : `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index = 0;\n\n  constructor(\n    public input: string,\n    public location: any,\n    public tokens: Token[],\n    public inputLength: number,\n    public parseAction: boolean,\n    private errors: ParserError[],\n    private offset: number\n  ) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  get inputIndex(): number {\n    return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n  }\n\n  span(start: number) {\n    return new ParseSpan(start, this.inputIndex);\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) {\n      return;\n    }\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) {\n      return;\n    }\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error(\"Binding expression cannot contain chained expression\");\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length === 0) {\n      return new EmptyExpr(this.span(start));\n    }\n    if (exprs.length === 1) {\n      return exprs[0];\n    }\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator(\"|\")) {\n      if (this.parseAction) {\n        this.error(\"Cannot have a pipe in an action expression\");\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator(\"|\"));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator(\"?\")) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator(\"||\")) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), \"||\", result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator(\"&&\")) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), \"&&\", result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"==\":\n        case \"===\":\n        case \"!=\":\n        case \"!==\":\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"<\":\n        case \">\":\n        case \"<=\":\n        case \">=\":\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"+\":\n        case \"-\":\n          this.advance();\n          const right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"*\":\n        case \"%\":\n        case \"/\":\n          this.advance();\n          const right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type === TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case \"+\":\n          this.advance();\n          return this.parsePrefix();\n        case \"-\":\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n        case \"!\":\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n      } else if (this.optionalOperator(\"?.\")) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator(\"=\")) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n      } else if (this.optionalOperator(\"!\")) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) : new MethodCall(span, receiver, id, args);\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator(\"=\")) {\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) {\n            this.error(\"Bindings cannot contain assignments\");\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) {\n      return [];\n    }\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` inbetween.\n   */\n  expectTemplateBindingKey(): string {\n    let result = \"\";\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator(\"-\");\n      if (operatorFound) {\n        result += \"-\";\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  parseTemplateBindings(): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n    let prefix: string = null!;\n    const warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const start = this.inputIndex;\n      let keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      const rawKey = this.expectTemplateBindingKey();\n      let key = rawKey;\n      if (!keyIsVar) {\n        if (prefix === null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let name: string = null!;\n      let expression: ASTWithSource = null!;\n      if (keyIsVar) {\n        if (this.optionalOperator(\"=\")) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = \"$implicit\";\n        }\n      } else if (this.peekKeywordAs()) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey(); // read local var name\n        keyIsVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const st = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(st - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (this.peekKeywordAs() && !keyIsVar) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        const letName = this.expectTemplateBindingKey(); // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null!));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number | null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number | null = null) {\n    if (index === null) {\n      index = this.index;\n    }\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) {\n    this.visitAll(ast.expressions);\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any) {\n    this.visitAll(ast.values);\n  }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) {\n    this.errors.push(\"pipes\");\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] {\n    return asts.map(node => node.visit(this));\n  }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * @internal\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string { return this._hashTag(`/${tag}`, {}, false); }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {InterpolationConfig} from \"../ast/interpolation_config\";\nimport {Parser} from \"./parser\";\nimport {Lexer} from \"./lexer\";\nimport {PlaceholderRegistry} from \"../serializers/placeholder\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {ParseSourceSpan} from \"../ast/parse_util\";\n\nconst _expParser = new Parser(new Lexer());\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(\n  interpolationConfig: InterpolationConfig\n): (nodes: html.Node[], meaning: string, description: string, id: string) => i18n.Message {\n  const visitor = new I18nVisitor(_expParser, interpolationConfig);\n\n  return (nodes: html.Node[], meaning: string, description: string, id: string) =>\n    visitor.toI18nMessage(nodes, meaning, description, id);\n}\n\nclass I18nVisitor implements html.Visitor {\n  private _isIcu: boolean;\n  private _icuDepth: number;\n  private _placeholderRegistry: PlaceholderRegistry;\n  private _placeholderToContent: {[phName: string]: string};\n  private _placeholderToMessage: {[phName: string]: i18n.Message};\n\n  constructor(private _expressionParser: Parser, private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(nodes: html.Node[], meaning: string, description: string, id: string): i18n.Message {\n    this._isIcu = nodes.length === 1 && nodes[0] instanceof html.Expansion;\n    this._icuDepth = 0;\n    this._placeholderRegistry = new PlaceholderRegistry();\n    this._placeholderToContent = {};\n    this._placeholderToMessage = {};\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, {});\n\n    return new i18n.Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n  }\n\n  visitElement(el: html.Element, context: any): i18n.Node {\n    const children = html.visitAll(this, el.children);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    this._placeholderToContent[startPhName] = el.sourceSpan ? el.sourceSpan!.toString() : \"\";\n\n    let closePhName = \"\";\n\n    if (!isVoid) {\n      closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      this._placeholderToContent[closePhName] = `</${el.name}>`;\n    }\n\n    return new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan!);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan!);\n  }\n\n  visitComment(comment: html.Comment, context: any): i18n.Node | null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): i18n.Node {\n    this._icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n        caze.expression.map(node => node.visit(this, {})),\n        caze.expSourceSpan\n      );\n    });\n    this._icuDepth--;\n\n    if (this._isIcu || this._icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      this._placeholderToContent[expPh] = icu.switchValue;\n\n      return i18nIcu;\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations. We need to create a new visitor (they are not re-entrant) to compute the\n    // message id.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = this._placeholderRegistry.getPlaceholderName(\"ICU\", icu.sourceSpan.toString());\n    const visitor = new I18nVisitor(this._expressionParser, this._interpolationConfig);\n    this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], \"\", \"\", \"\");\n    return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): i18n.Node {\n    throw new Error(\"Unreachable code\");\n  }\n\n  private _visitTextWithInterpolation(text: string, sourceSpan: ParseSourceSpan): i18n.Node {\n    const splitInterpolation = this._expressionParser.splitInterpolation(\n      text,\n      sourceSpan.start.toString(),\n      this._interpolationConfig\n    );\n\n    if (!splitInterpolation) {\n      // No expression, return a single text\n      return new i18n.Text(text, sourceSpan);\n    }\n\n    // Return a group of text + expressions\n    const nodes: i18n.Node[] = [];\n    const container = new i18n.Container(nodes, sourceSpan);\n    const {start: sDelimiter, end: eDelimiter} = this._interpolationConfig;\n\n    for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {\n      const expression = splitInterpolation.expressions[i];\n      const baseName = extractPlaceholderName(expression) || \"INTERPOLATION\";\n      const phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n\n      if (splitInterpolation.strings[i].length) {\n        // No need to add empty strings\n        nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));\n      }\n\n      nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));\n      this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n    }\n\n    // The last index contains no expression\n    const lastStringIdx = splitInterpolation.strings.length - 1;\n    if (splitInterpolation.strings[lastStringIdx].length) {\n      nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));\n    }\n    return container;\n  }\n}\n\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {createI18nMessageFactory} from \"./i18n\";\nimport {Parser, ParseTreeResult} from \"../ast/parser\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nMessagesById, PlaceholderMapper} from \"../serializers/serializer\";\nimport {MissingTranslationStrategy} from \"@angular/core\";\n\nconst _I18N_ATTR = \"i18n\";\n\nexport interface MessageMetadata {\n  meaning?: string;\n  description?: string;\n  id?: string;\n}\n\nexport class HtmlParser extends Parser {\n  constructor(private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    super(getHtmlTagDefinition);\n  }\n\n  parse(source: string, url: string, parseExpansionForms = false): ParseTreeResult {\n    return super.parse(source, url, parseExpansionForms, this.interpolationConfig);\n  }\n\n  /**\n   * Extract translatable messages from an html AST\n   */\n  extractMessages(nodes: html.Node[]): ExtractionResult {\n    const visitor = new Visitor([\"wrapper\"]);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.extract(wrapper, this.interpolationConfig);\n  }\n\n  mergeTranslations(\n    nodes: html.Node[],\n    translations: TranslationBundle,\n    params: {[key: string]: any},\n    metadata?: MessageMetadata,\n    implicitTags: string[] = []\n  ): ParseTreeResult {\n    const visitor = new Visitor(implicitTags);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.merge(wrapper, translations, this.interpolationConfig, params, metadata);\n  }\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n    private i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    public digest: (m: i18n.Message) => string,\n    interpolationConfig: InterpolationConfig,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n    console?: Console\n  ) {\n    this.i18nToHtml = new I18nToHtmlVisitor(\n      i18nNodesByMsgId,\n      digest,\n      mapperFactory!,\n      missingTranslationStrategy,\n      interpolationConfig,\n      console\n    );\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n    content: string,\n    url: string,\n    digest: (message: i18n.Message) => string,\n    createNameMapper: (message: i18n.Message) => PlaceholderMapper | null,\n    loadFct: (content: string, url: string) => I18nMessagesById,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): TranslationBundle {\n    const i18nNodesByMsgId = loadFct(content, url);\n    const digestFn = (m: i18n.Message) => digest(m);\n    const mapperFactory = (m: i18n.Message) => createNameMapper(m)!;\n    return new TranslationBundle(\n      i18nNodesByMsgId,\n      digestFn,\n      interpolationConfig,\n      missingTranslationStrategy,\n      mapperFactory,\n      console\n    );\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message, params): html.Node[] {\n    const htmlRes = this.i18nToHtml.convert(srcMsg, params);\n    if (htmlRes.errors.length) {\n      throw new Error(htmlRes.errors.join(\"\\n\"));\n    }\n\n    return htmlRes.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this.i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  private _srcMsg: i18n.Message;\n  private _contextStack: {msg: i18n.Message; mapper: (name: string) => string}[] = [];\n  private _errors: I18nError[] = [];\n  private _mapper: (name: string) => string;\n  private _params: {[key: string]: any};\n  private _paramKeys: string[];\n\n  constructor(\n    private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    private _digest: (m: i18n.Message) => string,\n    private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n    private _missingTranslationStrategy: MissingTranslationStrategy,\n    private _interpolationConfig?: InterpolationConfig,\n    private _console?: Console\n  ) {}\n\n  convert(srcMsg: i18n.Message, params: {[key: string]: any}): {nodes: html.Node[]; errors: I18nError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    this._params = params;\n    this._paramKeys = Object.keys(params);\n\n    // i18n to text\n    const text = this.convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const htmlParser = new HtmlParser().parse(text, url, true);\n\n    return {\n      nodes: htmlParser.rootNodes,\n      errors: [...this._errors, ...htmlParser.errors]\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map(n => n.visit(this)).join(\"\");\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression)\n      ? this._srcMsg.placeholders[icu.expression]\n      : icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(\" \")}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this.convertToValue(this._srcMsg.placeholders[phName]);\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this.convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return \"\";\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs)\n      .map(name => `${name}=\"${ph.attrs[name]}\"`)\n      .join(\" \");\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join(\"\");\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this.convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => (mapper ? mapper.toInternalName(name)! : name);\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        this._console.warn(`Missing translation for message \"${id}\"`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join(\"\");\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private convertToValue(placeholder: string): string {\n    const param = placeholder.replace(this._interpolationConfig.start, \"\").replace(this._interpolationConfig.end, \"\");\n    return this._paramKeys.indexOf(param) !== -1 ? this._params[param] : placeholder;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new I18nError(el.sourceSpan, msg));\n  }\n}\n\nenum VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass Visitor implements html.Visitor {\n  private depth: number;\n\n  // <el i18n>...</el>\n  private inI18nNode: boolean;\n  private inImplicitNode: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  private inI18nBlock: boolean;\n  private blockChildren: html.Node[] = [];\n  private blockStartDepth: number;\n\n  // {<icu message>}\n  private inIcu: boolean;\n\n  // set to void 0 when not in a section\n  private msgCountAtSectionStart: number | undefined;\n  private errors: I18nError[];\n  private mode: VisitorMode;\n\n  // VisitorMode.Extract only\n  private messages: i18n.Message[];\n\n  // VisitorMode.Merge only\n  private translations: TranslationBundle;\n  private createI18nMessage: (msg: html.Node[], meaning: string, description: string, id: string) => i18n.Message;\n  private metadata: MessageMetadata;\n  private params: {[key: string]: any};\n\n  constructor(private _implicitTags: string[] = []) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(node: html.Node, interpolationConfig: InterpolationConfig): ExtractionResult {\n    this.init(VisitorMode.Extract, interpolationConfig);\n\n    node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ExtractionResult(this.messages, this.errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n    node: html.Node,\n    translations: TranslationBundle,\n    interpolationConfig: InterpolationConfig,\n    params: {[key: string]: any},\n    metadata: MessageMetadata = {}\n  ): ParseTreeResult {\n    this.init(VisitorMode.Merge, interpolationConfig, params);\n    this.translations = translations;\n    this.metadata = metadata;\n\n    const translatedNode = node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ParseTreeResult(translatedNode.children, this.errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.ExpansionCase(\n        icuCase.value,\n        expression,\n        icuCase.sourceSpan,\n        icuCase.valueSourceSpan,\n        icuCase.expSourceSpan\n      );\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this.mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this.inIcu;\n\n    if (!this.inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this.isInTranslatableSection) {\n        this.addMessage([icu]);\n      }\n      this.inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this.inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return;\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this.isInTranslatableSection) {\n      this.mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element | null {\n    this.mayBeAddBlockChildren(el);\n    this.depth++;\n    const wasInI18nNode = this.inI18nNode;\n    const wasInImplicitNode = this.inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = getI18nAttr(el);\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this.inIcu && !this.isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this.inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this.isInTranslatableSection && !this.inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this.inI18nNode = true;\n        const message = this.addMessage(el.children, this.metadata)!;\n        translatedChildNodes = this.translateMessage(el, message);\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) {\n          this.openTranslatableSection(el);\n        }\n        html.visitAll(this, el.children);\n        if (isTranslatable) {\n          this._closeTranslatableSection(el, el.children);\n        }\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(el, \"Could not mark an element as translatable inside a translatable section\");\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this.mode === VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this.isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this.depth--;\n    this.inI18nNode = wasInI18nNode;\n    this.inImplicitNode = wasInImplicitNode;\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.Element(el.name, [], childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error(\"unreachable code\");\n  }\n\n  private init(mode: VisitorMode, interpolationConfig: InterpolationConfig, params: {[key: string]: any} = {}): void {\n    this.mode = mode;\n    this.inI18nBlock = false;\n    this.inI18nNode = false;\n    this.depth = 0;\n    this.inIcu = false;\n    this.msgCountAtSectionStart = undefined;\n    this.errors = [];\n    this.messages = [];\n    this.inImplicitNode = false;\n    this.createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    this.params = params;\n  }\n\n  // add a translatable message\n  private addMessage(ast: html.Node[], {meaning = \"\", description = \"\", id = \"\"} = {}): i18n.Message | null {\n    if (\n      ast.length === 0 ||\n      (ast.length === 1 && ast[0] instanceof html.Attribute && !(ast[0] as html.Attribute).value)\n    ) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const message = this.createI18nMessage(ast, meaning, description, id);\n    this.messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this.mode === VisitorMode.Merge) {\n      const nodes = this.translations.get(message, this.params);\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(el, `Translation unavailable for message id=\"${this.translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private mayBeAddBlockChildren(node: html.Node): void {\n    if (this.inI18nBlock && !this.inIcu && this.depth === this.blockStartDepth) {\n      this.blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private openTranslatableSection(node: html.Node): void {\n    if (this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section start\");\n    } else {\n      this.msgCountAtSectionStart = this.messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get isInTranslatableSection(): boolean {\n    return this.msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section end\");\n      return;\n    }\n\n    const startIndex = this.msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n      (count: number, n: html.Node): number => count + (n instanceof html.Comment ? 0 : 1),\n      0\n    );\n\n    if (significantChildren === 1) {\n      for (let i = this.messages.length - 1; i >= startIndex!; i--) {\n        const ast = this.messages[i].nodes;\n        if (!(ast.length === 1 && ast[0] instanceof i18n.Text)) {\n          this.messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this.msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this.errors.push(new I18nError(node.sourceSpan!, msg));\n  }\n}\n\nfunction getI18nAttr(p: html.Element): html.Attribute | null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n","import {\n  Inject,\n  Injectable,\n  InjectionToken,\n  LOCALE_ID,\n  MissingTranslationStrategy,\n  Optional,\n  TRANSLATIONS,\n  TRANSLATIONS_FORMAT\n} from \"@angular/core\";\nimport {xliffDigest, xliffLoadToI18n} from \"./serializers/xliff\";\nimport {xliff2Digest, xliff2LoadToI18n} from \"./serializers/xliff2\";\nimport {xtbDigest, xtbLoadToI18n, xtbMapper} from \"./serializers/xtb\";\nimport {HtmlParser, TranslationBundle} from \"./parser/html\";\nimport {I18nMessagesById, serializeNodes} from \"./serializers/serializer\";\nimport {Message} from \"./ast/i18n_ast\";\n\nexport declare interface I18n {\n  (def: string | I18nDef, params?: {[key: string]: any}): string;\n}\n\nexport interface I18nDef {\n  value: string;\n  id?: string;\n  meaning?: string;\n  description?: string;\n}\n\nexport const MISSING_TRANSLATION_STRATEGY = new InjectionToken<MissingTranslationStrategy>(\n  \"MissingTranslationStrategy\"\n);\n\n/**\n * A speculative polyfill to use i18n code translations\n */\n@Injectable()\nexport class I18n {\n  constructor(\n    @Inject(TRANSLATIONS_FORMAT) format: string,\n    @Inject(TRANSLATIONS) translations: string,\n    @Inject(LOCALE_ID) locale: string,\n    @Optional()\n    @Inject(MISSING_TRANSLATION_STRATEGY)\n    missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning\n  ) {\n    let loadFct: (content: string, url: string) => I18nMessagesById;\n    let digest: (message: Message) => string;\n    let createMapper = (message: Message) => null;\n    format = (format || \"xlf\").toLowerCase();\n    switch (format) {\n      case \"xtb\":\n        loadFct = xtbLoadToI18n;\n        digest = xtbDigest;\n        createMapper = xtbMapper;\n        break;\n      case \"xliff2\":\n      case \"xlf2\":\n        loadFct = xliff2LoadToI18n;\n        digest = xliff2Digest;\n        break;\n      case \"xliff\":\n      case \"xlf\":\n        loadFct = xliffLoadToI18n;\n        digest = xliffDigest;\n        break;\n      default:\n        throw new Error(`Unknown translations format ${format}`);\n    }\n    const htmlParser = new HtmlParser();\n\n    const translationsBundle = TranslationBundle.load(\n      translations,\n      \"i18n\",\n      digest,\n      createMapper,\n      loadFct,\n      missingTranslationStrategy\n    );\n\n    // todo use interpolation config\n    return (def: string | I18nDef, params: {[key: string]: any} = {}) => {\n      const content = typeof def === \"string\" ? def : def.value;\n      const metadata = {};\n      if (typeof def === \"object\") {\n        metadata[\"id\"] = def.id;\n        metadata[\"meaning\"] = def.meaning;\n        metadata[\"description\"] = def.description;\n      }\n      const htmlParserResult = htmlParser.parse(content, \"\", true);\n\n      if (htmlParserResult.errors.length) {\n        throw htmlParserResult.errors;\n      }\n\n      const mergedNodes = htmlParser.mergeTranslations(\n        htmlParserResult.rootNodes,\n        translationsBundle,\n        params,\n        metadata,\n        [\"wrapper\"]\n      );\n\n      return serializeNodes(mergedNodes.rootNodes, locale, params).join(\"\");\n    };\n  }\n}\n"],"names":["Text","tslib_1.__extends","chars.$EOF","chars.$LT","chars.$BANG","chars.$LBRACKET","chars.$MINUS","chars.$SLASH","chars.$RBRACE","chars.$LF","chars.$CR","chars.$AMPERSAND","chars.$HASH","chars.$x","chars.$X","chars.$SEMICOLON","chars.$RBRACKET","chars.$GT","chars.$COLON","chars.isAsciiLetter","chars.$EQ","chars.$SQ","chars.$DQ","chars.$LBRACE","chars.$COMMA","chars.isWhitespace","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$0","chars.$9","chars.isAsciiHexDigit","chars.isDigit","lex.tokenize","lex.TokenType","html.Comment","html.Expansion","lex.Token","html.ExpansionCase","html.Text","html.Element","html.Attribute","i18n.RecurseVisitor","I18nSelectPipe","I18nPluralPipe","NgLocaleLocalization","serializeNodes","SerializerVisitor","ml.visitAll","i18n.Text","i18n.Placeholder","i18n.Container","i18n.Icu","_PLACEHOLDER_TAG","_SOURCE_TAG","_TARGET_TAG","_UNIT_TAG","XmlToI18n","Token","TokenType","chars.$SPACE","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$PLUS","chars.$STAR","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$BAR","chars.$NBSP","chars.$BACKSLASH","chars.$u","chars.$_","chars.$$","chars.$e","chars.$E","chars.$BT","chars.$n","chars.$f","chars.$FF","chars.$r","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","Parser","html.visitAll","i18n.Message","i18n.TagPlaceholder","i18n.IcuPlaceholder","Visitor","MissingTranslationStrategy","InjectionToken","Injectable","Inject","TRANSLATIONS_FORMAT","TRANSLATIONS","LOCALE_ID","Optional"],"mappings":"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"}
