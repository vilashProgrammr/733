{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../lib/src/parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {escapeRegExp} from \"../ast/parse_util\";\n\nimport {\n  AST,\n  ASTWithSource,\n  AstVisitor,\n  Binary,\n  BindingPipe,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  FunctionCall,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  KeyedWrite,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  MethodCall,\n  NonNullAssert,\n  ParseSpan,\n  ParserError,\n  PrefixNot,\n  PropertyRead,\n  PropertyWrite,\n  Quote,\n  SafeMethodCall,\n  SafePropertyRead,\n  TemplateBinding\n} from \"./ast\";\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from \"./lexer\";\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(public templateBindings: TemplateBinding[], public warnings: string[], public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + \"([\\\\s\\\\S]*?)\" + escapeRegExp(config.end);\n  return new RegExp(pattern, \"g\");\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      true,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(`Host binding expression cannot contain ${errors.join(\" \")}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      false,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n  }\n\n  private _parseQuote(input: string | null, location: any): AST | null {\n    if (input === null) {\n      return null;\n    }\n    const prefixSeparatorIndex = input.indexOf(\":\");\n    if (prefixSeparatorIndex === -1) {\n      return null;\n    }\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) {\n      return null;\n    }\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(prefixToken: string | null, input: string, location: any): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new ParseAST(input, location, tokens, input.length, false, this.errors, 0).parseTemplateBindings();\n  }\n\n  parseInterpolation(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource | null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split === null) {\n      return null;\n    }\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new ParseAST(\n        input,\n        location,\n        tokens,\n        sourceToLex.length,\n        false,\n        this.errors,\n        split.offsets[i] + (expressionText.length - sourceToLex.length)\n      ).parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n      new Interpolation(new ParseSpan(0, input === null ? 0 : input.length), split.strings, expressions),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  splitInterpolation(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): SplitInterpolation | null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n          \"Blank expressions are not allowed in interpolated strings\",\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n          location\n        );\n        expressions.push(\"$implict\");\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource {\n    return new ASTWithSource(\n      new LiteralPrimitive(new ParseSpan(0, input === null ? 0 : input.length), input),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar === chars.$SLASH && outerQuote === null) {\n        return i;\n      }\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote === null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n        `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n        input,\n        `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n        location\n      );\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n    parts: string[],\n    partInErrIdx: number,\n    interpolationConfig: InterpolationConfig\n  ): number {\n    let errLocation = \"\";\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ? parts[j] : `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index = 0;\n\n  constructor(\n    public input: string,\n    public location: any,\n    public tokens: Token[],\n    public inputLength: number,\n    public parseAction: boolean,\n    private errors: ParserError[],\n    private offset: number\n  ) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  get inputIndex(): number {\n    return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n  }\n\n  span(start: number) {\n    return new ParseSpan(start, this.inputIndex);\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) {\n      return;\n    }\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) {\n      return;\n    }\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error(\"Binding expression cannot contain chained expression\");\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length === 0) {\n      return new EmptyExpr(this.span(start));\n    }\n    if (exprs.length === 1) {\n      return exprs[0];\n    }\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator(\"|\")) {\n      if (this.parseAction) {\n        this.error(\"Cannot have a pipe in an action expression\");\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator(\"|\"));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator(\"?\")) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator(\"||\")) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), \"||\", result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator(\"&&\")) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), \"&&\", result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"==\":\n        case \"===\":\n        case \"!=\":\n        case \"!==\":\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"<\":\n        case \">\":\n        case \"<=\":\n        case \">=\":\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"+\":\n        case \"-\":\n          this.advance();\n          const right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"*\":\n        case \"%\":\n        case \"/\":\n          this.advance();\n          const right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type === TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case \"+\":\n          this.advance();\n          return this.parsePrefix();\n        case \"-\":\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n        case \"!\":\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n      } else if (this.optionalOperator(\"?.\")) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator(\"=\")) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n      } else if (this.optionalOperator(\"!\")) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) : new MethodCall(span, receiver, id, args);\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator(\"=\")) {\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) {\n            this.error(\"Bindings cannot contain assignments\");\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) {\n      return [];\n    }\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` inbetween.\n   */\n  expectTemplateBindingKey(): string {\n    let result = \"\";\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator(\"-\");\n      if (operatorFound) {\n        result += \"-\";\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  parseTemplateBindings(): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n    let prefix: string = null!;\n    const warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const start = this.inputIndex;\n      let keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      const rawKey = this.expectTemplateBindingKey();\n      let key = rawKey;\n      if (!keyIsVar) {\n        if (prefix === null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let name: string = null!;\n      let expression: ASTWithSource = null!;\n      if (keyIsVar) {\n        if (this.optionalOperator(\"=\")) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = \"$implicit\";\n        }\n      } else if (this.peekKeywordAs()) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey(); // read local var name\n        keyIsVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const st = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(st - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (this.peekKeywordAs() && !keyIsVar) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        const letName = this.expectTemplateBindingKey(); // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null!));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number | null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number | null = null) {\n    if (index === null) {\n      index = this.index;\n    }\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) {\n    this.visitAll(ast.expressions);\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any) {\n    this.visitAll(ast.values);\n  }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) {\n    this.errors.push(\"pipes\");\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] {\n    return asts.map(node => node.visit(this));\n  }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n"]}