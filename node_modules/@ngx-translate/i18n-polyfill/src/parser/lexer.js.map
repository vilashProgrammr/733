{"version":3,"file":"lexer.js","sourceRoot":"","sources":["../../../lib/src/parser/lexer.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,oBAAoB;AAEpB,sCAAsC;AAEtC,IAAY,SAQX;AARD,WAAY,SAAS;IACnB,mDAAS,CAAA;IACT,qDAAU,CAAA;IACV,+CAAO,CAAA;IACP,6CAAM,CAAA;IACN,iDAAQ,CAAA;IACR,6CAAM,CAAA;IACN,2CAAK,CAAA;AACP,CAAC,EARW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAQpB;AAED,MAAM,QAAQ,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AAElG;IACE,QAAQ,CAAC,IAAY;QACnB,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;QAClC,MAAM,MAAM,GAAY,EAAE,CAAC;QAC3B,IAAI,KAAK,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;QAChC,OAAO,KAAK,IAAI,IAAI,EAAE,CAAC;YACrB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACnB,KAAK,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;QAC9B,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;CACF;AAXD,sBAWC;AAED;IACE,YAAmB,KAAa,EAAS,IAAe,EAAS,QAAgB,EAAS,QAAgB;QAAvF,UAAK,GAAL,KAAK,CAAQ;QAAS,SAAI,GAAJ,IAAI,CAAW;QAAS,aAAQ,GAAR,QAAQ,CAAQ;QAAS,aAAQ,GAAR,QAAQ,CAAQ;IAAG,CAAC;IAE9G,WAAW,CAAC,IAAY;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;IACrE,CAAC;IAED,QAAQ;QACN,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,MAAM,CAAC;IACxC,CAAC;IAED,QAAQ;QACN,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,MAAM,CAAC;IACxC,CAAC;IAED,UAAU,CAAC,QAAgB;QACzB,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC;IACxE,CAAC;IAED,YAAY;QACV,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,UAAU,CAAC;IAC5C,CAAC;IAED,SAAS;QACP,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,CAAC;IACzC,CAAC;IAED,YAAY;QACV,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC;IACpE,CAAC;IAED,WAAW;QACT,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;IACnE,CAAC;IAED,aAAa;QACX,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,CAAC;IACrE,CAAC;IAED,kBAAkB;QAChB,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,CAAC;IAC1E,CAAC;IAED,aAAa;QACX,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,CAAC;IACrE,CAAC;IAED,cAAc;QACZ,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,OAAO,CAAC;IACtE,CAAC;IAED,aAAa;QACX,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,CAAC;IACrE,CAAC;IAED,OAAO;QACL,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,KAAK,CAAC;IACvC,CAAC;IAED,QAAQ;QACN,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D,CAAC;IAED,QAAQ;QACN,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,KAAK,SAAS,CAAC,SAAS,CAAC;YACzB,KAAK,SAAS,CAAC,UAAU,CAAC;YAC1B,KAAK,SAAS,CAAC,OAAO,CAAC;YACvB,KAAK,SAAS,CAAC,QAAQ,CAAC;YACxB,KAAK,SAAS,CAAC,MAAM,CAAC;YACtB,KAAK,SAAS,CAAC,KAAK;gBAClB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACvB,KAAK,SAAS,CAAC,MAAM;gBACnB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;YAClC;gBACE,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;IACH,CAAC;CACF;AA9ED,sBA8EC;AAED,2BAA2B,KAAa,EAAE,IAAY;IACpD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,SAAS,EAAE,IAAI,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;AAChF,CAAC;AAED,4BAA4B,KAAa,EAAE,IAAY;IACrD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACzD,CAAC;AAED,yBAAyB,KAAa,EAAE,IAAY;IAClD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACtD,CAAC;AAED,0BAA0B,KAAa,EAAE,IAAY;IACnD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACvD,CAAC;AAED,wBAAwB,KAAa,EAAE,IAAY;IACjD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACrD,CAAC;AAED,wBAAwB,KAAa,EAAE,CAAS;IAC9C,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;AACnD,CAAC;AAED,uBAAuB,KAAa,EAAE,OAAe;IACnD,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;AACvD,CAAC;AAEY,QAAA,GAAG,GAAU,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;AAEpE;IAKE,YAAmB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;QAHhC,SAAI,GAAG,CAAC,CAAC;QACT,UAAK,GAAG,CAAC,CAAC,CAAC;QAGT,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,OAAO;QACL,IAAI,CAAC,IAAI,GAAG,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC3F,CAAC;IAED,SAAS;QACP,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACrB,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QAEvB,mBAAmB;QACnB,OAAO,IAAI,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;YAC5B,EAAE,CAAC,CAAC,EAAE,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC;gBACtB,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;gBAClB,KAAK,CAAC;YACR,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,EAAE,CAAC,CAAC,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAED,kCAAkC;QAClC,EAAE,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;QAC/B,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC;QAED,MAAM,KAAK,GAAW,KAAK,CAAC;QAC5B,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACb,KAAK,KAAK,CAAC,OAAO;gBAChB,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;YACrG,KAAK,KAAK,CAAC,OAAO,CAAC;YACnB,KAAK,KAAK,CAAC,OAAO,CAAC;YACnB,KAAK,KAAK,CAAC,OAAO,CAAC;YACnB,KAAK,KAAK,CAAC,OAAO,CAAC;YACnB,KAAK,KAAK,CAAC,SAAS,CAAC;YACrB,KAAK,KAAK,CAAC,SAAS,CAAC;YACrB,KAAK,KAAK,CAAC,MAAM,CAAC;YAClB,KAAK,KAAK,CAAC,MAAM,CAAC;YAClB,KAAK,KAAK,CAAC,UAAU;gBACnB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YACzC,KAAK,KAAK,CAAC,GAAG,CAAC;YACf,KAAK,KAAK,CAAC,GAAG;gBACZ,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YAC3B,KAAK,KAAK,CAAC,KAAK,CAAC;YACjB,KAAK,KAAK,CAAC,KAAK,CAAC;YACjB,KAAK,KAAK,CAAC,MAAM,CAAC;YAClB,KAAK,KAAK,CAAC,KAAK,CAAC;YACjB,KAAK,KAAK,CAAC,MAAM,CAAC;YAClB,KAAK,KAAK,CAAC,QAAQ,CAAC;YACpB,KAAK,KAAK,CAAC,MAAM;gBACf,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;YAC7D,KAAK,KAAK,CAAC,SAAS;gBAClB,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YAClE,KAAK,KAAK,CAAC,GAAG,CAAC;YACf,KAAK,KAAK,CAAC,GAAG;gBACZ,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YACpF,KAAK,KAAK,CAAC,KAAK,CAAC;YACjB,KAAK,KAAK,CAAC,GAAG;gBACZ,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YACpG,KAAK,KAAK,CAAC,UAAU;gBACnB,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;YACrE,KAAK,KAAK,CAAC,IAAI;gBACb,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YAC/D,KAAK,KAAK,CAAC,KAAK;gBACd,OAAO,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;oBACrC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjB,CAAC;gBACD,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;QAC5B,CAAC;QAED,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,yBAAyB,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC9E,CAAC;IAED,aAAa,CAAC,KAAa,EAAE,IAAY;QACvC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,MAAM,CAAC,iBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED,YAAY,CAAC,KAAa,EAAE,GAAW;QACrC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,MAAM,CAAC,gBAAgB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;;;;OASG;IACH,mBAAmB,CACjB,KAAa,EACb,GAAW,EACX,OAAe,EACf,GAAW,EACX,SAAkB,EAClB,KAAc;QAEd,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,GAAG,GAAW,GAAG,CAAC;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,GAAG,IAAI,GAAG,CAAC;QACb,CAAC;QACD,EAAE,CAAC,CAAC,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACjD,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,GAAG,IAAI,KAAK,CAAC;QACf,CAAC;QACD,MAAM,CAAC,gBAAgB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,cAAc;QACZ,MAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACnC,IAAI,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;QACD,MAAM,GAAG,GAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5D,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACnG,CAAC;IAED,UAAU,CAAC,KAAa;QACtB,IAAI,MAAM,GAAY,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC;QAC3C,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,sBAAsB;QACtC,OAAO,IAAI,EAAE,CAAC;YACZ,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC7B,cAAc;YAChB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBACvC,MAAM,GAAG,KAAK,CAAC;YACjB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACtC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC9B,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjB,CAAC;gBACD,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC5C,CAAC;gBACD,MAAM,GAAG,KAAK,CAAC;YACjB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAK,CAAC;YACR,CAAC;YACD,IAAI,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;QACD,MAAM,GAAG,GAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5D,MAAM,KAAK,GAAW,MAAM,CAAC,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QACxE,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACtC,CAAC;IAED,UAAU;QACR,MAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QACjC,MAAM,KAAK,GAAW,IAAI,CAAC,IAAI,CAAC;QAChC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,sBAAsB;QAEtC,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,MAAM,GAAW,IAAI,CAAC,KAAK,CAAC;QAChC,MAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QAEjC,OAAO,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;YAC3B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;gBACnC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC9C,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAI,aAAqB,CAAC;gBAC1B,kDAAkD;gBAClD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACtB,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3B,8CAA8C;oBAC9C,MAAM,GAAG,GAAW,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;oBACpE,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBAC7B,aAAa,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;oBACpC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,8BAA8B,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC;oBAC7D,CAAC;oBACD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;wBAC3B,IAAI,CAAC,OAAO,EAAE,CAAC;oBACjB,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,aAAa,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACpC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjB,CAAC;gBACD,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;gBAC7C,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;YACtB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACpC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;YAC7C,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAED,MAAM,IAAI,GAAW,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACzD,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,0BAA0B;QAE1C,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED,KAAK,CAAC,OAAe,EAAE,MAAc;QACnC,MAAM,QAAQ,GAAW,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QAC7C,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,gBAAgB,OAAO,cAAc,QAAQ,mBAAmB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IAChH,CAAC;CACF;AAED,2BAA2B,IAAY;IACrC,MAAM,CAAC,CACL,CAAC,KAAK,CAAC,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE,CAAC;QACtC,CAAC,KAAK,CAAC,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE,CAAC;QACtC,IAAI,KAAK,KAAK,CAAC,EAAE;QACjB,IAAI,KAAK,KAAK,CAAC,EAAE,CAClB,CAAC;AACJ,CAAC;AAED,sBAA6B,KAAa;IACxC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACvB,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IACD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC;IACnC,EAAE,CAAC,CAAC,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrC,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IACD,OAAO,CAAC,OAAO,EAAE,CAAC;IAClB,OAAO,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC;QACnC,EAAE,CAAC,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpC,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QACD,OAAO,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC;IACD,MAAM,CAAC,IAAI,CAAC;AACd,CAAC;AAhBD,oCAgBC;AAED,0BAA0B,IAAY;IACpC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;AACpG,CAAC;AAED,yBAAyB,IAAY;IACnC,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;AAChD,CAAC;AAED,wBAAwB,IAAY;IAClC,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,MAAM,IAAI,IAAI,KAAK,KAAK,CAAC,KAAK,CAAC;AACvD,CAAC;AAED,iBAAwB,IAAY;IAClC,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,GAAG,IAAI,IAAI,KAAK,KAAK,CAAC,GAAG,IAAI,IAAI,KAAK,KAAK,CAAC,GAAG,CAAC;AACxE,CAAC;AAFD,0BAEC;AAED,kBAAkB,IAAY;IAC5B,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QACb,KAAK,KAAK,CAAC,EAAE;YACX,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;QACnB,KAAK,KAAK,CAAC,EAAE;YACX,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;QACnB,KAAK,KAAK,CAAC,EAAE;YACX,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;QACnB,KAAK,KAAK,CAAC,EAAE;YACX,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC;QACpB,KAAK,KAAK,CAAC,EAAE;YACX,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;QACrB;YACE,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;AACH,CAAC;AAED,2BAA2B,IAAY;IACrC,MAAM,MAAM,GAAW,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IAC1C,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAClB,MAAM,IAAI,KAAK,CAAC,uCAAuC,GAAG,IAAI,CAAC,CAAC;IAClE,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(public index: number, public type: TokenType, public numValue: number, public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n\n  isNumber(): boolean {\n    return this.type === TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type === TokenType.String;\n  }\n\n  isOperator(operater: string): boolean {\n    return this.type === TokenType.Operator && this.strValue === operater;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === TokenType.Identifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type === TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"let\";\n  }\n\n  isKeywordAs(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"as\";\n  }\n\n  isKeywordNull(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"null\";\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"undefined\";\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"true\";\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"false\";\n  }\n\n  isKeywordThis(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"this\";\n  }\n\n  isError(): boolean {\n    return this.type === TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string | null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, \"\");\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, \"\");\n\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token | null {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (chars.isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, \"?\", chars.$PERIOD, \".\");\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\");\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\", chars.$EQ, \"=\");\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, \"&\", chars.$AMPERSAND, \"&\");\n      case chars.$BAR:\n        return this.scanComplexOperator(start, \"|\", chars.$BAR, \"|\");\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) {\n          this.advance();\n        }\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n    start: number,\n    one: string,\n    twoCode: number,\n    two: string,\n    threeCode?: number,\n    three?: string\n  ): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek === twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek === threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) {\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = this.index === start;\n    this.advance(); // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) {\n          this.advance();\n        }\n        if (!chars.isDigit(this.peek)) {\n          return this.error(\"Invalid exponent\", -1);\n        }\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance(); // Skip initial quote.\n\n    let buffer = \"\";\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek !== quote) {\n      if (this.peek === chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek === chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek === chars.$EOF) {\n        return this.error(\"Unterminated quote\", 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance(); // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (\n    (chars.$a <= code && code <= chars.$z) ||\n    (chars.$A <= code && code <= chars.$Z) ||\n    code === chars.$_ ||\n    code === chars.$$\n  );\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length === 0) {\n    return false;\n  }\n  const scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) {\n    return false;\n  }\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) {\n      return false;\n    }\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_ || code === chars.$$;\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code === chars.$e || code === chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code === chars.$MINUS || code === chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text, 10);\n  if (isNaN(result)) {\n    throw new Error(\"Invalid integer literal when parsing \" + text);\n  }\n  return result;\n}\n"]}