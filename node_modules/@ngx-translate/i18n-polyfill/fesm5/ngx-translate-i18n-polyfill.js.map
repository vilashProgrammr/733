{"version":3,"file":"ngx-translate-i18n-polyfill.js.map","sources":["ng://@ngx-translate/i18n-polyfill/src/ast/ast.ts","ng://@ngx-translate/i18n-polyfill/src/ast/i18n_ast.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xml_helper.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parse_util.ts","ng://@ngx-translate/i18n-polyfill/src/ast/interpolation_config.ts","ng://@ngx-translate/i18n-polyfill/src/ast/chars.ts","ng://@ngx-translate/i18n-polyfill/src/ast/tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/ast/parser.ts","ng://@ngx-translate/i18n-polyfill/src/ast/xml_tags.ts","ng://@ngx-translate/i18n-polyfill/src/ast/html_tags.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/serializer.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/digest.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xliff2.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xmb.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/xtb.ts","ng://@ngx-translate/i18n-polyfill/src/parser/ast.ts","ng://@ngx-translate/i18n-polyfill/src/parser/lexer.ts","ng://@ngx-translate/i18n-polyfill/src/parser/parser.ts","ng://@ngx-translate/i18n-polyfill/src/serializers/placeholder.ts","ng://@ngx-translate/i18n-polyfill/src/parser/i18n.ts","ng://@ngx-translate/i18n-polyfill/src/parser/html.ts","ng://@ngx-translate/i18n-polyfill/src/i18n-polyfill.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion implements Node {\n  constructor(\n    public switchValue: string,\n    public type: string,\n    public cases: ExpansionCase[],\n    public sourceSpan: ParseSourceSpan,\n    public switchValueSourceSpan: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements Node {\n  constructor(\n    public value: string,\n    public expression: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public valueSourceSpan: ParseSourceSpan,\n    public expSourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    public valueSpan?: ParseSourceSpan\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n    public name: string,\n    public attrs: Attribute[],\n    public children: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan | null = null,\n    public endSourceSpan: ParseSourceSpan | null = null\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements Node {\n  constructor(public value: string | null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit\n    ? (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context)\n    : (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {ParseSourceSpan} from \"./parse_util\";\n\nexport class Message {\n  sources: MessageSpan[];\n\n  /**\n   * @param source message AST\n   * @param placeholders maps placeholder names to static content\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param id\n   */\n  constructor(\n    public nodes: Node[],\n    public placeholders: {[phName: string]: string},\n    public placeholderToMessage: {[phName: string]: Message},\n    public meaning: string,\n    public description: string,\n    public id: string\n  ) {\n    if (nodes.length) {\n      this.sources = [\n        {\n          filePath: nodes[0].sourceSpan.start.file.url,\n          startLine: nodes[0].sourceSpan.start.line + 1,\n          startCol: nodes[0].sourceSpan.start.col + 1,\n          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n          endCol: nodes[0].sourceSpan.start.col + 1\n        }\n      ];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  public expressionPlaceholder: string;\n  constructor(\n    public expression: string,\n    public type: string,\n    public cases: {[k: string]: Node},\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n    public tag: string,\n    public attrs: {[k: string]: string},\n    public startName: string,\n    public closeName: string,\n    public children: Node[],\n    public isVoid: boolean,\n    public sourceSpan: ParseSourceSpan\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => (cases[key] = icu.cases[key].visit(this, context)));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport * as ml from \"../ast/ast\";\r\n\r\nexport interface IVisitor {\r\n  visitTag(tag: Tag): any;\r\n  visitElement(element: ml.Element): any;\r\n  visitText(text: Text): any;\r\n  visitDeclaration(decl: Declaration): any;\r\n  visitDoctype(doctype: Doctype): any;\r\n}\r\n\r\nclass Visitor implements IVisitor {\r\n  visitTag(tag: Tag): string {\r\n    const strAttrs = this._serializeAttributes(tag.attrs);\r\n    if (tag.children.length === 0) {\r\n      return `<${tag.name}${strAttrs}/>`;\r\n    }\r\n\r\n    const strChildren = tag.children.map(node => node.visit(this));\r\n    return `<${tag.name}${strAttrs}>${strChildren.join(\"\")}</${tag.name}>`;\r\n  }\r\n\r\n  visitText(text: Text): string {\r\n    return _escapeXml(text.value);\r\n  }\r\n\r\n  visitElement(element: ml.Element) {\r\n    const attrs = {};\r\n    element.attrs.forEach((attr: ml.Attribute) => {\r\n      attrs[attr.name] = attr.value;\r\n    });\r\n    const tag = new Tag(element.name, attrs, element.children as any);\r\n    return this.visitTag(tag);\r\n  }\r\n\r\n  visitDeclaration(decl: Declaration): string {\r\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\r\n  }\r\n\r\n  private _serializeAttributes(attrs: {[k: string]: string}) {\r\n    const strAttrs = Object.keys(attrs)\r\n      .map((name: string) => `${name}=\"${_escapeXml(attrs[name])}\"`)\r\n      .join(\" \");\r\n    return strAttrs.length > 0 ? \" \" + strAttrs : \"\";\r\n  }\r\n\r\n  visitDoctype(doctype: Doctype): any {\r\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\r\n  }\r\n}\r\n\r\nconst _visitor = new Visitor();\r\n\r\nexport function serialize(nodes: Node[]): string {\r\n  return nodes.map((node: Node): string => node.visit(_visitor)).join(\"\");\r\n}\r\n\r\nexport interface Node {\r\n  visit(visitor: IVisitor): any;\r\n}\r\n\r\nexport class Declaration implements Node {\r\n  constructor(public attrs: {[k: string]: string}) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDeclaration(this);\r\n  }\r\n}\r\n\r\nexport class Doctype implements Node {\r\n  constructor(public rootTag: string, public dtd: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitDoctype(this);\r\n  }\r\n}\r\n\r\nexport class Tag implements Node {\r\n  constructor(public name: string, public attrs: {[k: string]: string} = {}, public children: Node[] = []) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitTag(this);\r\n  }\r\n}\r\n\r\nexport class Text implements Node {\r\n  constructor(public value: string) {}\r\n\r\n  visit(visitor: IVisitor): any {\r\n    return visitor.visitText(this);\r\n  }\r\n}\r\n\r\nexport class CR extends Text {\r\n  constructor(ws = 0) {\r\n    super(`\\n${new Array(ws + 1).join(\" \")}`);\r\n  }\r\n}\r\n\r\nconst _ESCAPED_CHARS: [RegExp, string][] = [\r\n  [/&/g, \"&amp;\"],\r\n  [/\"/g, \"&quot;\"],\r\n  [/'/g, \"&apos;\"],\r\n  [/</g, \"&lt;\"],\r\n  [/>/g, \"&gt;\"]\r\n];\r\n\r\nfunction _escapeXml(text: string): string {\r\n  return _ESCAPED_CHARS.reduce((str: string, entry: [RegExp, string]) => str.replace(entry[0], entry[1]), text);\r\n}\r\n","import {I18nDef} from \"../i18n-polyfill\";\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParseLocation {\n  constructor(public file: ParseSourceFile, public offset: number, public line: number, public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.line}:${this.col}` : \"\";\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string; after: string} | null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] === \"\\n\") {\n          if (++ctxLines === maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url = \"\") {}\n}\n\nexport class ParseSourceSpan {\n  constructor(public start: ParseLocation, public end: ParseLocation, public details: string | null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR\n}\n\nexport class ParseError {\n  constructor(\n    public span: ParseSourceSpan,\n    public msg: string,\n    public level: ParseErrorLevel = ParseErrorLevel.ERROR\n  ) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? ` (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : \"\";\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : \"\";\n    return `${this.msg}${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n  constructor(span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class InterpolationConfig {\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig = new InterpolationConfig(\"{{\", \"}}\");\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || code === $NBSP;\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return (code >= $a && code <= $z) || (code >= $A && code <= $Z);\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return (code >= $a && code <= $f) || (code >= $A && code <= $F) || isDigit(code);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string | null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n\n  requireExtraParent(currentParent: string): boolean;\n\n  isClosedByChild(name: string): boolean;\n}\n\nexport function splitNsName(elementName: string): [string | null, string] {\n  if (elementName[0] !== \":\") {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(\":\", 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-container\";\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-content\";\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === \"ng-template\";\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string | null): string | null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\n\nexport const NAMED_ENTITIES: {[k: string]: string} = {\n  Aacute: \"\\u00C1\",\n  aacute: \"\\u00E1\",\n  Acirc: \"\\u00C2\",\n  acirc: \"\\u00E2\",\n  acute: \"\\u00B4\",\n  AElig: \"\\u00C6\",\n  aelig: \"\\u00E6\",\n  Agrave: \"\\u00C0\",\n  agrave: \"\\u00E0\",\n  alefsym: \"\\u2135\",\n  Alpha: \"\\u0391\",\n  alpha: \"\\u03B1\",\n  amp: \"&\",\n  and: \"\\u2227\",\n  ang: \"\\u2220\",\n  apos: \"\\u0027\",\n  Aring: \"\\u00C5\",\n  aring: \"\\u00E5\",\n  asymp: \"\\u2248\",\n  Atilde: \"\\u00C3\",\n  atilde: \"\\u00E3\",\n  Auml: \"\\u00C4\",\n  auml: \"\\u00E4\",\n  bdquo: \"\\u201E\",\n  Beta: \"\\u0392\",\n  beta: \"\\u03B2\",\n  brvbar: \"\\u00A6\",\n  bull: \"\\u2022\",\n  cap: \"\\u2229\",\n  Ccedil: \"\\u00C7\",\n  ccedil: \"\\u00E7\",\n  cedil: \"\\u00B8\",\n  cent: \"\\u00A2\",\n  Chi: \"\\u03A7\",\n  chi: \"\\u03C7\",\n  circ: \"\\u02C6\",\n  clubs: \"\\u2663\",\n  cong: \"\\u2245\",\n  copy: \"\\u00A9\",\n  crarr: \"\\u21B5\",\n  cup: \"\\u222A\",\n  curren: \"\\u00A4\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  darr: \"\\u2193\",\n  dArr: \"\\u21D3\",\n  deg: \"\\u00B0\",\n  Delta: \"\\u0394\",\n  delta: \"\\u03B4\",\n  diams: \"\\u2666\",\n  divide: \"\\u00F7\",\n  Eacute: \"\\u00C9\",\n  eacute: \"\\u00E9\",\n  Ecirc: \"\\u00CA\",\n  ecirc: \"\\u00EA\",\n  Egrave: \"\\u00C8\",\n  egrave: \"\\u00E8\",\n  empty: \"\\u2205\",\n  emsp: \"\\u2003\",\n  ensp: \"\\u2002\",\n  Epsilon: \"\\u0395\",\n  epsilon: \"\\u03B5\",\n  equiv: \"\\u2261\",\n  Eta: \"\\u0397\",\n  eta: \"\\u03B7\",\n  ETH: \"\\u00D0\",\n  eth: \"\\u00F0\",\n  Euml: \"\\u00CB\",\n  euml: \"\\u00EB\",\n  euro: \"\\u20AC\",\n  exist: \"\\u2203\",\n  fnof: \"\\u0192\",\n  forall: \"\\u2200\",\n  frac12: \"\\u00BD\",\n  frac14: \"\\u00BC\",\n  frac34: \"\\u00BE\",\n  frasl: \"\\u2044\",\n  Gamma: \"\\u0393\",\n  gamma: \"\\u03B3\",\n  ge: \"\\u2265\",\n  gt: \">\",\n  harr: \"\\u2194\",\n  hArr: \"\\u21D4\",\n  hearts: \"\\u2665\",\n  hellip: \"\\u2026\",\n  Iacute: \"\\u00CD\",\n  iacute: \"\\u00ED\",\n  Icirc: \"\\u00CE\",\n  icirc: \"\\u00EE\",\n  iexcl: \"\\u00A1\",\n  Igrave: \"\\u00CC\",\n  igrave: \"\\u00EC\",\n  image: \"\\u2111\",\n  infin: \"\\u221E\",\n  int: \"\\u222B\",\n  Iota: \"\\u0399\",\n  iota: \"\\u03B9\",\n  iquest: \"\\u00BF\",\n  isin: \"\\u2208\",\n  Iuml: \"\\u00CF\",\n  iuml: \"\\u00EF\",\n  Kappa: \"\\u039A\",\n  kappa: \"\\u03BA\",\n  Lambda: \"\\u039B\",\n  lambda: \"\\u03BB\",\n  lang: \"\\u27E8\",\n  laquo: \"\\u00AB\",\n  larr: \"\\u2190\",\n  lArr: \"\\u21D0\",\n  lceil: \"\\u2308\",\n  ldquo: \"\\u201C\",\n  le: \"\\u2264\",\n  lfloor: \"\\u230A\",\n  lowast: \"\\u2217\",\n  loz: \"\\u25CA\",\n  lrm: \"\\u200E\",\n  lsaquo: \"\\u2039\",\n  lsquo: \"\\u2018\",\n  lt: \"<\",\n  macr: \"\\u00AF\",\n  mdash: \"\\u2014\",\n  micro: \"\\u00B5\",\n  middot: \"\\u00B7\",\n  minus: \"\\u2212\",\n  Mu: \"\\u039C\",\n  mu: \"\\u03BC\",\n  nabla: \"\\u2207\",\n  nbsp: \"\\u00A0\",\n  ndash: \"\\u2013\",\n  ne: \"\\u2260\",\n  ni: \"\\u220B\",\n  not: \"\\u00AC\",\n  notin: \"\\u2209\",\n  nsub: \"\\u2284\",\n  Ntilde: \"\\u00D1\",\n  ntilde: \"\\u00F1\",\n  Nu: \"\\u039D\",\n  nu: \"\\u03BD\",\n  Oacute: \"\\u00D3\",\n  oacute: \"\\u00F3\",\n  Ocirc: \"\\u00D4\",\n  ocirc: \"\\u00F4\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Ograve: \"\\u00D2\",\n  ograve: \"\\u00F2\",\n  oline: \"\\u203E\",\n  Omega: \"\\u03A9\",\n  omega: \"\\u03C9\",\n  Omicron: \"\\u039F\",\n  omicron: \"\\u03BF\",\n  oplus: \"\\u2295\",\n  or: \"\\u2228\",\n  ordf: \"\\u00AA\",\n  ordm: \"\\u00BA\",\n  Oslash: \"\\u00D8\",\n  oslash: \"\\u00F8\",\n  Otilde: \"\\u00D5\",\n  otilde: \"\\u00F5\",\n  otimes: \"\\u2297\",\n  Ouml: \"\\u00D6\",\n  ouml: \"\\u00F6\",\n  para: \"\\u00B6\",\n  permil: \"\\u2030\",\n  perp: \"\\u22A5\",\n  Phi: \"\\u03A6\",\n  phi: \"\\u03C6\",\n  Pi: \"\\u03A0\",\n  pi: \"\\u03C0\",\n  piv: \"\\u03D6\",\n  plusmn: \"\\u00B1\",\n  pound: \"\\u00A3\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  prod: \"\\u220F\",\n  prop: \"\\u221D\",\n  Psi: \"\\u03A8\",\n  psi: \"\\u03C8\",\n  quot: \"\\u0022\",\n  radic: \"\\u221A\",\n  rang: \"\\u27E9\",\n  raquo: \"\\u00BB\",\n  rarr: \"\\u2192\",\n  rArr: \"\\u21D2\",\n  rceil: \"\\u2309\",\n  rdquo: \"\\u201D\",\n  real: \"\\u211C\",\n  reg: \"\\u00AE\",\n  rfloor: \"\\u230B\",\n  Rho: \"\\u03A1\",\n  rho: \"\\u03C1\",\n  rlm: \"\\u200F\",\n  rsaquo: \"\\u203A\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  sdot: \"\\u22C5\",\n  sect: \"\\u00A7\",\n  shy: \"\\u00AD\",\n  Sigma: \"\\u03A3\",\n  sigma: \"\\u03C3\",\n  sigmaf: \"\\u03C2\",\n  sim: \"\\u223C\",\n  spades: \"\\u2660\",\n  sub: \"\\u2282\",\n  sube: \"\\u2286\",\n  sum: \"\\u2211\",\n  sup: \"\\u2283\",\n  sup1: \"\\u00B9\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  supe: \"\\u2287\",\n  szlig: \"\\u00DF\",\n  Tau: \"\\u03A4\",\n  tau: \"\\u03C4\",\n  there4: \"\\u2234\",\n  Theta: \"\\u0398\",\n  theta: \"\\u03B8\",\n  thetasym: \"\\u03D1\",\n  thinsp: \"\\u2009\",\n  THORN: \"\\u00DE\",\n  thorn: \"\\u00FE\",\n  tilde: \"\\u02DC\",\n  times: \"\\u00D7\",\n  trade: \"\\u2122\",\n  Uacute: \"\\u00DA\",\n  uacute: \"\\u00FA\",\n  uarr: \"\\u2191\",\n  uArr: \"\\u21D1\",\n  Ucirc: \"\\u00DB\",\n  ucirc: \"\\u00FB\",\n  Ugrave: \"\\u00D9\",\n  ugrave: \"\\u00F9\",\n  uml: \"\\u00A8\",\n  upsih: \"\\u03D2\",\n  Upsilon: \"\\u03A5\",\n  upsilon: \"\\u03C5\",\n  Uuml: \"\\u00DC\",\n  uuml: \"\\u00FC\",\n  weierp: \"\\u2118\",\n  Xi: \"\\u039E\",\n  xi: \"\\u03BE\",\n  Yacute: \"\\u00DD\",\n  yacute: \"\\u00FD\",\n  yen: \"\\u00A5\",\n  yuml: \"\\u00FF\",\n  Yuml: \"\\u0178\",\n  Zeta: \"\\u0396\",\n  zeta: \"\\u03B6\",\n  zwj: \"\\u200D\",\n  zwnj: \"\\u200C\"\n};\n\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const NGSP_UNICODE = \"\\uE500\";\n\nNAMED_ENTITIES[\"ngsp\"] = NGSP_UNICODE;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport * as chars from \"./chars\";\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from \"./parse_util\";\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from \"./tags\";\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(public type: TokenType, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport function tokenize(\n  source: string,\n  url: string,\n  getTagDefinition: (tagName: string) => TagDefinition,\n  tokenizeExpansionForms = false,\n  interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n): TokenizeResult {\n  return new Tokenizer(\n    new ParseSourceFile(source, url),\n    getTagDefinition,\n    tokenizeExpansionForms,\n    interpolationConfig\n  ).tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? \"EOF\" : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass Tokenizer {\n  private _input: string;\n  private _length: number;\n  // Note: this is always lowercase!\n  private _peek = -1;\n  private _nextPeek = -1;\n  private _index = -1;\n  private _line = 0;\n  private _column = -1;\n  private _currentTokenStart: ParseLocation;\n  private _currentTokenType: TokenType;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation = false;\n\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source\n   * @param _getTagDefinition\n   * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n   * @param _interpolationConfig\n   */\n  constructor(\n    private _file: ParseSourceFile,\n    private _getTagDefinition: (tagName: string) => TagDefinition,\n    private _tokenizeIcu: boolean,\n    private _interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ) {\n    this._input = _file.content;\n    this._length = _file.content.length;\n    this._advance();\n  }\n\n  private _processCarriageReturns(content: string): string {\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, \"\\n\");\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._peek !== chars.$EOF) {\n      const start = this._getLocation();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        if (e instanceof ControlFlowError) {\n          this.errors.push(e.error);\n        } else {\n          throw e;\n        }\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._peek === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getLocation(): ParseLocation {\n    return new ParseLocation(this._file, this._index, this._line, this._column);\n  }\n\n  private _getSpan(\n    start: ParseLocation = this._getLocation(),\n    end: ParseLocation = this._getLocation()\n  ): ParseSourceSpan {\n    return new ParseSourceSpan(start, end);\n  }\n\n  private _beginToken(type: TokenType, start: ParseLocation = this._getLocation()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end: ParseLocation = this._getLocation()): Token {\n    const token = new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n    this.tokens.push(token);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null!;\n    this._currentTokenType = null!;\n    return new ControlFlowError(error);\n  }\n\n  private _advance() {\n    if (this._index >= this._length) {\n      throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n    }\n    if (this._peek === chars.$LF) {\n      this._line++;\n      this._column = 0;\n    } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n      this._column++;\n    }\n    this._index++;\n    this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n    this._nextPeek = this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._peek === charCode) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._getLocation();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._index + len > this._length) {\n      return false;\n    }\n    const initialPosition = this._savePosition();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._restorePosition(initialPosition);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._getLocation();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._peek)) {\n      this._advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._getLocation();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._index - start.offset < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._peek !== char) {\n      this._advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._peek === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      const index = this._index;\n      this._advance();\n      return this._input[index];\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._getLocation();\n    this._advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const numberStart = this._getLocation().offset;\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      this._advance();\n      const strNum = this._input.substring(numberStart, this._index - 1);\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch (e) {\n        const entity = this._input.substring(start.offset + 1, this._index - 1);\n        throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n      }\n    } else {\n      const startPosition = this._savePosition();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._peek !== chars.$SEMICOLON) {\n        this._restorePosition(startPosition);\n        return \"&\";\n      }\n      this._advance();\n      const name = this._input.substring(start.offset + 1, this._index - 1);\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(decodeEntities: boolean, firstCharOfEnd: number, attemptEndRest: () => boolean): Token {\n    let tagCloseStart: ParseLocation;\n    const textStart = this._getLocation();\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n    const parts: string[] = [];\n    while (true) {\n      tagCloseStart = this._getLocation();\n      if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n        break;\n      }\n      if (this._index > tagCloseStart.offset) {\n        // add the characters consumed by the previous if statement to the output\n        parts.push(this._input.substring(tagCloseStart.offset, this._index));\n      }\n      while (this._peek !== firstCharOfEnd) {\n        parts.push(this._readChar(decodeEntities));\n      }\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(\"\"))], tagCloseStart);\n  }\n\n  private _consumeComment(start: ParseLocation) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr(\"->\"));\n    this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: ParseLocation) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr(\"CDATA[\");\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(\"]>\"));\n    this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: ParseLocation) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    this._attemptUntilChar(chars.$GT);\n    this._advance();\n    this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._index;\n    let prefix: string = null!;\n    while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n      this._advance();\n    }\n    let nameStart: number;\n    if (this._peek === chars.$COLON) {\n      this._advance();\n      prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n      nameStart = this._index;\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n    const name = this._input.substring(nameStart, this._index);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: ParseLocation) {\n    const savedPos = this._savePosition();\n    let tagName: string;\n    let lowercaseTagName: string;\n    try {\n      if (!chars.isAsciiLetter(this._peek)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      const nameStart = this._index;\n      this._consumeTagOpenStart(start);\n      tagName = this._input.substring(nameStart, this._index);\n      lowercaseTagName = tagName.toLowerCase();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof ControlFlowError) {\n        // When the start tag is invalid, assume we want a \"<\"\n        this._restorePosition(savedPos);\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken([\"<\"]);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(lowercaseTagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(lowercaseTagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n    this._endToken([null!, lowercaseTagName]);\n  }\n\n  private _consumeTagOpenStart(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    this._beginToken(TokenType.ATTR_VALUE);\n    let value: string;\n    if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n      const quoteChar = this._peek;\n      this._advance();\n      const parts: string[] = [];\n      while (this._peek !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join(\"\");\n      this._advance();\n    } else {\n      const valueStart = this._index;\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._input.substring(valueStart, this._index);\n    }\n    this._endToken([this._processCarriageReturns(value)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._getLocation();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n        this._interpolationConfig &&\n        this._inInterpolation &&\n        this._attemptStr(this._interpolationConfig.end)\n      ) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(\"\"))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _savePosition(): [number, number, number, number, number] {\n    return [this._peek, this._index, this._column, this._line, this.tokens.length];\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._index;\n    this._attemptUntilChar(char);\n    return this._input.substring(start, this._index);\n  }\n\n  private _restorePosition(position: [number, number, number, number, number]): void {\n    this._peek = position[0];\n    this._index = position[1];\n    this._column = position[2];\n    this._line = position[3];\n    const nbTokens = position[4];\n    if (nbTokens < this.tokens.length) {\n      // remove any extra tokens\n      this.tokens = this.tokens.slice(0, nbTokens);\n    }\n  }\n\n  private _isInExpansionCase(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START\n    );\n  }\n\n  private _isInExpansionForm(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START\n    );\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return (\n    chars.isWhitespace(code) ||\n    code === chars.$GT ||\n    code === chars.$SLASH ||\n    code === chars.$SQ ||\n    code === chars.$DQ ||\n    code === chars.$EQ\n  );\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (\n    (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) && (code < chars.$0 || code > chars.$9)\n  );\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionFormStart(input: string, offset: number, interpolationConfig: InterpolationConfig): boolean {\n  const isInterpolationStart = interpolationConfig\n    ? input.indexOf(interpolationConfig.start, offset) === offset\n    : false;\n\n  return input.charCodeAt(offset) === chars.$LBRACE && !isInterpolationStart;\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token | undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\nimport {ParseError, ParseSourceSpan} from \"./parse_util\";\n\nimport * as html from \"./ast\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"./interpolation_config\";\nimport * as lex from \"./lexer\";\nimport {TagDefinition, getNsPrefix, isNgContainer, mergeNsAndName} from \"./tags\";\n\nexport class TreeError extends ParseError {\n  static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string | null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(\n    source: string,\n    url: string,\n    parseExpansionForms = false,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ParseTreeResult {\n    const tokensAndErrors = lex.tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n\n    const treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n\n    return new ParseTreeResult(\n      treeAndErrors.rootNodes,\n      (tokensAndErrors.errors as ParseError[]).concat(treeAndErrors.errors)\n    );\n  }\n}\n\nclass _TreeBuilder {\n  private _index = -1;\n  private _peek: lex.Token;\n\n  private _rootNodes: html.Node[] = [];\n  private _errors: TreeError[] = [];\n\n  private _elementStack: html.Element[] = [];\n\n  constructor(private tokens: lex.Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): ParseTreeResult {\n    while (this._peek.type !== lex.TokenType.EOF) {\n      if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n        this._consumeStartTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === lex.TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n        this._peek.type === lex.TokenType.TEXT ||\n        this._peek.type === lex.TokenType.RAW_TEXT ||\n        this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT\n      ) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n    return new ParseTreeResult(this._rootNodes, this._errors);\n  }\n\n  private _advance(): lex.Token {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n\n  private _advanceIf(type: lex.TokenType): lex.Token | null {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n\n  private _consumeCdata(startToken: lex.Token) {\n    this._consumeText(this._advance());\n    this._advanceIf(lex.TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: lex.Token) {\n    const text = this._advanceIf(lex.TokenType.RAW_TEXT);\n    this._advanceIf(lex.TokenType.COMMENT_END);\n    const value = text !== null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: lex.Token) {\n    const switchValue = this._advance();\n\n    const type = this._advance();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) {\n        return;\n      } // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n    this._addToParent(\n      new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan)\n    );\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase | null {\n    const value = this._advance();\n\n    // read {\n    if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {\n      this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) {\n      return null;\n    }\n\n    const end = this._advance();\n    exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));\n\n    // parse everything in between { and }\n    const parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n    if (parsedExp.errors.length > 0) {\n      this._errors = this._errors.concat(parsedExp.errors as TreeError[]);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n    return new html.ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: lex.Token): lex.Token[] | null {\n    const exp: lex.Token[] = [];\n    const expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (\n        this._peek.type === lex.TokenType.EXPANSION_FORM_START ||\n        this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START\n      ) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) {\n            return exp;\n          }\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EOF) {\n        this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: lex.Token) {\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === \"\\n\") {\n      const parent = this._getParentElement();\n      if (parent !== null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n      }\n    }\n\n    if (text.length > 0) {\n      this._addToParent(new html.Text(text, token.sourceSpan));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: lex.Token) {\n    const prefix = startTagToken.parts[0];\n    const name = startTagToken.parts[1];\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === lex.TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this._errors.push(\n          TreeError.create(\n            fullName,\n            startTagToken.sourceSpan,\n            `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`\n          )\n        );\n      }\n    } else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.start;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n    const el = new html.Element(fullName, attrs, [], span, span, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      this._popElement(fullName);\n      el.endSourceSpan = span;\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    const tagDef = this.getTagDefinition(el.name);\n    const {parent, container} = this._getParentElementSkippingContainers();\n\n    if (parent && tagDef.requireExtraParent(parent.name)) {\n      const newParent = new html.Element(\n        tagDef.parentToAdd,\n        [],\n        [],\n        el.sourceSpan,\n        el.startSourceSpan,\n        el.endSourceSpan\n      );\n      this._insertBeforeContainer(parent, container, newParent);\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: lex.Token) {\n    const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this._getParentElement()) {\n      this._getParentElement()!.endSourceSpan = endTagToken.sourceSpan;\n    }\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this._errors.push(\n        TreeError.create(\n          fullName,\n          endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`\n        )\n      );\n    } else if (!this._popElement(fullName)) {\n      const errMsg = `Unexpected closing tag \"${\n        fullName\n      }\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _popElement(fullName: string): boolean {\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name === fullName) {\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return true;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: lex.Token): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let end = attrName.sourceSpan.end;\n    let value = \"\";\n    let valueSpan: ParseSourceSpan = undefined!;\n    if (this._peek.type === lex.TokenType.ATTR_VALUE) {\n      const valueToken = this._advance();\n      value = valueToken.parts[0];\n      end = valueToken.sourceSpan.end;\n      valueSpan = valueToken.sourceSpan;\n    }\n    return new html.Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n  }\n\n  private _getParentElement(): html.Element | null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  /**\n   * Returns the parent in the DOM and the container.\n   *\n   * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n   */\n  private _getParentElementSkippingContainers(): {parent: html.Element | null; container: html.Element | null} {\n    let container: html.Element | null = null;\n\n    for (let i = this._elementStack.length - 1; i >= 0; i--) {\n      if (!isNgContainer(this._elementStack[i].name)) {\n        return {parent: this._elementStack[i], container};\n      }\n      container = this._elementStack[i];\n    }\n\n    return {parent: null, container};\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent !== null) {\n      parent.children.push(node);\n    } else {\n      this._rootNodes.push(node);\n    }\n  }\n\n  /**\n   * Insert a node between the parent and the container.\n   * When no container is given, the node is appended as a child of the parent.\n   * Also updates the element stack accordingly.\n   *\n   * @internal\n   */\n  private _insertBeforeContainer(parent: html.Element, container: html.Element | null, node: html.Element) {\n    if (!container) {\n      this._addToParent(node);\n      this._elementStack.push(node);\n    } else {\n      if (parent) {\n        // replace the container with the new node in the children\n        const index = parent.children.indexOf(container);\n        parent.children[index] = node;\n      } else {\n        this._rootNodes.push(node);\n      }\n      node.children.push(container);\n      this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element | null): string {\n    if (prefix === null) {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix!;\n      if (prefix === null && parentElement !== null) {\n        prefix = getNsPrefix(parentElement.name);\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from \"./tags\";\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string;\n  contentType: TagContentType = TagContentType.PARSABLE_DATA;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n\n  closedByParent: boolean = false;\n  requiredParents: {[key: string]: boolean};\n  parentToAdd: string;\n  implicitNamespacePrefix: string|null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n\n  constructor(\n      {closedByChildren, requiredParents, implicitNamespacePrefix,\n       contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false,\n       ignoreFirstLf = false}: {\n        closedByChildren?: string[],\n        closedByParent?: boolean,\n        requiredParents?: string[],\n        implicitNamespacePrefix?: string,\n        contentType?: TagContentType,\n        isVoid?: boolean,\n        ignoreFirstLf?: boolean\n      } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    if (requiredParents && requiredParents.length > 0) {\n      this.requiredParents = {};\n      // The first parent is the list is automatically when none of the listed parents are present\n      this.parentToAdd = requiredParents[0];\n      requiredParents.forEach(tagName => this.requiredParents[tagName] = true);\n    }\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n  }\n\n  requireExtraParent(currentParent: string): boolean {\n    if (!this.requiredParents) {\n      return false;\n    }\n\n    if (!currentParent) {\n      return true;\n    }\n\n    const lcParent = currentParent.toLowerCase();\n    const isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n    return !isParentTemplate && this.requiredParents[lcParent] !== true;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nconst TAG_DEFINITIONS: {[key: string]: HtmlTagDefinition} = {\n  'base': new HtmlTagDefinition({isVoid: true}),\n  'meta': new HtmlTagDefinition({isVoid: true}),\n  'area': new HtmlTagDefinition({isVoid: true}),\n  'embed': new HtmlTagDefinition({isVoid: true}),\n  'link': new HtmlTagDefinition({isVoid: true}),\n  'img': new HtmlTagDefinition({isVoid: true}),\n  'input': new HtmlTagDefinition({isVoid: true}),\n  'param': new HtmlTagDefinition({isVoid: true}),\n  'hr': new HtmlTagDefinition({isVoid: true}),\n  'br': new HtmlTagDefinition({isVoid: true}),\n  'source': new HtmlTagDefinition({isVoid: true}),\n  'track': new HtmlTagDefinition({isVoid: true}),\n  'wbr': new HtmlTagDefinition({isVoid: true}),\n  'p': new HtmlTagDefinition({\n    closedByChildren: [\n      'address', 'article', 'aside', 'blockquote', 'div', 'dl',      'fieldset', 'footer', 'form',\n      'h1',      'h2',      'h3',    'h4',         'h5',  'h6',      'header',   'hgroup', 'hr',\n      'main',    'nav',     'ol',    'p',          'pre', 'section', 'table',    'ul'\n    ],\n    closedByParent: true\n  }),\n  'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n  'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n  'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n  'tr': new HtmlTagDefinition({\n    closedByChildren: ['tr'],\n    requiredParents: ['tbody', 'tfoot', 'thead'],\n    closedByParent: true\n  }),\n  'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n  'col': new HtmlTagDefinition({requiredParents: ['colgroup'], isVoid: true}),\n  'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n  'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n  'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n  'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n  'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n  'rb': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rt': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n  'rp': new HtmlTagDefinition({closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n  'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n  'option': new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n  'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n  'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n  'title': new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT}),\n  'textarea':\n      new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n};\n\nconst _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nPluralPipe, I18nSelectPipe, NgLocaleLocalization} from \"@angular/common\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport * as xml from \"./xml_helper\";\n\nexport interface I18nMessagesById {\n  [msgId: string]: i18n.Node[];\n}\n\nexport interface XmlMessagesById {\n  [id: string]: xml.Node;\n}\n\nexport interface IcuContent {\n  cases: {[value: string]: html.Node[]};\n  expression: string;\n  type: string;\n}\n\nexport interface IcuContentStr {\n  cases: {[value: string]: string};\n  expression: string;\n  type: string;\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string | null;\n\n  toInternalName(publicName: string): string | null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string | null {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n\n  toInternalName(publicName: string): string | null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n\n  visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n\nconst i18nSelectPipe = new I18nSelectPipe();\nclass SerializerVisitor implements html.Visitor {\n  private i18nPluralPipe: I18nPluralPipe;\n  constructor(locale: string, private params: {[key: string]: any}) {\n    this.i18nPluralPipe = new I18nPluralPipe(new NgLocaleLocalization(locale));\n  }\n  visitElement(element: html.Element, context: any): any {\n    if (getHtmlTagDefinition(element.name).isVoid) {\n      return `<${element.name}${this.serializeNodes(element.attrs, \" \")}/>`;\n    }\n\n    return `<${element.name}${this.serializeNodes(element.attrs, \" \")}>${this.serializeNodes(element.children)}</${\n      element.name\n    }>`;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return `${attribute.name}=\"${attribute.value}\"`;\n  }\n\n  visitText(text: html.Text, context: any): any {\n    return text.value;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return `<!--${comment.value}-->`;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    const cases = {};\n    expansion.cases.forEach(c => (cases[c.value] = this.serializeNodes(c.expression)));\n\n    switch (expansion.type) {\n      case \"select\":\n        return i18nSelectPipe.transform(this.params[expansion.switchValue] || \"\", cases);\n      case \"plural\":\n        return this.i18nPluralPipe.transform(this.params[expansion.switchValue], cases);\n    }\n    throw new Error(`Unknown expansion type \"${expansion.type}\"`);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return ` ${expansionCase.value} {${this.serializeNodes(expansionCase.expression)}}`;\n  }\n\n  private serializeNodes(nodes: html.Node[], join = \"\"): string {\n    if (nodes.length === 0) {\n      return \"\";\n    }\n    return join + nodes.map(a => a.visit(this, null)).join(join);\n  }\n}\n\nexport function serializeNodes(nodes: html.Node[], locale: string, params: {[key: string]: any}): string[] {\n  return nodes.map(node => node.visit(new SerializerVisitor(locale, params), null));\n}\n\nexport class HtmlToXmlParser implements html.Visitor {\n  private errors: I18nError[];\n  private xmlMessagesById: {[id: string]: xml.Node};\n\n  constructor(private MESSAGE_TAG: string) {}\n\n  parse(content: string) {\n    this.xmlMessagesById = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this.errors = parser.errors;\n    html.visitAll(this, parser.rootNodes, null);\n\n    return {\n      xmlMessagesById: this.xmlMessagesById,\n      errors: this.errors\n    };\n  }\n\n  visitElement(element: html.Element, context: any): any {\n    switch (element.name) {\n      case this.MESSAGE_TAG:\n        const id = element.attrs.find(attr => attr.name === \"id\");\n        if (id) {\n          this.xmlMessagesById[id.value] = (element as any) as xml.Node;\n        }\n        break;\n      default:\n        html.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {}\n\n  visitText(text: html.Text, context: any): any {}\n\n  visitComment(comment: html.Comment, context: any): any {}\n\n  visitExpansion(expansion: html.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\n\nexport function digest(message: i18n.Message): string {\n  return message.id || sha1(serializeNodes(message.nodes).join(\"\") + `[${message.meaning}]`);\n}\n\nexport function decimalDigest(message: i18n.Message): string {\n  if (message.id) {\n    return message.id;\n  }\n\n  const visitor = new SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(\"\"), message.meaning);\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(\", \")}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(\", \")}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(\", \")}</ph name=\"${\n          ph.closeName\n        }\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n html to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass SerializerIgnoreIcuExpVisitor extends SerializerVisitor {\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(\", \")}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = stringToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Array(80);\n  let [a, b, c, d, e]: number[] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const [h0, h1, h2, h3, h4]: number[] = [a, b, c, d, e];\n\n    for (let j = 0; j < 80; j++) {\n      /* tslint:disable-next-line */\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const [f, k] = fk(j, b, c, d);\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];\n    }\n\n    [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];\n  }\n\n  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let [hi, lo] = [hash32(utf8, 0), hash32(utf8, 102072)];\n\n  if (hi === 0 && (lo === 0 || lo === 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string): string {\n  let [hi, lo] = fingerprint(msg);\n\n  if (meaning) {\n    const [him, lom] = fingerprint(meaning);\n    [hi, lo] = add64(rol64([hi, lo], 1), [him, lom]);\n  }\n\n  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n\nfunction hash32(str: string, c: number): number {\n  let [a, b] = [0x9e3779b9, 0x9e3779b9];\n  let i: number;\n\n  const len = str.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    c = add32(c, wordAt(str, i + 8, Endian.Little));\n    [a, b, c] = mix([a, b, c]);\n  }\n\n  a = add32(a, wordAt(str, i, Endian.Little));\n  b = add32(b, wordAt(str, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n\n  return mix([a, b, c])[2];\n}\n\n// clang-format off\nfunction mix([a, b, c]: [number, number, number]): [number, number, number] {\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 13;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 8;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 13;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 12;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 16;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 5;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 3;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 10;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64([ah, al]: [number, number], [bh, bl]: [number, number]): [number, number] {\n  const [carry, l] = add32to64(al, bl);\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64([hi, lo]: [number, number], count: number): [number, number] {\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction stringToWords32(str: string, endian: Endian): number[] {\n  const words32 = Array((str.length + 3) >>> 2);\n\n  for (let i = 0; i < words32.length; i++) {\n    words32[i] = wordAt(str, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(str: string, index: number): number {\n  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n\nfunction wordAt(str: string, index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): string {\n  return words32.reduce((str, word) => str + word32ToByteString(word), \"\");\n}\n\nfunction word32ToByteString(word: number): string {\n  let str = \"\";\n  for (let i = 0; i < 4; i++) {\n    str += String.fromCharCode((word >>> (8 * (3 - i))) & 0xff);\n  }\n  return str;\n}\n\nfunction byteStringToHexString(str: string): string {\n  let hex = \"\";\n  for (let i = 0; i < str.length; i++) {\n    const b = byteAt(str, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str: string): string {\n  let decimal = \"\";\n  let toThePower = \"1\";\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n    toThePower = numberTimesBigInt(256, toThePower);\n  }\n\n  return decimal\n    .split(\"\")\n    .reverse()\n    .join(\"\");\n}\n\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x: string, y: string): string {\n  let sum = \"\";\n  const len = Math.max(x.length, y.length);\n  for (let i = 0, carry = 0; i < len || carry; i++) {\n    const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n    if (tmpSum >= 10) {\n      carry = 1;\n      sum += tmpSum - 10;\n    } else {\n      carry = 0;\n      sum += tmpSum;\n    }\n  }\n\n  return sum;\n}\n\nfunction numberTimesBigInt(num: number, b: string): string {\n  let product = \"\";\n  let bToThePower = b;\n  for (; num !== 0; num = num >>> 1) {\n    if (num & 1) {\n      product = addBigInt(product, bToThePower);\n    }\n    bToThePower = addBigInt(bToThePower, bToThePower);\n  }\n  return product;\n}\n\nfunction utf8Encode(str: string): string {\n  let encoded = \"\";\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(((codePoint >> 6) & 0x1f) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(\n        (codePoint >> 12) | 0xe0,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(\n        ((codePoint >> 18) & 0x07) | 0xf0,\n        ((codePoint >> 12) & 0x3f) | 0x80,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80\n      );\n    }\n  }\n\n  return encoded;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\n\nconst _VERSION = \"1.2\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:1.2\";\nconst _PLACEHOLDER_TAG = \"x\";\nconst _FILE_TAG = \"file\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"trans-unit\";\nconst _CONTEXT_GROUP_TAG = \"context-group\";\nconst _CONTEXT_TAG = \"context\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\n\nexport function xliffLoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliffParser = new XliffParser();\n  const {msgIdToHtml, errors} = xliffParser.parse(content);\n\n  // xml nodes to i18n messages\n  const i18nMessagesById: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nMessagesById[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nMessagesById;\n}\n\n// used to merge translations when extracting\nexport function xliffLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\n// http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport function xliffWrite(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const transUnits: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(6), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const contextTags: xml.Node[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      const contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: \"location\"});\n      contextGroupTag.children.push(\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"sourcefile\"}, [new xml.Text(source.filePath)]),\n        new xml.CR(10),\n        new xml.Tag(_CONTEXT_TAG, {\"context-type\": \"linenumber\"}, [new xml.Text(`${source.startLine}`)]),\n        new xml.CR(8)\n      );\n      contextTags.push(new xml.CR(8), contextGroupTag);\n    });\n\n    const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: \"html\"});\n    transUnit.children.push(\n      new xml.CR(8),\n      new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n      ...contextTags\n    );\n\n    if (message.description) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"description\"}, [new xml.Text(message.description)])\n      );\n    }\n\n    if (message.meaning) {\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(\"note\", {priority: \"1\", from: \"meaning\"}, [new xml.Text(message.meaning)])\n      );\n    }\n\n    transUnit.children.push(new xml.CR(6));\n\n    transUnits.push(new xml.CR(6), transUnit);\n  });\n\n  const body = new xml.Tag(\"body\", {}, [...transUnits, new xml.CR(4)]);\n  const file = new xml.Tag(\n    \"file\",\n    {\n      \"source-language\": locale || _DEFAULT_SOURCE_LANG,\n      datatype: \"plaintext\",\n      original: \"ng2.template\"\n    },\n    [new xml.CR(4), body, new xml.CR(2)]\n  );\n  const xliff = new xml.Tag(\"xliff\", {version: _VERSION, xmlns: _XMLNS}, [new xml.CR(2), file, new xml.CR()]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliffDigest = digest;\n\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"id\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}/>`})];\n    }\n\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, \"equiv-text\": `<${ph.tag}>`});\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, \"equiv-text\": `</${ph.tag}>`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": `{{${ph.value}}}`})];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \")}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, \"equiv-text\": equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n      return \"lb\";\n    case \"img\":\n      return \"image\";\n    default:\n      return `x-${tag}`;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as xml from \"./xml_helper\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {HtmlToXmlParser, I18nMessagesById, XmlMessagesById} from \"./serializer\";\nimport {decimalDigest} from \"./digest\";\n\nconst _VERSION = \"2.0\";\nconst _XMLNS = \"urn:oasis:names:tc:xliff:document:2.0\";\nconst _DEFAULT_SOURCE_LANG = \"en\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _PLACEHOLDER_SPANNING_TAG = \"pc\";\nconst _XLIFF_TAG = \"xliff\";\nconst _SOURCE_TAG = \"source\";\nconst _TARGET_TAG = \"target\";\nconst _UNIT_TAG = \"unit\";\nconst _NOTES_TAG = \"notes\";\nconst _NOTE_TAG = \"note\";\nconst _SEGMENT_TAG = \"segment\";\nconst _FILE_TAG = \"file\";\n\n// http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport function xliff2LoadToI18n(content: string): I18nMessagesById {\n  // xliff to xml nodes\n  const xliff2Parser = new Xliff2Parser();\n  const {msgIdToHtml, errors} = xliff2Parser.parse(content);\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId]);\n    errors.push(...e);\n    i18nNodesByMsgId[msgId] = i18nNodes;\n  });\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return i18nNodesByMsgId;\n}\n\n// used to merge translations when extracting\nexport function xliff2LoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_UNIT_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xliff2 parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xliff2Write(messages: i18n.Message[], locale: string | null, existingNodes?: xml.Node[]): string {\n  const visitor = new WriteVisitor();\n  const units: xml.Node[] = existingNodes && existingNodes.length ? [new xml.CR(4), ...existingNodes] : [];\n\n  messages.forEach(message => {\n    const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n    const notes = new xml.Tag(_NOTES_TAG);\n\n    if (message.description || message.meaning) {\n      if (message.description) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"description\"}, [new xml.Text(message.description)])\n        );\n      }\n\n      if (message.meaning) {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag(_NOTE_TAG, {category: \"meaning\"}, [new xml.Text(message.meaning)])\n        );\n      }\n    }\n\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      notes.children.push(\n        new xml.CR(8),\n        new xml.Tag(_NOTE_TAG, {category: \"location\"}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    notes.children.push(new xml.CR(6));\n    unit.children.push(new xml.CR(6), notes);\n\n    const segment = new xml.Tag(_SEGMENT_TAG);\n\n    segment.children.push(new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new xml.CR(6));\n\n    unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n    units.push(new xml.CR(4), unit);\n  });\n\n  const file = new xml.Tag(_FILE_TAG, {original: \"ng.template\", id: \"ngi18n\"}, [...units, new xml.CR(2)]);\n\n  const xliff = new xml.Tag(_XLIFF_TAG, {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG}, [\n    new xml.CR(2),\n    file,\n    new xml.CR()\n  ]);\n\n  return xml.serialize([new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}), new xml.CR(), xliff, new xml.CR()]);\n}\n\nexport const xliff2Digest = decimalDigest;\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  private _unitMlString: string | null;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(content: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const parser = new Parser(getXmlTagDefinition).parse(content, \"\", false);\n\n    this._errors = parser.errors;\n    ml.visitAll(this, parser.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === \"string\") {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan!.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan!.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const versionAttr = element.attrs.find(attr => attr.name === \"version\");\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== \"2.0\") {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[] | null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find(attr => attr.name === \"equiv\");\n        if (nameAttr) {\n          return [new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === \"equivStart\");\n        const endAttr = el.attrs.find(attr => attr.name === \"equivEnd\");\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n            new i18n.Placeholder(\"\", startId, el.sourceSpan),\n            ...el.children.map(node => node.visit(this, null)),\n            new i18n.Placeholder(\"\", endId, el.sourceSpan)\n          );\n        }\n        break;\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression))\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nclass WriteVisitor implements i18n.Visitor {\n  private _nextPlaceholderId: number;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(\"\"));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{{${ph.value}}}`\n      })\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases)\n      .map((value: string) => value + \" {...}\")\n      .join(\" \");\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n      })\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case \"br\":\n    case \"b\":\n    case \"i\":\n    case \"u\":\n      return \"fmt\";\n    case \"img\":\n      return \"image\";\n    case \"a\":\n      return \"link\";\n    default:\n      return \"other\";\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from \"../ast/i18n_ast\";\nimport * as ml from \"../ast/ast\";\nimport * as xml from \"./xml_helper\";\nimport {decimalDigest} from \"./digest\";\nimport {HtmlToXmlParser, PlaceholderMapper, SimplePlaceholderMapper, XmlMessagesById} from \"./serializer\";\n\nconst _MESSAGES_TAG = \"messagebundle\";\nconst _MESSAGE_TAG = \"msg\";\nconst _PLACEHOLDER_TAG = \"ph\";\nconst _EXEMPLE_TAG = \"ex\";\nconst _SOURCE_TAG = \"source\";\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\n// used to merge translations when extracting\nexport function xmbLoadToXml(content: string): XmlMessagesById {\n  const parser = new HtmlToXmlParser(_MESSAGE_TAG);\n  const {xmlMessagesById, errors} = parser.parse(content);\n\n  if (errors.length) {\n    throw new Error(`xmb parse errors:\\n${errors.join(\"\\n\")}`);\n  }\n\n  return xmlMessagesById;\n}\n\nexport function xmbWrite(messages: i18n.Message[], locale: string | null, existingNodes: xml.Node[] = []): string {\n  const exampleVisitor = new ExampleVisitor();\n  const visitor = new Visitor();\n  const rootNode = new xml.Tag(_MESSAGES_TAG);\n\n  existingNodes.forEach(node => {\n    rootNode.children.push(new xml.CR(2), node);\n  });\n\n  // console.log(existingNodes);\n  messages.forEach(message => {\n    const attrs: {[k: string]: string} = {id: message.id};\n\n    if (message.description) {\n      attrs[\"desc\"] = message.description;\n    }\n\n    if (message.meaning) {\n      attrs[\"meaning\"] = message.meaning;\n    }\n\n    const sourceTags: xml.Tag[] = [];\n    message.sources.forEach((source: i18n.MessageSpan) => {\n      sourceTags.push(\n        new xml.Tag(_SOURCE_TAG, {}, [\n          new xml.Text(\n            `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? \",\" + source.endLine : \"\"}`\n          )\n        ])\n      );\n    });\n\n    rootNode.children.push(\n      new xml.CR(2),\n      new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)])\n    );\n  });\n\n  rootNode.children.push(new xml.CR());\n\n  return xml.serialize([\n    new xml.Declaration({version: \"1.0\", encoding: \"UTF-8\"}),\n    new xml.CR(),\n    new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n    new xml.CR(),\n    exampleVisitor.addDefaultExamples(rootNode),\n    new xml.CR()\n  ]);\n}\n\nexport function xmbDigest(message: i18n.Message): string {\n  return digest(message);\n}\n\nexport function xmbMapper(message: i18n.Message): PlaceholderMapper {\n  return new SimplePlaceholderMapper(message, toPublicName);\n}\n\nclass Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`<${ph.tag}>`)]);\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`</${ph.tag}>`)]);\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`{{${ph.value}}}`)]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const exTag = new xml.Tag(_EXEMPLE_TAG, {}, [\n      new xml.Text(\n        `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n          .map((value: string) => value + \" {...}\")\n          .join(\" \")}}`\n      )\n    ]);\n    return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag])];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length === 0) {\n        const exText = new xml.Text(tag.attrs[\"name\"] || \"...\");\n        tag.children = [new xml.Tag(_EXEMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: ml.Element): any {\n    const attrs = {};\n    element.attrs.forEach((attr: ml.Attribute) => {\n      attrs[attr.name] = attr.value;\n    });\n    const tag = new xml.Tag(element.name, attrs, element.children as any);\n    return this.visitTag(tag);\n  }\n\n  visitText(text: xml.Text): void {}\n\n  visitDeclaration(decl: xml.Declaration): void {}\n\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, \"_\");\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {Parser} from \"../ast/parser\";\nimport {getXmlTagDefinition} from \"../ast/xml_tags\";\nimport {I18nMessagesById} from \"./serializer\";\nimport {digest} from \"./digest\";\nimport {xmbMapper} from \"./xmb\";\n\nconst _TRANSLATIONS_TAG = \"translationbundle\";\nconst _TRANSLATION_TAG = \"translation\";\nconst _PLACEHOLDER_TAG = \"ph\";\n\nexport function xtbLoadToI18n(content: string): I18nMessagesById {\n  // xtb to xml nodes\n  const xtbParser = new XtbParser();\n  const {msgIdToHtml, errors: parseErrors} = xtbParser.parse(content);\n\n  if (parseErrors.length) {\n    throw new Error(`xtb parse errors:\\n${parseErrors.join(\"\\n\")}`);\n  }\n\n  // xml nodes to i18n nodes\n  const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n  const converter = new XmlToI18n();\n\n  // Because we should be able to load xtb files that rely on features not supported by angular,\n  // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n  // converted\n  Object.keys(msgIdToHtml).forEach(msgId => {\n    const valueFn = () => {\n      const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId]);\n      if (errors.length) {\n        throw new Error(`xtb parse errors:\\n${errors.join(\"\\n\")}`);\n      }\n      return i18nNodes;\n    };\n    createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n  });\n\n  return i18nNodesByMsgId;\n}\n\nexport const xtbDigest = digest;\n\nexport const xtbMapper = xmbMapper;\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: _ => {\n      throw new Error(\"Could not overwrite an XTB translation\");\n    }\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  private _bundleDepth: number;\n  private _errors: I18nError[];\n  private _msgIdToHtml: {[msgId: string]: string};\n\n  parse(xtb: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new Parser(getXmlTagDefinition).parse(xtb, \"\", false);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === \"id\");\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan!.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan!.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, \"Unexpected tag\");\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  private _errors: I18nError[];\n\n  convert(message: string) {\n    const xmlIcu = new Parser(getXmlTagDefinition).parse(message, \"\", true);\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length === 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan!);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression)\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === \"name\");\n      if (nameAttr) {\n        return new i18n.Placeholder(\"\", nameAttr.value, el.sourceSpan!);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan!, message));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class ParserError {\n  public message: string;\n  constructor(message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n  constructor(public span: ParseSpan) {}\n  visit(visitor: AstVisitor, context: any = null): any {\n    return null;\n  }\n  toString(): string {\n    return \"AST\";\n  }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(span: ParseSpan, public prefix: string, public uninterpretedExpression: string, public location: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitQuote(this, context);\n  }\n  toString(): string {\n    return \"Quote\";\n  }\n}\n\nexport class EmptyExpr extends AST {\n  visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends AST {\n  constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, public value: any) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport interface LiteralMapKey {\n  key: string;\n  quoted: boolean;\n}\n\nexport class LiteralMap extends AST {\n  constructor(span: ParseSpan, public keys: LiteralMapKey[], public values: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(span: ParseSpan, public strings: any[], public expressions: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, public expression: AST) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class MethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitMethodCall(this, context);\n  }\n}\n\nexport class SafeMethodCall extends AST {\n  constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeMethodCall(this, context);\n  }\n}\n\nexport class FunctionCall extends AST {\n  constructor(span: ParseSpan, public target: AST | null, public args: any[]) {\n    super(span);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitFunctionCall(this, context);\n  }\n}\n\nexport class ASTWithSource extends AST {\n  constructor(public ast: AST, public source: string | null, public location: string, public errors: ParserError[]) {\n    super(new ParseSpan(0, source == null ? 0 : source.length));\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return this.ast.visit(visitor, context);\n  }\n  toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\nexport class TemplateBinding {\n  constructor(\n    public span: ParseSpan,\n    public key: string,\n    public keyIsVar: boolean,\n    public name: string,\n    public expression: ASTWithSource\n  ) {}\n}\n\nexport interface AstVisitor {\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  visitFunctionCall(ast: FunctionCall, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitMethodCall(ast: MethodCall, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visitBinary(ast: Binary, context: any): any {\n    ast.left.visit(this);\n    ast.right.visit(this);\n    return null;\n  }\n  visitChain(ast: Chain, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    ast.condition.visit(this);\n    ast.trueExp.visit(this);\n    ast.falseExp.visit(this);\n    return null;\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitFunctionCall(ast: FunctionCall, context: any): any {\n    ast.target!.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n    return null;\n  }\n  visitInterpolation(ast: Interpolation, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    return null;\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    ast.obj.visit(this);\n    ast.key.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    return this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n    return null;\n  }\n  visitMethodCall(ast: MethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    ast.expression.visit(this);\n    return null;\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    ast.receiver.visit(this);\n    ast.value.visit(this);\n    return null;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    ast.receiver.visit(this);\n    return null;\n  }\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    ast.receiver.visit(this);\n    return this.visitAll(ast.args, context);\n  }\n  visitAll(asts: AST[], context: any): any {\n    asts.forEach(ast => ast.visit(this, context));\n    return null;\n  }\n  visitQuote(ast: Quote, context: any): any {\n    return null;\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    return new FunctionCall(ast.span, ast.target!.visit(this), this.visitAll(ast.args));\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = new Array(asts.length);\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(public index: number, public type: TokenType, public numValue: number, public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n\n  isNumber(): boolean {\n    return this.type === TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type === TokenType.String;\n  }\n\n  isOperator(operater: string): boolean {\n    return this.type === TokenType.Operator && this.strValue === operater;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === TokenType.Identifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type === TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"let\";\n  }\n\n  isKeywordAs(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"as\";\n  }\n\n  isKeywordNull(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"null\";\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"undefined\";\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"true\";\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"false\";\n  }\n\n  isKeywordThis(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === \"this\";\n  }\n\n  isError(): boolean {\n    return this.type === TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string | null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, \"\");\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, \"\");\n\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token | null {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (chars.isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, \"?\", chars.$PERIOD, \".\");\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\");\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, \"=\", chars.$EQ, \"=\");\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, \"&\", chars.$AMPERSAND, \"&\");\n      case chars.$BAR:\n        return this.scanComplexOperator(start, \"|\", chars.$BAR, \"|\");\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) {\n          this.advance();\n        }\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n    start: number,\n    one: string,\n    twoCode: number,\n    two: string,\n    threeCode?: number,\n    three?: string\n  ): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek === twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek === threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) {\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = this.index === start;\n    this.advance(); // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) {\n          this.advance();\n        }\n        if (!chars.isDigit(this.peek)) {\n          return this.error(\"Invalid exponent\", -1);\n        }\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance(); // Skip initial quote.\n\n    let buffer = \"\";\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek !== quote) {\n      if (this.peek === chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek === chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek === chars.$EOF) {\n        return this.error(\"Unterminated quote\", 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance(); // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (\n    (chars.$a <= code && code <= chars.$z) ||\n    (chars.$A <= code && code <= chars.$Z) ||\n    code === chars.$_ ||\n    code === chars.$$\n  );\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length === 0) {\n    return false;\n  }\n  const scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) {\n    return false;\n  }\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) {\n      return false;\n    }\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_ || code === chars.$$;\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code === chars.$e || code === chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code === chars.$MINUS || code === chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text, 10);\n  if (isNaN(result)) {\n    throw new Error(\"Invalid integer literal when parsing \" + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable */\n\nimport * as chars from \"../ast/chars\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {escapeRegExp} from \"../ast/parse_util\";\n\nimport {\n  AST,\n  ASTWithSource,\n  AstVisitor,\n  Binary,\n  BindingPipe,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  FunctionCall,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  KeyedWrite,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  MethodCall,\n  NonNullAssert,\n  ParseSpan,\n  ParserError,\n  PrefixNot,\n  PropertyRead,\n  PropertyWrite,\n  Quote,\n  SafeMethodCall,\n  SafePropertyRead,\n  TemplateBinding\n} from \"./ast\";\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from \"./lexer\";\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(public templateBindings: TemplateBinding[], public warnings: string[], public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + \"([\\\\s\\\\S]*?)\" + escapeRegExp(config.end);\n  return new RegExp(pattern, \"g\");\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      true,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(`Host binding expression cannot contain ${errors.join(\" \")}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new ParseAST(\n      input,\n      location,\n      tokens,\n      sourceToLex.length,\n      false,\n      this.errors,\n      input.length - sourceToLex.length\n    ).parseChain();\n  }\n\n  private _parseQuote(input: string | null, location: any): AST | null {\n    if (input === null) {\n      return null;\n    }\n    const prefixSeparatorIndex = input.indexOf(\":\");\n    if (prefixSeparatorIndex === -1) {\n      return null;\n    }\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) {\n      return null;\n    }\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(prefixToken: string | null, input: string, location: any): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new ParseAST(input, location, tokens, input.length, false, this.errors, 0).parseTemplateBindings();\n  }\n\n  parseInterpolation(\n    input: string,\n    location: any,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): ASTWithSource | null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split === null) {\n      return null;\n    }\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new ParseAST(\n        input,\n        location,\n        tokens,\n        sourceToLex.length,\n        false,\n        this.errors,\n        split.offsets[i] + (expressionText.length - sourceToLex.length)\n      ).parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n      new Interpolation(new ParseSpan(0, input === null ? 0 : input.length), split.strings, expressions),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  splitInterpolation(\n    input: string,\n    location: string,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): SplitInterpolation | null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n          \"Blank expressions are not allowed in interpolated strings\",\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n          location\n        );\n        expressions.push(\"$implict\");\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource {\n    return new ASTWithSource(\n      new LiteralPrimitive(new ParseSpan(0, input === null ? 0 : input.length), input),\n      input,\n      location,\n      this.errors\n    );\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar === chars.$SLASH && outerQuote === null) {\n        return i;\n      }\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote === null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n        `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n        input,\n        `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n        location\n      );\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n    parts: string[],\n    partInErrIdx: number,\n    interpolationConfig: InterpolationConfig\n  ): number {\n    let errLocation = \"\";\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ? parts[j] : `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index = 0;\n\n  constructor(\n    public input: string,\n    public location: any,\n    public tokens: Token[],\n    public inputLength: number,\n    public parseAction: boolean,\n    private errors: ParserError[],\n    private offset: number\n  ) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  get inputIndex(): number {\n    return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n  }\n\n  span(start: number) {\n    return new ParseSpan(start, this.inputIndex);\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) {\n      return;\n    }\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) {\n      return;\n    }\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return \"\";\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error(\"Binding expression cannot contain chained expression\");\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length === 0) {\n      return new EmptyExpr(this.span(start));\n    }\n    if (exprs.length === 1) {\n      return exprs[0];\n    }\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator(\"|\")) {\n      if (this.parseAction) {\n        this.error(\"Cannot have a pipe in an action expression\");\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator(\"|\"));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator(\"?\")) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator(\"||\")) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), \"||\", result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator(\"&&\")) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), \"&&\", result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"==\":\n        case \"===\":\n        case \"!=\":\n        case \"!==\":\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"<\":\n        case \">\":\n        case \"<=\":\n        case \">=\":\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"+\":\n        case \"-\":\n          this.advance();\n          const right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type === TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case \"*\":\n        case \"%\":\n        case \"/\":\n          this.advance();\n          const right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type === TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case \"+\":\n          this.advance();\n          return this.parsePrefix();\n        case \"-\":\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n        case \"!\":\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n      } else if (this.optionalOperator(\"?.\")) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator(\"=\")) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n      } else if (this.optionalOperator(\"!\")) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) : new MethodCall(span, receiver, id, args);\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator(\"=\")) {\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) {\n            this.error(\"Bindings cannot contain assignments\");\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) {\n      return [];\n    }\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` inbetween.\n   */\n  expectTemplateBindingKey(): string {\n    let result = \"\";\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator(\"-\");\n      if (operatorFound) {\n        result += \"-\";\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  parseTemplateBindings(): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n    let prefix: string = null!;\n    const warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const start = this.inputIndex;\n      let keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      const rawKey = this.expectTemplateBindingKey();\n      let key = rawKey;\n      if (!keyIsVar) {\n        if (prefix === null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let name: string = null!;\n      let expression: ASTWithSource = null!;\n      if (keyIsVar) {\n        if (this.optionalOperator(\"=\")) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = \"$implicit\";\n        }\n      } else if (this.peekKeywordAs()) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey(); // read local var name\n        keyIsVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const st = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(st - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (this.peekKeywordAs() && !keyIsVar) {\n        const letStart = this.inputIndex;\n        this.advance(); // consume `as`\n        const letName = this.expectTemplateBindingKey(); // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null!));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number | null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number | null = null) {\n    if (index === null) {\n      index = this.index;\n    }\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) {\n    this.visitAll(ast.expressions);\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any) {\n    this.visitAll(ast.values);\n  }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) {\n    this.errors.push(\"pipes\");\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] {\n    return asts.map(node => node.visit(this));\n  }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * @internal\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string { return this._hashTag(`/${tag}`, {}, false); }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {InterpolationConfig} from \"../ast/interpolation_config\";\nimport {Parser} from \"./parser\";\nimport {Lexer} from \"./lexer\";\nimport {PlaceholderRegistry} from \"../serializers/placeholder\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {ParseSourceSpan} from \"../ast/parse_util\";\n\nconst _expParser = new Parser(new Lexer());\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(\n  interpolationConfig: InterpolationConfig\n): (nodes: html.Node[], meaning: string, description: string, id: string) => i18n.Message {\n  const visitor = new I18nVisitor(_expParser, interpolationConfig);\n\n  return (nodes: html.Node[], meaning: string, description: string, id: string) =>\n    visitor.toI18nMessage(nodes, meaning, description, id);\n}\n\nclass I18nVisitor implements html.Visitor {\n  private _isIcu: boolean;\n  private _icuDepth: number;\n  private _placeholderRegistry: PlaceholderRegistry;\n  private _placeholderToContent: {[phName: string]: string};\n  private _placeholderToMessage: {[phName: string]: i18n.Message};\n\n  constructor(private _expressionParser: Parser, private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(nodes: html.Node[], meaning: string, description: string, id: string): i18n.Message {\n    this._isIcu = nodes.length === 1 && nodes[0] instanceof html.Expansion;\n    this._icuDepth = 0;\n    this._placeholderRegistry = new PlaceholderRegistry();\n    this._placeholderToContent = {};\n    this._placeholderToMessage = {};\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, {});\n\n    return new i18n.Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n  }\n\n  visitElement(el: html.Element, context: any): i18n.Node {\n    const children = html.visitAll(this, el.children);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    this._placeholderToContent[startPhName] = el.sourceSpan ? el.sourceSpan!.toString() : \"\";\n\n    let closePhName = \"\";\n\n    if (!isVoid) {\n      closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      this._placeholderToContent[closePhName] = `</${el.name}>`;\n    }\n\n    return new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan!);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan!);\n  }\n\n  visitComment(comment: html.Comment, context: any): i18n.Node | null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): i18n.Node {\n    this._icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n        caze.expression.map(node => node.visit(this, {})),\n        caze.expSourceSpan\n      );\n    });\n    this._icuDepth--;\n\n    if (this._isIcu || this._icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      this._placeholderToContent[expPh] = icu.switchValue;\n\n      return i18nIcu;\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations. We need to create a new visitor (they are not re-entrant) to compute the\n    // message id.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = this._placeholderRegistry.getPlaceholderName(\"ICU\", icu.sourceSpan.toString());\n    const visitor = new I18nVisitor(this._expressionParser, this._interpolationConfig);\n    this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], \"\", \"\", \"\");\n    return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): i18n.Node {\n    throw new Error(\"Unreachable code\");\n  }\n\n  private _visitTextWithInterpolation(text: string, sourceSpan: ParseSourceSpan): i18n.Node {\n    const splitInterpolation = this._expressionParser.splitInterpolation(\n      text,\n      sourceSpan.start.toString(),\n      this._interpolationConfig\n    );\n\n    if (!splitInterpolation) {\n      // No expression, return a single text\n      return new i18n.Text(text, sourceSpan);\n    }\n\n    // Return a group of text + expressions\n    const nodes: i18n.Node[] = [];\n    const container = new i18n.Container(nodes, sourceSpan);\n    const {start: sDelimiter, end: eDelimiter} = this._interpolationConfig;\n\n    for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {\n      const expression = splitInterpolation.expressions[i];\n      const baseName = extractPlaceholderName(expression) || \"INTERPOLATION\";\n      const phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n\n      if (splitInterpolation.strings[i].length) {\n        // No need to add empty strings\n        nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));\n      }\n\n      nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));\n      this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n    }\n\n    // The last index contains no expression\n    const lastStringIdx = splitInterpolation.strings.length - 1;\n    if (splitInterpolation.strings[lastStringIdx].length) {\n      nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));\n    }\n    return container;\n  }\n}\n\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n","import * as html from \"../ast/ast\";\nimport * as i18n from \"../ast/i18n_ast\";\nimport {I18nError} from \"../ast/parse_util\";\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from \"../ast/interpolation_config\";\nimport {createI18nMessageFactory} from \"./i18n\";\nimport {Parser, ParseTreeResult} from \"../ast/parser\";\nimport {getHtmlTagDefinition} from \"../ast/html_tags\";\nimport {I18nMessagesById, PlaceholderMapper} from \"../serializers/serializer\";\nimport {MissingTranslationStrategy} from \"@angular/core\";\n\nconst _I18N_ATTR = \"i18n\";\n\nexport interface MessageMetadata {\n  meaning?: string;\n  description?: string;\n  id?: string;\n}\n\nexport class HtmlParser extends Parser {\n  constructor(private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    super(getHtmlTagDefinition);\n  }\n\n  parse(source: string, url: string, parseExpansionForms = false): ParseTreeResult {\n    return super.parse(source, url, parseExpansionForms, this.interpolationConfig);\n  }\n\n  /**\n   * Extract translatable messages from an html AST\n   */\n  extractMessages(nodes: html.Node[]): ExtractionResult {\n    const visitor = new Visitor([\"wrapper\"]);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.extract(wrapper, this.interpolationConfig);\n  }\n\n  mergeTranslations(\n    nodes: html.Node[],\n    translations: TranslationBundle,\n    params: {[key: string]: any},\n    metadata?: MessageMetadata,\n    implicitTags: string[] = []\n  ): ParseTreeResult {\n    const visitor = new Visitor(implicitTags);\n    // Construct a single fake root element\n    const wrapper = new html.Element(\"wrapper\", [], nodes, undefined!, undefined, undefined);\n    return visitor.merge(wrapper, translations, this.interpolationConfig, params, metadata);\n  }\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n    private i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    public digest: (m: i18n.Message) => string,\n    interpolationConfig: InterpolationConfig,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n    console?: Console\n  ) {\n    this.i18nToHtml = new I18nToHtmlVisitor(\n      i18nNodesByMsgId,\n      digest,\n      mapperFactory!,\n      missingTranslationStrategy,\n      interpolationConfig,\n      console\n    );\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n    content: string,\n    url: string,\n    digest: (message: i18n.Message) => string,\n    createNameMapper: (message: i18n.Message) => PlaceholderMapper | null,\n    loadFct: (content: string, url: string) => I18nMessagesById,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG\n  ): TranslationBundle {\n    const i18nNodesByMsgId = loadFct(content, url);\n    const digestFn = (m: i18n.Message) => digest(m);\n    const mapperFactory = (m: i18n.Message) => createNameMapper(m)!;\n    return new TranslationBundle(\n      i18nNodesByMsgId,\n      digestFn,\n      interpolationConfig,\n      missingTranslationStrategy,\n      mapperFactory,\n      console\n    );\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message, params): html.Node[] {\n    const htmlRes = this.i18nToHtml.convert(srcMsg, params);\n    if (htmlRes.errors.length) {\n      throw new Error(htmlRes.errors.join(\"\\n\"));\n    }\n\n    return htmlRes.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this.i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  private _srcMsg: i18n.Message;\n  private _contextStack: {msg: i18n.Message; mapper: (name: string) => string}[] = [];\n  private _errors: I18nError[] = [];\n  private _mapper: (name: string) => string;\n  private _params: {[key: string]: any};\n  private _paramKeys: string[];\n\n  constructor(\n    private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    private _digest: (m: i18n.Message) => string,\n    private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n    private _missingTranslationStrategy: MissingTranslationStrategy,\n    private _interpolationConfig?: InterpolationConfig,\n    private _console?: Console\n  ) {}\n\n  convert(srcMsg: i18n.Message, params: {[key: string]: any}): {nodes: html.Node[]; errors: I18nError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    this._params = params;\n    this._paramKeys = Object.keys(params);\n\n    // i18n to text\n    const text = this.convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const htmlParser = new HtmlParser().parse(text, url, true);\n\n    return {\n      nodes: htmlParser.rootNodes,\n      errors: [...this._errors, ...htmlParser.errors]\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map(n => n.visit(this)).join(\"\");\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression)\n      ? this._srcMsg.placeholders[icu.expression]\n      : icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(\" \")}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this.convertToValue(this._srcMsg.placeholders[phName]);\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this.convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return \"\";\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs)\n      .map(name => `${name}=\"${ph.attrs[name]}\"`)\n      .join(\" \");\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join(\"\");\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this.convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => (mapper ? mapper.toInternalName(name)! : name);\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        this._console.warn(`Missing translation for message \"${id}\"`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join(\"\");\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private convertToValue(placeholder: string): string {\n    const param = placeholder.replace(this._interpolationConfig.start, \"\").replace(this._interpolationConfig.end, \"\");\n    return this._paramKeys.indexOf(param) !== -1 ? this._params[param] : placeholder;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new I18nError(el.sourceSpan, msg));\n  }\n}\n\nenum VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass Visitor implements html.Visitor {\n  private depth: number;\n\n  // <el i18n>...</el>\n  private inI18nNode: boolean;\n  private inImplicitNode: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  private inI18nBlock: boolean;\n  private blockChildren: html.Node[] = [];\n  private blockStartDepth: number;\n\n  // {<icu message>}\n  private inIcu: boolean;\n\n  // set to void 0 when not in a section\n  private msgCountAtSectionStart: number | undefined;\n  private errors: I18nError[];\n  private mode: VisitorMode;\n\n  // VisitorMode.Extract only\n  private messages: i18n.Message[];\n\n  // VisitorMode.Merge only\n  private translations: TranslationBundle;\n  private createI18nMessage: (msg: html.Node[], meaning: string, description: string, id: string) => i18n.Message;\n  private metadata: MessageMetadata;\n  private params: {[key: string]: any};\n\n  constructor(private _implicitTags: string[] = []) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(node: html.Node, interpolationConfig: InterpolationConfig): ExtractionResult {\n    this.init(VisitorMode.Extract, interpolationConfig);\n\n    node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ExtractionResult(this.messages, this.errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n    node: html.Node,\n    translations: TranslationBundle,\n    interpolationConfig: InterpolationConfig,\n    params: {[key: string]: any},\n    metadata: MessageMetadata = {}\n  ): ParseTreeResult {\n    this.init(VisitorMode.Merge, interpolationConfig, params);\n    this.translations = translations;\n    this.metadata = metadata;\n\n    const translatedNode = node.visit(this, null);\n\n    if (this.inI18nBlock) {\n      this._reportError(node, \"Unclosed block\");\n    }\n\n    return new ParseTreeResult(translatedNode.children, this.errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.ExpansionCase(\n        icuCase.value,\n        expression,\n        icuCase.sourceSpan,\n        icuCase.valueSourceSpan,\n        icuCase.expSourceSpan\n      );\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this.mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this.inIcu;\n\n    if (!this.inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this.isInTranslatableSection) {\n        this.addMessage([icu]);\n      }\n      this.inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this.mode === VisitorMode.Merge) {\n      icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this.inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return;\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this.isInTranslatableSection) {\n      this.mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element | null {\n    this.mayBeAddBlockChildren(el);\n    this.depth++;\n    const wasInI18nNode = this.inI18nNode;\n    const wasInImplicitNode = this.inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = getI18nAttr(el);\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this.inIcu && !this.isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this.inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this.isInTranslatableSection && !this.inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this.inI18nNode = true;\n        const message = this.addMessage(el.children, this.metadata)!;\n        translatedChildNodes = this.translateMessage(el, message);\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) {\n          this.openTranslatableSection(el);\n        }\n        html.visitAll(this, el.children);\n        if (isTranslatable) {\n          this._closeTranslatableSection(el, el.children);\n        }\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(el, \"Could not mark an element as translatable inside a translatable section\");\n      }\n\n      if (this.mode === VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this.mode === VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this.isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this.depth--;\n    this.inI18nNode = wasInI18nNode;\n    this.inImplicitNode = wasInImplicitNode;\n\n    if (this.mode === VisitorMode.Merge) {\n      return new html.Element(el.name, [], childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error(\"unreachable code\");\n  }\n\n  private init(mode: VisitorMode, interpolationConfig: InterpolationConfig, params: {[key: string]: any} = {}): void {\n    this.mode = mode;\n    this.inI18nBlock = false;\n    this.inI18nNode = false;\n    this.depth = 0;\n    this.inIcu = false;\n    this.msgCountAtSectionStart = undefined;\n    this.errors = [];\n    this.messages = [];\n    this.inImplicitNode = false;\n    this.createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    this.params = params;\n  }\n\n  // add a translatable message\n  private addMessage(ast: html.Node[], {meaning = \"\", description = \"\", id = \"\"} = {}): i18n.Message | null {\n    if (\n      ast.length === 0 ||\n      (ast.length === 1 && ast[0] instanceof html.Attribute && !(ast[0] as html.Attribute).value)\n    ) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const message = this.createI18nMessage(ast, meaning, description, id);\n    this.messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this.mode === VisitorMode.Merge) {\n      const nodes = this.translations.get(message, this.params);\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(el, `Translation unavailable for message id=\"${this.translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private mayBeAddBlockChildren(node: html.Node): void {\n    if (this.inI18nBlock && !this.inIcu && this.depth === this.blockStartDepth) {\n      this.blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private openTranslatableSection(node: html.Node): void {\n    if (this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section start\");\n    } else {\n      this.msgCountAtSectionStart = this.messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get isInTranslatableSection(): boolean {\n    return this.msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this.isInTranslatableSection) {\n      this._reportError(node, \"Unexpected section end\");\n      return;\n    }\n\n    const startIndex = this.msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n      (count: number, n: html.Node): number => count + (n instanceof html.Comment ? 0 : 1),\n      0\n    );\n\n    if (significantChildren === 1) {\n      for (let i = this.messages.length - 1; i >= startIndex!; i--) {\n        const ast = this.messages[i].nodes;\n        if (!(ast.length === 1 && ast[0] instanceof i18n.Text)) {\n          this.messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this.msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this.errors.push(new I18nError(node.sourceSpan!, msg));\n  }\n}\n\nfunction getI18nAttr(p: html.Element): html.Attribute | null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n","import {\n  Inject,\n  Injectable,\n  InjectionToken,\n  LOCALE_ID,\n  MissingTranslationStrategy,\n  Optional,\n  TRANSLATIONS,\n  TRANSLATIONS_FORMAT\n} from \"@angular/core\";\nimport {xliffDigest, xliffLoadToI18n} from \"./serializers/xliff\";\nimport {xliff2Digest, xliff2LoadToI18n} from \"./serializers/xliff2\";\nimport {xtbDigest, xtbLoadToI18n, xtbMapper} from \"./serializers/xtb\";\nimport {HtmlParser, TranslationBundle} from \"./parser/html\";\nimport {I18nMessagesById, serializeNodes} from \"./serializers/serializer\";\nimport {Message} from \"./ast/i18n_ast\";\n\nexport declare interface I18n {\n  (def: string | I18nDef, params?: {[key: string]: any}): string;\n}\n\nexport interface I18nDef {\n  value: string;\n  id?: string;\n  meaning?: string;\n  description?: string;\n}\n\nexport const MISSING_TRANSLATION_STRATEGY = new InjectionToken<MissingTranslationStrategy>(\n  \"MissingTranslationStrategy\"\n);\n\n/**\n * A speculative polyfill to use i18n code translations\n */\n@Injectable()\nexport class I18n {\n  constructor(\n    @Inject(TRANSLATIONS_FORMAT) format: string,\n    @Inject(TRANSLATIONS) translations: string,\n    @Inject(LOCALE_ID) locale: string,\n    @Optional()\n    @Inject(MISSING_TRANSLATION_STRATEGY)\n    missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning\n  ) {\n    let loadFct: (content: string, url: string) => I18nMessagesById;\n    let digest: (message: Message) => string;\n    let createMapper = (message: Message) => null;\n    format = (format || \"xlf\").toLowerCase();\n    switch (format) {\n      case \"xtb\":\n        loadFct = xtbLoadToI18n;\n        digest = xtbDigest;\n        createMapper = xtbMapper;\n        break;\n      case \"xliff2\":\n      case \"xlf2\":\n        loadFct = xliff2LoadToI18n;\n        digest = xliff2Digest;\n        break;\n      case \"xliff\":\n      case \"xlf\":\n        loadFct = xliffLoadToI18n;\n        digest = xliffDigest;\n        break;\n      default:\n        throw new Error(`Unknown translations format ${format}`);\n    }\n    const htmlParser = new HtmlParser();\n\n    const translationsBundle = TranslationBundle.load(\n      translations,\n      \"i18n\",\n      digest,\n      createMapper,\n      loadFct,\n      missingTranslationStrategy\n    );\n\n    // todo use interpolation config\n    return (def: string | I18nDef, params: {[key: string]: any} = {}) => {\n      const content = typeof def === \"string\" ? def : def.value;\n      const metadata = {};\n      if (typeof def === \"object\") {\n        metadata[\"id\"] = def.id;\n        metadata[\"meaning\"] = def.meaning;\n        metadata[\"description\"] = def.description;\n      }\n      const htmlParserResult = htmlParser.parse(content, \"\", true);\n\n      if (htmlParserResult.errors.length) {\n        throw htmlParserResult.errors;\n      }\n\n      const mergedNodes = htmlParser.mergeTranslations(\n        htmlParserResult.rootNodes,\n        translationsBundle,\n        params,\n        metadata,\n        [\"wrapper\"]\n      );\n\n      return serializeNodes(mergedNodes.rootNodes, locale, params).join(\"\");\n    };\n  }\n}\n"],"names":["Text","tslib_1.__extends","chars.$EOF","chars.$LT","chars.$BANG","chars.$LBRACKET","chars.$MINUS","chars.$SLASH","chars.$RBRACE","chars.$LF","chars.$CR","chars.$AMPERSAND","chars.$HASH","chars.$x","chars.$X","chars.$SEMICOLON","chars.$RBRACKET","chars.$GT","chars.$COLON","chars.isAsciiLetter","chars.$EQ","chars.$SQ","chars.$DQ","chars.$LBRACE","chars.$COMMA","chars.isWhitespace","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$0","chars.$9","chars.isAsciiHexDigit","chars.isDigit","lex.tokenize","lex.TokenType","html.Comment","html.Expansion","lex.Token","html.ExpansionCase","html.Text","html.Element","html.Attribute","i18n.RecurseVisitor","serializeNodes","SerializerVisitor","ml.visitAll","i18n.Text","i18n.Placeholder","i18n.Container","i18n.Icu","_PLACEHOLDER_TAG","_SOURCE_TAG","_TARGET_TAG","_UNIT_TAG","XmlToI18n","Token","TokenType","chars.$SPACE","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$PLUS","chars.$STAR","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$BAR","chars.$NBSP","chars.$BACKSLASH","chars.$u","chars.$_","chars.$$","chars.$e","chars.$E","chars.$BT","chars.$n","chars.$f","chars.$FF","chars.$r","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","Parser","html.visitAll","i18n.Message","i18n.TagPlaceholder","i18n.IcuPlaceholder","Visitor"],"mappings":"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"}
