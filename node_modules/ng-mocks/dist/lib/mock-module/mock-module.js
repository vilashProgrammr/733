"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@angular/common");
var core_1 = require("@angular/core");
var common_2 = require("../common");
var reflect_1 = require("../common/reflect");
var mock_declaration_1 = require("../mock-declaration");
var cache = new Map();
var neverMockProvidedToken = [
    'InjectionToken Application Initializer',
];
var neverMockProvidedFunction = [
    'ApplicationInitStatus',
    'DomRendererFactory2',
    'RendererFactory2',
];
var mockProvider = function (provider) {
    var provide = typeof provider === 'object' && provider.provide ? provider.provide : provider;
    var multi = typeof provider === 'object' && provider.multi;
    if (typeof provide === 'object' && provide.ngMetadataName === 'InjectionToken'
        && neverMockProvidedToken.includes(provide.toString())) {
        return undefined;
    }
    if (typeof provide === 'function'
        && neverMockProvidedFunction.includes(provide.name)) {
        return undefined;
    }
    return {
        multi: multi,
        provide: provide,
        useValue: {},
    };
};
var flatten = function (values, result) {
    if (result === void 0) { result = []; }
    if (Array.isArray(values)) {
        values.forEach(function (value) { return flatten(value, result); });
    }
    else {
        result.push(values);
    }
    return result;
};
var isModule = function (object) {
    var annotations = reflect_1.jitReflector.annotations(object);
    var ngMetadataNames = annotations.map(function (annotation) { return annotation.__proto__.ngMetadataName; });
    return ngMetadataNames.indexOf('NgModule') !== -1;
};
var isModuleWithProviders = function (object) { return typeof object.ngModule !== 'undefined'
    && isModule(object.ngModule); };
function MockModule(module) {
    var ngModule;
    var ngModuleProviders;
    var moduleMockPointer;
    if (isModuleWithProviders(module)) {
        ngModule = module.ngModule;
        if (module.providers) {
            ngModuleProviders = module.providers;
        }
    }
    else {
        ngModule = module;
    }
    if (NEVER_MOCK.includes(ngModule)) {
        return module;
    }
    var cacheHit = cache.get(ngModule);
    if (cacheHit) {
        moduleMockPointer = cacheHit;
    }
    else {
        var ModuleMock = (function () {
            function ModuleMock() {
            }
            ModuleMock = __decorate([
                core_1.NgModule(MockIt(ngModule)),
                common_2.MockOf(ngModule)
            ], ModuleMock);
            return ModuleMock;
        }());
        moduleMockPointer = ModuleMock;
        cache.set(ngModule, moduleMockPointer);
    }
    if (ngModuleProviders) {
        return {
            ngModule: moduleMockPointer,
            providers: flatten(ngModuleProviders).map(mockProvider)
                .filter(function (provider) { return !!provider; }),
        };
    }
    return moduleMockPointer;
}
exports.MockModule = MockModule;
var NEVER_MOCK = [common_1.CommonModule];
function MockIt(module) {
    var mockedModule = {};
    var _a = reflect_1.ngModuleResolver.resolve(module), _b = _a.declarations, declarations = _b === void 0 ? [] : _b, _c = _a.entryComponents, entryComponents = _c === void 0 ? [] : _c, _d = _a.imports, imports = _d === void 0 ? [] : _d, _e = _a.providers, providers = _e === void 0 ? [] : _e;
    if (imports.length) {
        mockedModule.imports = flatten(imports).map(function (instance) {
            if (isModule(instance)) {
                return MockModule(instance);
            }
            if (isModuleWithProviders(instance)) {
                return MockModule(instance);
            }
            return mock_declaration_1.MockDeclaration(instance);
        });
    }
    if (declarations.length) {
        mockedModule.declarations = flatten(declarations).map(mock_declaration_1.MockDeclaration);
    }
    if (entryComponents.length) {
        mockedModule.entryComponents = flatten(entryComponents).map(mock_declaration_1.MockDeclaration);
    }
    if (providers.length) {
        mockedModule.providers = flatten(providers).map(mockProvider)
            .filter(function (provider) { return !!provider; });
    }
    if (mockedModule.declarations || mockedModule.imports) {
        mockedModule.exports = [];
        if (mockedModule.imports) {
            var onlyModules = mockedModule.imports.map(function (instance) {
                if (isModule(instance)) {
                    return instance;
                }
                if (isModuleWithProviders(instance)) {
                    return instance.ngModule;
                }
                return undefined;
            }).filter(function (instance) { return instance; });
            mockedModule.exports = mockedModule.exports.concat(onlyModules);
        }
        if (mockedModule.declarations) {
            mockedModule.exports = mockedModule.exports.concat(mockedModule.declarations);
        }
    }
    return mockedModule;
}
//# sourceMappingURL=mock-module.js.map