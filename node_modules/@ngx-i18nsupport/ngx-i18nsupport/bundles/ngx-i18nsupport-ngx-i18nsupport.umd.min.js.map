{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@ngx-i18nsupport/ngx-i18nsupport/lib/xliffmerge.module.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/common/util.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/common/writer-to-string.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/common/command-output.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/xliff-merge-error.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/common/file-util.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/ngx-translate-extraction-pattern.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/ngx-translate-extractor.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/xliff-merge-parameters.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/version.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/xml-reader.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/translation-messages-file-reader.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/autotranslate/auto-translate-service.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/autotranslate/auto-translate-result.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/autotranslate/auto-translate-summary-report.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/autotranslate/xliff-merge-auto-translate-service.ts","ng://@ngx-i18nsupport/ngx-i18nsupport/xliffmerge/xliff-merge.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","__read","n","r","e","ar","push","error","__spread","arguments","concat","XliffmergeModule","NgModule","args","imports","declarations","exports","isNullOrUndefined","undefined","isArray","WriterToString","_this","_super","resultString","tslib_1.__extends","_write","chunk","encoding","callback","chunkString","Buffer","toString","alloc","writtenData","Writable","ERROR","WARN","INFO","DEBUG","CommandOutput","stdout","_quiet","_verbose","outputStream","process","setVerbose","setQuiet","verbose","quiet","msg","params","_i","log","LogLevel","warn","info","debug","level","isOutputEnabled","coloredMessage","chalk","red","magenta","gray","outMsg","format","apply","write","quietEnabled","verboseEnabled","XliffMergeError","Error","FileUtil","exists","filename","fs.existsSync","read","fs.readFileSync","replaceContent","newContent","fs.writeFileSync","copy","srcFile","destFile","buff","fdr","fs.openSync","fdw","bytesRead","pos","fs.readSync","fs.writeSync","fs.closeSync","deleteFolderRecursive","path","fs.readdirSync","forEach","file","curPath","fs.lstatSync","isDirectory","fs.unlinkSync","fs.rmdirSync","deleteFolderContentRecursive","deleteFile","NgxTranslateExtractionPattern","extractionPatternString","parts","split","_matchExplicitId","_descriptionPatterns","part","errorString","checkValidDescriptionPattern","isExplicitIdMatched","id","isDescriptionMatched","description","indexOf","descriptionPattern","test","NgxTranslateExtractor","messagesFile","extractionPattern","checkPattern","message","extract","outputFile","extractTo","translations","toNgxTranslations","keys","JSON","stringify","result","forEachTransUnit","tu","ngxId","ngxTranslateIdFromTU","messagetext","targetContentNormalized","asDisplayString","NORMALIZATION_FORMAT_NGXTRANSLATE","isExplicitlySetId","meaning","msgList","translationObject","putInTranslationObject","firstPartOfId","restOfId","indexOfDot","substring","object","DefaultExtractionPattern","PROFILE_CANDIDATES","XliffMergeParameters","errorsFound","warningsFound","createFromOptions","options","profileContent","parameters","configure","readProfileCandidate","profilePath","content","err","parsedContent","parse","xliffmergeOptions","readProfile","validProfile","initializeFromConfig","languages","_languages","_defaultLanguage","checkParameters","PROFILE_CANDIDATES_1","tslib_1.__values","PROFILE_CANDIDATES_1_1","configfilename","profile","usedProfilePath","srcDir","adjustPathToProfilePath","genDir","apikeyfile","pathToAdjust","isAbsolute","join","dirname","replace","allowIdChange","_allowIdChange","defaultLanguage","_srcDir","angularCompilerOptions","_genDir","i18nBaseFile","_i18nBaseFile","i18nFile","_i18nFile","i18nFormat","_i18nFormat","_encoding","removeUnusedIds","_removeUnusedIds","supportNgxTranslate","_supportNgxTranslate","ngxTranslateExtractionPattern","_ngxTranslateExtractionPattern","useSourceAsTarget","_useSourceAsTarget","targetPraefix","_targetPraefix","targetSuffix","_targetSuffix","autotranslate","_autotranslate","beautifyOutput","_beautifyOutput","preserveOrder","_preserveOrder","apikey","_apikey","_apikeyfile","stats","checkLanguageSyntax","lang","fs.statSync","fs.accessSync","fs.constants","R_OK","autotranslatedLanguages","checkResult","showAllParameters","commandOutput","_b","_c","language","generatedI18nFile","suffixForGeneratedI18nFile","generatedNgxTranslateFile","autotranslateLanguage","slice","apikeyPath","env","API_KEY_FILE","pkg","require","path.resolve","__dirname","VERSION","version","XmlReader","readXmlFileContent","DEFAULT_ENCODING","foundEncoding","encodingFromXml","xmlString","index","endIndex","TranslationMessagesFileReader","fromFile","optionalMasterFilePath","xmlContent","optionalMaster","masterFileContent","TranslationMessagesFileFactory","fromFileContent","fromUnknownFormatFile","fromUnknownFormatFileContent","masterXmlContent","save","editedContent","AutoTranslateService","apiKey","_request","request","_apiKey","_rootUrl","stripRegioncode","langLower","toLowerCase","c","charAt","setApiKey","translateMultipleStrings","messages","from","to","of","throwError","allRequests","splitMessagesToGoogleLimit","map","partialMessages","limitedTranslateMultipleStrings","forkJoin","pipe","allTranslations","all","currentPackage","packageSize","realUrl","url","body","q","target","source","json","post","data","code","translation","translatedText","uri","_call","assign","method","Observable","observer","response","complete","AutoTranslateResult","_success","_details","success","AutoTranslateSummaryReport","_from","_to","_total","_ignored","_failed","setError","total","_error","setIgnored","ignored","addSingleResult","merge","anotherSummary","failed","XliffMergeAutoTranslateService","autoTranslateService","autoTranslate","languageSpecificMessagesFile","doAutoTranslateNonICUMessages","doAutoTranslateICUMessages","summaries","summary","allUntranslatedTUs","allUntranslated","targetState","STATE_NEW","allTranslatable","filter","sourceContentNormalized","getICUMessage","allMessages","encodedTranslation","entityDecoderLib.decode","translationText","autoTranslateNonICUUnit","catchError","failSummary","doAutoTranslateICUMessage","categories","getCategories","find","category","getMessageNormalized","icuTranslation","getCategory","autoTranslateICUUnit","translatedMessage","autoTranslateUnit","translate","translateICUMessage","errors","validate","warnings","validateWarnings","XliffMerge","main","argv","parseArgs","run","exit","arg","console","showUsage","instance","callbackFunction","errorFunction","runAsync","subscribe","retcode","_d","_e","_f","readMaster","executionForAllLanguages","processLanguage","retcodes","totalRetcode","master","warning","count","numberOfTransUnits","missingIdCount","numberOfTransUnitsWithMissingId","sourceLang","sourceLanguage","setSourceLanguage","currentFilename","filenameString","languageXliffFile","mergeMasterTo","createUntranslatedXliff","translationFormat","languageXliffFilePath","isDefaultLang","setNewTransUnitTargetPraefix","setNewTransUnitTargetSuffix","createTranslationFileForLang","FORMAT_XMB","FORMAT_XTB","newCount","correctSourceContentCount","correctSourceRefCount","correctDescriptionOrMeaningCount","idChangedCount","lastProcessedUnit","masterTransUnit","transUnit","transUnitWithId","supportsSetSourceContent","areSourcesNearlyEqual","setSourceContent","sourceContent","setTargetState","STATE_FINAL","STATE_TRANSLATED","supportsSetSourceReferences","areSourceReferencesEqual","sourceReferences","setSourceReferences","supportsSetDescriptionAndMeaning","changed","setDescription","setMeaning","newUnit","processChangedIdUnit","importNewTransUnit","removeCount","removeTransUnitWithId","changedTransUnit","languageTransUnit","mergedTransUnit","translatedContent","targetContent","tu1","tu2","tu1Normalized","tu2Normalized","isICUMessage","asNativeString","trim","containsICUMessageRef","NORMALIZATION_FORMAT_DEFAULT","ref1","ref2","set1","Set","ref","add","sourcefile","linenumber","set2","size","match","has","autotranslateEnabled"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\n// not used, only there to make ng-packagr happy\r\n@NgModule({\r\n    imports: [\r\n    ],\r\n    declarations: [],\r\n    exports: []\r\n})\r\nexport class XliffmergeModule { }\r\n","/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nexport function isNullOrUndefined(value: any) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n/**\r\n * Replaces node isString.\r\n */\r\nexport function isString(value: any) {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nexport function isBoolean(value: any) {\r\n    return typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nexport function isNumber(value: any) {\r\n    return typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Replaces node isArray.\r\n */\r\nexport function isArray(value: any) {\r\n    return Array.isArray(value);\r\n}\r\n","import {Writable} from 'stream';\r\nimport {isString} from './util';\r\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\n\r\nexport class WriterToString extends Writable {\r\n\r\n    private resultString: string;\r\n\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n\r\n    public _write(chunk: any, encoding: string, callback: Function): void {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        } else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        } else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    public writtenData(): string {\r\n        return this.resultString;\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\n\r\nimport chalk from 'chalk';\r\nimport WritableStream = NodeJS.WritableStream;\r\nimport {format} from 'util';\r\n\r\nenum LogLevel {\r\n    'ERROR',\r\n    'WARN',\r\n    'INFO',\r\n    'DEBUG'\r\n}\r\n\r\nexport class CommandOutput {\r\n\r\n    /**\r\n     * verbose enables output of everything.\r\n     */\r\n    public _verbose: boolean;\r\n\r\n    /**\r\n     * quiet disables output of everything but errors.\r\n     */\r\n    public _quiet: boolean;\r\n\r\n    private outputStream: WritableStream;\r\n\r\n    constructor(stdout?: WritableStream) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        } else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n\r\n    public setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n\r\n    public setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    public verbose(): boolean {\r\n        return this._verbose;\r\n    }\r\n\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    public quiet(): boolean {\r\n        return this._quiet;\r\n    }\r\n\r\n    public error(msg, ...params: any[]) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n\r\n    public warn(msg, ...params: any[]) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n\r\n    public info(msg, ...params: any[]) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n\r\n    public debug(msg, ...params: any[]) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n\r\n    private log(level: LogLevel, msg, params: any[]) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n\r\n    private isOutputEnabled(level: LogLevel): boolean {\r\n        let quietEnabled, verboseEnabled: boolean;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        } else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true;    // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n */\r\n\r\nexport class XliffMergeError extends Error {\r\n\r\n    constructor(msg: string) {\r\n        super(msg);\r\n\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\r\n","import * as fs from 'fs';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\n\r\nexport class FileUtil {\r\n\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    public static exists(filename: string) {\r\n        return fs.existsSync(filename);\r\n    }\r\n\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    public static read(filename: string, encoding: string) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    public static replaceContent(filename: string, newContent: string, encoding: string) {\r\n        fs.writeFileSync(filename, newContent, {encoding: encoding});\r\n    }\r\n\r\n    public static copy(srcFile: string, destFile: string) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    public static deleteFolderRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path) ) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function(file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    public static deleteFolderContentRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path) ) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function(file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    public static deleteFile(path: string) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\r\n","/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nexport class NgxTranslateExtractionPattern {\r\n\r\n    private _matchExplicitId: boolean;\r\n    private _descriptionPatterns: string[];\r\n\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(private extractionPatternString: string) {\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            } else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    public isExplicitIdMatched(id: string): boolean {\r\n        return id && this._matchExplicitId;\r\n    }\r\n\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    public isDescriptionMatched(description: string): boolean {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n\r\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        } else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\r\n","import {ITranslationMessagesFile, ITransUnit, NORMALIZATION_FORMAT_NGXTRANSLATE} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {NgxTranslateExtractionPattern} from './ngx-translate-extraction-pattern';\r\n/**\r\n * Created by roobm on 15.03.2017.\r\n * A tool for extracting messages in ngx-translate format.\r\n * Generates a json-file to be used with ngx-translate.\r\n */\r\n\r\n/**\r\n * The interface used for translations in ngx-translate.\r\n * A hash that contains either the translation or another hash.\r\n */\r\ninterface NgxTranslations {\r\n    [id: string]: NgxTranslations | string;\r\n}\r\n\r\n/**\r\n * internal,\r\n * a message with id (a dot-separated string).\r\n */\r\ninterface NgxMessage {\r\n    id: string; // dot separated name, e.g. \"myapp.service1.message1\"\r\n    message: string; // the message, placeholder are in {{n}} syntax, e.g. \"a test with value: {{0}}\r\n}\r\n\r\nexport class NgxTranslateExtractor {\r\n\r\n    public static DefaultExtractionPattern = '@@|ngx-translate';\r\n    private extractionPattern: NgxTranslateExtractionPattern;\r\n\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    public static checkPattern(extractionPatternString: string): string {\r\n        try {\r\n          if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n              return null;\r\n          }\r\n        } catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static extract(messagesFile: ITranslationMessagesFile, extractionPattern: string, outputFile: string) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n\r\n    constructor(private messagesFile: ITranslationMessagesFile, extractionPatternString: string) {\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    public extractTo(outputFile: string) {\r\n        const translations: NgxTranslations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'UTF-8');\r\n        } else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    private extract(): NgxMessage[] {\r\n        const result: NgxMessage[] = [];\r\n        this.messagesFile.forEachTransUnit((tu: ITransUnit) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({id: ngxId, message: messagetext});\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    private ngxTranslateIdFromTU(tu: ITransUnit): string {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    private isExplicitlySetId(id: string): boolean {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    private toNgxTranslations(msgList: NgxMessage[]): NgxTranslations {\r\n        const translationObject: NgxTranslations = {};\r\n        msgList.forEach((msg: NgxMessage) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    private putInTranslationObject(translationObject: NgxTranslations, msg: NgxMessage) {\r\n        let firstPartOfId: string;\r\n        let restOfId: string;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        } else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        } else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(<NgxTranslations> object, {id: restOfId, message: msg.message});\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {Stats} from 'fs';\r\nimport {CommandOutput} from '../common/command-output';\r\nimport {format} from 'util';\r\nimport {isArray, isNullOrUndefined} from '../common/util';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {dirname, isAbsolute, join, normalize} from 'path';\r\n\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\n\r\nexport class XliffMergeParameters {\r\n\r\n    private usedProfilePath: string;\r\n    private _quiet: boolean;\r\n    private _verbose: boolean;\r\n    private _allowIdChange: boolean;\r\n    private _defaultLanguage: string;\r\n    private _srcDir: string;\r\n    private _i18nBaseFile: string;\r\n    private _i18nFile: string;\r\n    private _i18nFormat: string;\r\n    private _encoding: string;\r\n    private _genDir: string;\r\n    private _languages: string[];\r\n    private _removeUnusedIds: boolean;\r\n    private _supportNgxTranslate: boolean;\r\n    private _ngxTranslateExtractionPattern: string;\r\n    private _useSourceAsTarget: boolean;\r\n    private _targetPraefix: string;\r\n    private _targetSuffix: string;\r\n    private _beautifyOutput: boolean;\r\n    private _preserveOrder: boolean;\r\n    private _autotranslate: boolean|string[];\r\n    private _apikey: string;\r\n    private _apikeyfile: string;\r\n\r\n    public errorsFound: XliffMergeError[];\r\n    public warningsFound: string[];\r\n\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    public static createFromOptions(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n\r\n    private constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    private static readProfileCandidate(profilePath: string): IConfigFile {\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'UTF-8');\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent: IConfigFile = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    private configure(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile: boolean = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    private readProfile(options: ProgramOptions): IConfigFile {\r\n        const profilePath: string = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'UTF-8');\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent: IConfigFile = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n\r\n    private adjustPathToProfilePath(profilePath: string, pathToAdjust: string | undefined): string | undefined {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private initializeFromConfig(profileContent: IConfigFile) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        } else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    private checkParameters(): void {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats: Stats;\r\n        let err: any;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n     }\r\n\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    private checkLanguageSyntax(lang: string) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n\r\n    public allowIdChange(): boolean {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n\r\n    public verbose(): boolean {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n\r\n    public quiet(): boolean {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    public showAllParameters(commandOutput: CommandOutput): void {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    public defaultLanguage(): string {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    public languages(): string[] {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    public srcDir(): string {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    public i18nBaseFile(): string {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    public i18nFile(): string {\r\n        return join(this.srcDir(),\r\n            (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())\r\n        ).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    public i18nFormat(): string {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private suffixForGeneratedI18nFile(): string {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding ? this._encoding : 'UTF-8';\r\n    }\r\n\r\n     /**\r\n      * Output-Directory, where the output is written to.\r\n      * Default is <srcDir>.\r\n     */\r\n    public genDir(): string {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n\r\n    public removeUnusedIds(): boolean {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n\r\n    public supportNgxTranslate(): boolean {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n\r\n    public ngxTranslateExtractionPattern(): string {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    public useSourceAsTarget(): boolean {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetPraefix(): string {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetSuffix(): string {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    public beautifyOutput(): boolean {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    public preserveOrder(): boolean {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    public autotranslate(): boolean {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate).length > 0;\r\n        }\r\n        return <boolean> this._autotranslate;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    public autotranslateLanguage(lang: string): boolean {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    public autotranslatedLanguages(): string[] {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate);\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    public apikey(): string {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        } else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                } else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    public apikeyfile(): string {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        } else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nimport * as path from 'path';\r\n\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n} catch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    } catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\n\r\nexport const VERSION = (pkg ? pkg.version : 'unknown');\r\n","import {FileUtil} from '../common/file-util';\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\n\r\nexport class XmlReader {\r\n    static DEFAULT_ENCODING = 'UTF-8';\r\n\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    public static readXmlFileContent(path: string, encoding?: string): {content: string, encoding: string} {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING;\r\n        }\r\n        let content: string = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content);\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    private static encodingFromXml(xmlString: string): string {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n\r\n}\r\n\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {TranslationMessagesFileFactory, ITranslationMessagesFile} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {XmlReader} from './xml-reader';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nexport class TranslationMessagesFileReader {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromFile(i18nFormat: string,\r\n                           path: string,\r\n                           encoding: string,\r\n                           optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromUnknownFormatFile(path: string,\r\n                                        encoding: string,\r\n                                        optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    private static masterFileContent(optionalMasterFilePath: string, encoding: string)\r\n        : {xmlContent: string, path: string, encoding: string} {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public static save(messagesFile: ITranslationMessagesFile, beautifyOutput?: boolean) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());\r\n    }\r\n}\r\n\r\n","import {format} from 'util';\r\nimport * as request from 'request';\r\nimport {Observable} from 'rxjs';\r\nimport {of, forkJoin, throwError} from 'rxjs';\r\nimport {map} from 'rxjs/operators';\r\n\r\n/**\r\n * Created by roobm on 03.07.2017.\r\n * Low Level Service to call Google Translate.\r\n */\r\n\r\n/**\r\n * Types form google translate api.\r\n */\r\n\r\ninterface GetSupportedLanguagesRequest {\r\n    target: string; // The language to use to return localized, human readable names of supported\\nlanguages.\r\n}\r\n\r\ninterface LanguagesResource {\r\n    language: string; // code of the language\r\n    name: string; // human readable name (in target language)\r\n}\r\n\r\ninterface LanguagesListResponse {\r\n    languages: LanguagesResource[];\r\n}\r\n\r\ninterface TranslateTextRequest {\r\n    q: string[];  // The input texts to translate\r\n    target: string; // The language to use for translation of the input text\r\n    source: string; // The language of the source text\r\n    format?: string; // \"html\" (default) or \"text\"\r\n    model?: string; // see public documentation\r\n}\r\n\r\ninterface TranslationsResource {\r\n    detectedSourceLanguage?: string;\r\n    model?: string;\r\n    translatedText: string;\r\n}\r\n\r\ninterface TranslationsListResponse {\r\n    translations: TranslationsResource[];\r\n}\r\n\r\ninterface InternalRequestResponse {\r\n    response: request.RequestResponse;\r\n    body: any;\r\n}\r\n\r\nconst MAX_SEGMENTS = 128;\r\n\r\nexport class AutoTranslateService {\r\n\r\n    private _request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;\r\n    _rootUrl: string;\r\n    _apiKey: string;\r\n\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    public static stripRegioncode(lang: string): string {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n\r\n    constructor(apiKey: string) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    public setApiKey(apikey: string) {\r\n        this._apiKey = apikey;\r\n    }\r\n\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    public translateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests: Observable<string[]>[] = this.splitMessagesToGoogleLimit(messages).map((partialMessages: string[]) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(\r\n            map((allTranslations: string[][]) => {\r\n                let all = [];\r\n                for (let i = 0; i < allTranslations.length; i++) {\r\n                    all = all.concat(allTranslations[i]);\r\n                }\r\n                return all;\r\n        }));\r\n    }\r\n\r\n    private splitMessagesToGoogleLimit(messages: string[]): string[][] {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    private limitedTranslateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest: TranslateTextRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n//            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(\r\n            map((data) => {\r\n            const body: any = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                } else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation: TranslationsResource) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> this._call.apply(this, [].concat('post', <string> uri,\r\n            <request.CoreOptions> Object.assign({}, options || {})));\r\n    }\r\n\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    private _call(method: string, uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(<string> uri, <request.CoreOptions> Object.assign({}, options || {}),\r\n                <RequestCallback>(error: any, response: request.RequestResponse, body: any) => {\r\n                    if (error) {\r\n                        return observer.error(error);\r\n                    }\r\n\r\n                    observer.next(<InternalRequestResponse> Object.assign({}, {\r\n                        response: <request.RequestResponse> response,\r\n                        body: <any> body\r\n                    }));\r\n                    observer.complete();\r\n                });\r\n\r\n            // _call request method\r\n            try {\r\n                this._request[<string> method].apply(\r\n                    <request.RequestAPI<request.Request,\r\n                    request.CoreOptions,\r\n                    request.RequiredUriUrl>> this._request,\r\n                    params);\r\n            } catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateResult {\r\n\r\n  constructor(private _success: boolean, private _details: string) {\r\n\r\n  }\r\n\r\n  public success(): boolean {\r\n    return this._success;\r\n  }\r\n}\r\n","import {AutoTranslateResult} from './auto-translate-result';\r\nimport {format} from 'util';\r\nimport {ITransUnit} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\n\r\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateSummaryReport {\r\n\r\n  private _error: string;\r\n  private _from: string;\r\n  private _to: string;\r\n  private _total: number;\r\n  private _ignored: number;\r\n  private _success: number;\r\n  private _failed: number;\r\n\r\n  constructor(from: string, to: string) {\r\n    this._from = from;\r\n    this._to = to;\r\n    this._total = 0;\r\n    this._ignored = 0;\r\n    this._success = 0;\r\n    this._failed = 0;\r\n  }\r\n\r\n  /**\r\n   * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n   * @param error error\r\n   * @param total total\r\n   */\r\n  public setError(error: string, total: number) {\r\n    this._error = error;\r\n    this._total = total;\r\n    this._failed = total;\r\n  }\r\n\r\n  public error(): string {\r\n    return this._error;\r\n  }\r\n\r\n  public setIgnored(ignored: number) {\r\n    this._total += ignored;\r\n    this._ignored = ignored;\r\n  }\r\n\r\n  /**\r\n   * Add a single result to the summary.\r\n   * @param tu tu\r\n   * @param result result\r\n   */\r\n  public addSingleResult(tu: ITransUnit, result: AutoTranslateResult) {\r\n    this._total++;\r\n    if (result.success()) {\r\n      this._success++;\r\n    } else {\r\n      this._failed++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge another summary into this one.\r\n   * @param anotherSummary anotherSummary\r\n   */\r\n  public merge(anotherSummary: AutoTranslateSummaryReport) {\r\n    if (!this._error) {\r\n      this._error = anotherSummary._error;\r\n    }\r\n    this._total += anotherSummary.total();\r\n    this._ignored += anotherSummary.ignored();\r\n    this._success += anotherSummary.success();\r\n    this._failed += anotherSummary.failed();\r\n  }\r\n\r\n  public total(): number {\r\n    return this._total;\r\n  }\r\n\r\n  public ignored(): number {\r\n    return this._ignored;\r\n  }\r\n\r\n  public success(): number {\r\n    return this._success;\r\n  }\r\n\r\n  public failed(): number {\r\n    return this._failed;\r\n  }\r\n\r\n  /**\r\n   * Human readable version of report\r\n   */\r\n  public content(): string {\r\n    let result;\r\n    if (this._error) {\r\n      result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n    } else {\r\n      result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s',\r\n          this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import {isNullOrUndefined} from '../common/util';\r\nimport {Observable, forkJoin, of} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport * as entityDecoderLib from 'he';\r\nimport {\r\n    IICUMessage, IICUMessageTranslation, INormalizedMessage, ITranslationMessagesFile, ITransUnit,\r\n    STATE_NEW\r\n} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {AutoTranslateService} from './auto-translate-service';\r\nimport {AutoTranslateResult} from './auto-translate-result';\r\nimport {AutoTranslateSummaryReport} from './auto-translate-summary-report';\r\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\n\r\nexport class XliffMergeAutoTranslateService {\r\n\r\n    private autoTranslateService: AutoTranslateService;\r\n\r\n    constructor(apikey: string) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    public autoTranslate(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)])\r\n            .pipe(\r\n                map((summaries: AutoTranslateSummaryReport[]) => {\r\n                    const summary = summaries[0];\r\n                    for (let i = 1; i < summaries.length; i++) {\r\n                        summary.merge(summaries[i]);\r\n                    }\r\n                    return summary;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    private allUntranslatedTUs(languageSpecificMessagesFile: ITranslationMessagesFile): ITransUnit[] {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated: ITransUnit[] = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n\r\n    private doAutoTranslateNonICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages: string[] = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                const summary = new AutoTranslateSummaryReport(from, to);\r\n                summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n                for (let i = 0; i < translations.length; i++) {\r\n                    const tu = allTranslatable[i];\r\n                    const translationText = translations[i];\r\n                    const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                    summary.addSingleResult(tu, result);\r\n                }\r\n                return summary;\r\n                }),\r\n                catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private doAutoTranslateICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport>[] {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    private doAutoTranslateICUMessage(from: string, to: string, tu: ITransUnit): Observable<AutoTranslateSummaryReport> {\r\n        const icuMessage: IICUMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages: string[] = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                    const summary = new AutoTranslateSummaryReport(from, to);\r\n                    const icuTranslation: IICUMessageTranslation = {};\r\n                    for (let i = 0; i < translations.length; i++) {\r\n                        icuTranslation[categories[i].getCategory()] = translations[i];\r\n                    }\r\n                    const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n                    summary.addSingleResult(tu, result);\r\n                    return summary;\r\n                }), catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private autoTranslateNonICUUnit(tu: ITransUnit, translatedMessage: string): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n\r\n    private autoTranslateICUUnit(tu: ITransUnit, translation: IICUMessageTranslation): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n\r\n    private autoTranslateUnit(tu: ITransUnit, translatedMessage: INormalizedMessage): AutoTranslateResult {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        } else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        } else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\r\n","import {CommandOutput} from '../common/command-output';\r\nimport {XliffMergeParameters} from './xliff-merge-parameters';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {VERSION} from './version';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {ITranslationMessagesFile, ITransUnit,\r\n    FORMAT_XMB, FORMAT_XTB,\r\n    NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {TranslationMessagesFileReader} from './translation-messages-file-reader';\r\nimport {Observable, of, forkJoin} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport {XliffMergeAutoTranslateService} from '../autotranslate/xliff-merge-auto-translate-service';\r\nimport {AutoTranslateSummaryReport} from '../autotranslate/auto-translate-summary-report';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\n\r\nexport class XliffMerge {\r\n\r\n    private readonly commandOutput: CommandOutput;\r\n\r\n    private readonly options: ProgramOptions;\r\n\r\n    private parameters: XliffMergeParameters;\r\n\r\n    /**\r\n     * The read master xlf file.\r\n     */\r\n    private master: ITranslationMessagesFile; // XliffFile or Xliff2File or XmbFile\r\n\r\n    private autoTranslateService: XliffMergeAutoTranslateService;\r\n\r\n    static main(argv: string[]) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n\r\n    static parseArgs(argv: string[]): ProgramOptions {\r\n        const options: ProgramOptions = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            } else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            } else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                } else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            } else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            } else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            } else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            } else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    public static createFromOptions(commandOutput: CommandOutput, options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n\r\n    constructor(commandOutput: CommandOutput, options: ProgramOptions) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    public run(callbackFunction?: ((retcode: number) => any), errorFunction?: ((error: any) => any)) {\r\n        this.runAsync()\r\n            .subscribe((retcode: number) => {\r\n                if (!isNullOrUndefined(callbackFunction)) {\r\n                    callbackFunction(retcode);\r\n                }\r\n            }, (error) => {\r\n                if (!isNullOrUndefined(errorFunction)) {\r\n                    errorFunction(error);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    public runAsync(): Observable<number> {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages: Observable<number>[] = [];\r\n        this.parameters.languages().forEach((lang: string) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(\r\n            map((retcodes: number[]) => this.totalRetcode(retcodes)));\r\n    }\r\n\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    private totalRetcode(retcodes: number[]): number {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    public warnings(): string[] {\r\n        return this.parameters.warningsFound;\r\n    }\r\n\r\n    private readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(\r\n                this.parameters.i18nFormat(),\r\n                this.parameters.i18nFile(),\r\n                this.parameters.encoding());\r\n            this.master.warnings().forEach((warning: string) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang: string = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn(\r\n                    'master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)',\r\n                    sourceLang,\r\n                    this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        } catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            } else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    private processLanguage(lang: string): Observable<number> {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result: Observable<void>;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        } else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n                if (this.parameters.supportNgxTranslate()) {\r\n                    const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n                        TranslationMessagesFileReader.fromFile(\r\n                            this.translationFormat(this.parameters.i18nFormat()),\r\n                            languageXliffFile,\r\n                            this.parameters.encoding(),\r\n                            this.master.filename());\r\n                    NgxTranslateExtractor.extract(\r\n                        languageSpecificMessagesFile,\r\n                        this.parameters.ngxTranslateExtractionPattern(),\r\n                        this.parameters.generatedNgxTranslateFile(lang));\r\n                }\r\n                return 0;\r\n            }), catchError((err) => {\r\n                if (err instanceof XliffMergeError) {\r\n                    this.commandOutput.error(err.message);\r\n                    return of(-1);\r\n                } else {\r\n                    // unhandled\r\n                    const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                    this.commandOutput.error(filenameString + 'oops ' + err);\r\n                    throw err;\r\n                }\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    private createUntranslatedXliff(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(\r\n            map((/* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    private translationFormat(i18nFormat: string): string {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        } else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    private mergeMasterTo(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            TranslationMessagesFileReader.fromFile(\r\n                this.translationFormat(this.parameters.i18nFormat()),\r\n                languageXliffFilePath,\r\n                this.parameters.encoding());\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit: ITransUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit: ITransUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                } else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n                        masterTransUnit,\r\n                        isDefaultLang,\r\n                        this.parameters.useSourceAsTarget(),\r\n                        (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            } else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    } else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn(\r\n                'transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            } else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        } else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                    // write it to file\r\n                    TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                    this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    if (newCount > 0 && !isDefaultLang) {\r\n                        this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    }\r\n                    return null;\r\n                }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    private processChangedIdUnit(\r\n        masterTransUnit: ITransUnit,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile,\r\n        lastProcessedUnit: ITransUnit): ITransUnit {\r\n\r\n        let changedTransUnit: ITransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n             if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                 changedTransUnit = languageTransUnit;\r\n             }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n            masterTransUnit,\r\n            false,\r\n            false,\r\n            (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    private areSourcesNearlyEqual(tu1: ITransUnit, tu2: ITransUnit): boolean {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n\r\n    private areSourceReferencesEqual(\r\n        ref1: {sourcefile: string; linenumber: number; }[],\r\n        ref2: {sourcefile: string; linenumber: number; }[]): boolean {\r\n\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1: Set<string> = new Set<string>();\r\n        ref1.forEach((ref) => {set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2: Set<string> = new Set<string>();\r\n        ref2.forEach((ref) => {set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    private autoTranslate(\r\n        from: string,\r\n        to: string,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile): Observable<AutoTranslateSummaryReport> {\r\n\r\n        let serviceCall: Observable<AutoTranslateSummaryReport>;\r\n        const autotranslateEnabled: boolean = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        } else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                } else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n\r\n}\r\n"]}