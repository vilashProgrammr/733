{"version":3,"file":"ngx-translate-extraction-pattern.js","sourceRoot":"","sources":["../../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extraction-pattern.ts"],"names":[],"mappings":";;AAAA;;;GAGG;AACH,MAAa,6BAA6B;IAKtC;;;;OAIG;IACH,YAAoB,uBAA+B;QAA/B,4BAAuB,GAAvB,uBAAuB,CAAQ;QAC/C,MAAM,KAAK,GAAG,uBAAuB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjD,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC9B,IAAI,CAAC,oBAAoB,GAAG,EAAE,CAAC;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,IAAI,KAAK,IAAI,EAAE;gBACf,IAAI,IAAI,CAAC,gBAAgB,EAAE;oBACvB,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;iBACnE;gBACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;aAChC;iBAAM;gBACH,MAAM,WAAW,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;gBAC5D,IAAI,WAAW,EAAE;oBACb,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC;iBAChC;gBACD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACxC;SACJ;IACL,CAAC;IAED;;;;OAIG;IACI,mBAAmB,CAAC,EAAU;QACjC,OAAO,EAAE,IAAI,IAAI,CAAC,gBAAgB,CAAC;IACvC,CAAC;IAED;;;;OAIG;IACI,oBAAoB,CAAC,WAAmB;QAC3C,OAAO,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC/D,CAAC;IAEO,4BAA4B,CAAC,kBAA0B;QAC3D,IAAI,CAAC,kBAAkB,EAAE;YACrB,OAAO,yBAAyB,CAAC;SACpC;QACD,IAAI,wBAAwB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE;YACnD,OAAO,IAAI,CAAC,CAAC,WAAW;SAC3B;aAAM;YACH,OAAO,mFAAmF,CAAC;SAC9F;IACL,CAAC;CACJ;AA3DD,sEA2DC","sourcesContent":["/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nexport class NgxTranslateExtractionPattern {\r\n\r\n    private _matchExplicitId: boolean;\r\n    private _descriptionPatterns: string[];\r\n\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(private extractionPatternString: string) {\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            } else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    public isExplicitIdMatched(id: string): boolean {\r\n        return id && this._matchExplicitId;\r\n    }\r\n\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    public isDescriptionMatched(description: string): boolean {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n\r\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        } else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\r\n"]}