{"version":3,"file":"preboot.umd.min.js","sources":["../../out-tsc/lib/common/get-node-key.ts","../../out-tsc/lib/common/tokens.ts","../../out-tsc/lib/api/event.replayer.ts","../../out-tsc/lib/api/event.recorder.ts","../../out-tsc/lib/api/inline.preboot.code.ts","../../node_modules/tslib/tslib.es6.js","../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../node_modules/rxjs/src/internal/config.ts","../../node_modules/rxjs/src/internal/Observer.ts","../../node_modules/rxjs/src/internal/util/isObject.ts","../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../node_modules/rxjs/src/internal/Subscription.ts","../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../node_modules/rxjs/src/internal/Subscriber.ts","../../node_modules/rxjs/src/internal/Observable.ts","../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../node_modules/rxjs/src/internal/util/canReportError.ts","../../node_modules/rxjs/src/internal/util/pipe.ts","../../node_modules/rxjs/src/internal/observable/combineLatest.ts","../../node_modules/rxjs/src/internal/observable/empty.ts","../../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../../node_modules/rxjs/src/internal/operators/filter.ts","../../node_modules/rxjs/src/internal/operators/take.ts","../../out-tsc/lib/provider.ts","../../out-tsc/lib/module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeContext } from './preboot.interfaces';\n\n/**\n * Attempt to generate key from node position in the DOM\n */\nexport function getNodeKeyForPreboot(nodeContext: NodeContext): string {\n  const ancestors: Element[] = [];\n  const root = nodeContext.root;\n  const node = nodeContext.node;\n  let temp: Element | null = node;\n\n  // walk up the tree from the target node up to the root\n  while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n    ancestors.push(temp);\n    temp = temp.parentNode as Element;\n  }\n\n  // note: if temp doesn't exist here it means root node wasn't found\n  if (temp) {\n    ancestors.push(temp);\n  }\n\n  // now go backwards starting from the root, appending the appName to unique\n  // identify the node later..\n  const name = node.nodeName || 'unknown';\n  let key = name;\n  const len = ancestors.length;\n\n  for (let i = len - 1; i >= 0; i--) {\n    temp = ancestors[i];\n\n    if (temp.childNodes && i > 0) {\n      for (let j = 0; j < temp.childNodes.length; j++) {\n        if (temp.childNodes[j] === ancestors[i - 1]) {\n          key += '_s' + (j + 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\n\nexport const PREBOOT_NONCE = new InjectionToken<string>('PrebootNonce');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  NodeContext,\n  PrebootAppData,\n  PrebootData,\n  PrebootEvent,\n  PrebootWindow,\n  ServerClientRoot,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nexport function _window(): PrebootWindow {\n  return {\n    prebootData: (window as any)['prebootData'],\n    getComputedStyle: window.getComputedStyle,\n    document: document\n  };\n}\n\nexport class EventReplayer {\n  clientNodeCache: { [key: string]: Element } = {};\n  replayStarted = false;\n  win: PrebootWindow;\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  setWindow(win: PrebootWindow) {\n    this.win = win;\n  }\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  getWindow() {\n    if (!this.win) {\n      this.win = _window();\n    }\n    return this.win;\n  }\n\n  /**\n   * Replay all events for all apps. this can only be run once.\n   * if called multiple times, will only do something once\n   */\n  replayAll() {\n    if (this.replayStarted) {\n      return;\n    } else {\n      this.replayStarted = true;\n    }\n\n    // loop through each of the preboot apps\n    const prebootData = this.getWindow().prebootData || {};\n    const apps = prebootData.apps || [];\n    apps.forEach(appData => this.replayForApp(appData));\n\n    // once all events have been replayed and buffers switched, then we cleanup preboot\n    this.cleanup(prebootData);\n  }\n\n  /**\n   * Replay all events for one app (most of the time there is just one app)\n   * @param appData\n   */\n  replayForApp(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    // try catch around events b/c even if error occurs, we still move forward\n    try {\n      const events = appData.events || [];\n\n      // replay all the events from the server view onto the client view\n      events.forEach(event => this.replayEvent(appData, event));\n    } catch (ex) {\n      console.error(ex);\n    }\n\n    // if we are buffering, switch the buffers\n    this.switchBuffer(appData);\n  }\n\n  /**\n   * Replay one particular event\n   * @param appData\n   * @param prebootEvent\n   */\n  replayEvent(appData: PrebootAppData, prebootEvent: PrebootEvent) {\n    appData = <PrebootAppData>(appData || {});\n    prebootEvent = <PrebootEvent>(prebootEvent || {});\n\n    const event = prebootEvent.event as Event;\n    const serverNode = prebootEvent.node || {};\n    const nodeKey = prebootEvent.nodeKey;\n    const clientNode = this.findClientNode({\n      root: appData.root,\n      node: serverNode,\n      nodeKey: nodeKey\n    });\n\n    // if client node can't be found, log a warning\n    if (!clientNode) {\n      console.warn(\n        `Trying to dispatch event ${event.type} to node ${nodeKey}\n        but could not find client node. Server node is: ${serverNode}`\n      );\n      return;\n    }\n\n    // now dispatch events and whatnot to the client node\n    (clientNode as HTMLInputElement).checked = serverNode.checked;\n    (clientNode as HTMLOptionElement).selected = serverNode.selected;\n    (clientNode as HTMLOptionElement).value = serverNode.value;\n    clientNode.dispatchEvent(event);\n  }\n\n  /**\n   * Switch the buffer for one particular app (i.e. display the client\n   * view and destroy the server view)\n   * @param appData\n   */\n  switchBuffer(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    const root = <ServerClientRoot>(appData.root || {});\n    const serverView = root.serverNode;\n    const clientView = root.clientNode;\n\n    // if no client view or the server view is the body or client\n    // and server view are the same, then don't do anything and return\n    if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {\n      return;\n    }\n\n    // do a try-catch just in case something messed up\n    try {\n      // get the server view display mode\n      const gcs = this.getWindow().getComputedStyle;\n      const display = gcs(serverView).getPropertyValue('display') || 'block';\n\n      // first remove the server view\n      serverView.remove ? serverView.remove() : (serverView.style.display = 'none');\n\n      // now add the client view\n      clientView.style.display = display;\n    } catch (ex) {\n      console.error(ex);\n    }\n  }\n\n  /**\n   * Finally, set focus, remove all the event listeners and remove\n   * any freeze screen that may be there\n   * @param prebootData\n   */\n  cleanup(prebootData: PrebootData) {\n    prebootData = prebootData || {};\n\n    const listeners = prebootData.listeners || [];\n\n    // set focus on the active node AFTER a small delay to ensure buffer\n    // switched\n    const activeNode = prebootData.activeNode;\n    if (activeNode != null) {\n      setTimeout(() => this.setFocus(activeNode), 1);\n    }\n\n    // remove all event listeners\n    for (const listener of listeners) {\n      listener.node.removeEventListener(listener.eventName, listener.handler);\n    }\n\n    // remove the freeze overlay if it exists\n    const doc = this.getWindow().document;\n    const prebootOverlay = doc.getElementById('prebootOverlay');\n    if (prebootOverlay) {\n      prebootOverlay.remove ?\n        prebootOverlay.remove() : prebootOverlay.parentNode !== null ?\n        prebootOverlay.parentNode.removeChild(prebootOverlay) :\n        prebootOverlay.style.display = 'none';\n    }\n\n    // clear out the data stored for each app\n    prebootData.apps = [];\n    this.clientNodeCache = {};\n\n    // send event to document that signals preboot complete\n    // constructor is not supported by older browsers ( i.e. IE9-11 )\n    // in these browsers, the type of CustomEvent will be \"object\"\n    if (typeof CustomEvent === 'function') {\n      const completeEvent = new CustomEvent('PrebootComplete');\n      doc.dispatchEvent(completeEvent);\n    } else {\n      console.warn(`Could not dispatch PrebootComplete event.\n       You can fix this by including a polyfill for CustomEvent.`);\n    }\n  }\n\n  setFocus(activeNode: NodeContext) {\n    // only do something if there is an active node\n    if (!activeNode || !activeNode.node || !activeNode.nodeKey) {\n      return;\n    }\n\n    // find the client node in the new client view\n    const clientNode = this.findClientNode(activeNode);\n    if (clientNode) {\n      // set focus on the client node\n      clientNode.focus();\n\n      // set selection if a modern browser (i.e. IE9+, etc.)\n      const selection = activeNode.selection;\n      if ((clientNode as HTMLInputElement).setSelectionRange && selection) {\n        try {\n          (clientNode as HTMLInputElement)\n            .setSelectionRange(selection.start, selection.end, selection.direction);\n        } catch (ex) {}\n      }\n    }\n  }\n\n  /**\n   * Given a node from the server rendered view, find the equivalent\n   * node in the client rendered view. We do this by the following approach:\n   *      1. take the name of the server node tag (ex. div or h1 or input)\n   *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n   *      3. use that value as a selector to get all the matching client nodes\n   *      4. loop through all client nodes found and for each generate a key value\n   *      5. compare the client key to the server key; once there is a match,\n   *          we have our client node\n   *\n   * NOTE: this only works when the client view is almost exactly the same as\n   * the server view. we will need an improvement here in the future to account\n   * for situations where the client view is different in structure from the\n   * server view\n   */\n  findClientNode(serverNodeContext: NodeContext): HTMLElement | null {\n    serverNodeContext = <NodeContext>(serverNodeContext || {});\n\n    const serverNode = serverNodeContext.node;\n    const root = serverNodeContext.root;\n\n    // if no server or client root, don't do anything\n    if (!root || !root.serverNode || !root.clientNode) {\n      return null;\n    }\n\n    // we use the string of the node to compare to the client node & as key in\n    // cache\n    const serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);\n\n    // if client node already in cache, return it\n    if (this.clientNodeCache[serverNodeKey]) {\n      return this.clientNodeCache[serverNodeKey] as HTMLElement;\n    }\n\n    // get the selector for client nodes\n    const className = (serverNode.className || '').replace('ng-binding', '').trim();\n    let selector = serverNode.tagName;\n\n    if (serverNode.id) {\n      selector += `#${serverNode.id}`;\n    } else if (className) {\n      selector += `.${className.replace(/ /g, '.')}`;\n    }\n\n    // select all possible client nodes and look through them to try and find a\n    // match\n    const rootClientNode = root.clientNode;\n    let clientNodes = rootClientNode.querySelectorAll(selector);\n\n    // if nothing found, then just try the tag name as a final option\n    if (!clientNodes.length) {\n      console.log(`nothing found for ${selector} so using ${serverNode.tagName}`);\n      clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);\n    }\n\n    const length = clientNodes.length;\n    for (let i = 0; i < length; i++) {\n      const clientNode = clientNodes.item(i);\n\n      // get the key for the client node\n      const clientNodeKey = getNodeKeyForPreboot({\n        root: root,\n        node: clientNode\n      });\n\n      // if the client node key is exact match for the server node key, then we\n      // found the client node\n      if (clientNodeKey === serverNodeKey) {\n        this.clientNodeCache[serverNodeKey] = clientNode;\n        return clientNode as HTMLElement;\n      }\n    }\n\n    // if we get here and there is one clientNode, use it as a fallback\n    if (clientNodes.length === 1) {\n      this.clientNodeCache[serverNodeKey] = clientNodes[0];\n      return clientNodes[0] as HTMLElement;\n    }\n\n    // if we get here it means we couldn't find the client node so give the user\n    // a warning\n    console.warn(\n      `No matching client node found for ${serverNodeKey}.\n       You can fix this by assigning this element a unique id attribute.`\n    );\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  EventSelector,\n  PrebootOptions,\n  PrebootAppData,\n  PrebootData,\n  DomEvent,\n  PrebootWindow,\n  ServerClientRoot,\n  PrebootSelection,\n  PrebootSelectionDirection,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\n/**\n * Called right away to initialize preboot\n *\n * @param opts All the preboot options\n * @param win\n */\nexport function initAll(opts: PrebootOptions, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // Add the preboot options to the preboot data and then add the data to\n  // the window so it can be used later by the client.\n  // Only set new options if they're not already set - we may have multiple app roots\n  // and each of them invokes the init function separately.\n  const data = (theWindow.prebootData = <PrebootData>{\n    opts: opts,\n    apps: [],\n    listeners: []\n  });\n\n  return () => start(data, theWindow);\n}\n\n/**\n * Start up preboot by going through each app and assigning the appropriate\n * handlers. Normally this wouldn't be called directly, but we have set it up so\n * that it can for older versions of Universal.\n *\n * @param prebootData Global preboot data object that contains options and will\n * have events\n * @param win Optional param to pass in mock window for testing purposes\n */\nexport function start(prebootData: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n  const _document = <Document>(theWindow.document || {});\n\n  // Remove the current script from the DOM so that child indexes match\n  // between the client & the server. The script is already running so it\n  // doesn't affect it.\n  const currentScript = _document.currentScript ||\n    // Support: IE 9-11 only\n    // IE doesn't support document.currentScript. Since the script is invoked\n    // synchronously, though, the current running script is just the last one\n    // currently in the document.\n    [].slice.call(_document.getElementsByTagName('script'), -1)[0];\n\n  if (!currentScript) {\n    console.error('Preboot initialization failed, no currentScript has been detected.');\n    return;\n  }\n\n  let serverNode = currentScript.parentNode;\n  if (!serverNode) {\n    console.error('Preboot initialization failed, the script is detached');\n    return;\n  }\n\n  serverNode.removeChild(currentScript);\n\n  const opts = prebootData.opts || ({} as PrebootOptions);\n  let eventSelectors = opts.eventSelectors || [];\n\n  // get the root info\n  const appRoot = prebootData.opts ? getAppRoot(_document, prebootData.opts, serverNode) : null;\n\n  // we track all events for each app in the prebootData object which is on\n  // the global scope; each `start` invocation adds data for one app only.\n  const appData = <PrebootAppData>{ root: appRoot, events: [] };\n  if (prebootData.apps) {\n    prebootData.apps.push(appData);\n  }\n\n  eventSelectors = eventSelectors.map(eventSelector => {\n    if (!eventSelector.hasOwnProperty('replay')) {\n      eventSelector.replay = true;\n    }\n    return eventSelector;\n  });\n\n  // loop through all the eventSelectors and create event handlers\n  eventSelectors.forEach(eventSelector =>\n    handleEvents(_document, prebootData, appData, eventSelector));\n}\n\n/**\n * Create an overlay div and add it to the DOM so it can be used\n * if a freeze event occurs\n *\n * @param _document The global document object (passed in for testing purposes)\n * @returns Element The overlay node is returned\n */\nexport function createOverlay(_document: Document): HTMLElement | undefined {\n  let overlay = _document.createElement('div');\n  overlay.setAttribute('id', 'prebootOverlay');\n  overlay.setAttribute(\n    'style',\n    'display:none;position:absolute;left:0;' +\n    'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3'\n  );\n  _document.documentElement.appendChild(overlay);\n\n  return overlay;\n}\n\n/**\n * Get references to the current app root node based on input options. Users can\n * initialize preboot either by specifying appRoot which is just one or more\n * selectors for apps. This section option is useful for people that are doing their own\n * buffering (i.e. they have their own client and server view)\n *\n * @param _document The global document object used to attach the overlay\n * @param opts Options passed in by the user to init()\n * @param serverNode The server node serving as application root\n * @returns ServerClientRoot An array of root info for the current app\n */\nexport function getAppRoot(\n  _document: Document,\n  opts: PrebootOptions,\n  serverNode: HTMLElement\n): ServerClientRoot {\n  const root: ServerClientRoot = {serverNode};\n\n  // if we are doing buffering, we need to create the buffer for the client\n  // else the client root is the same as the server\n  root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;\n\n  // create an overlay if not disabled ,that can be used later if a freeze event occurs\n  if (!opts.disableOverlay) {\n    root.overlay = createOverlay(_document);\n  }\n\n  return root;\n}\n\n/**\n * Under given server root, for given selector, record events\n *\n * @param _document\n * @param prebootData\n * @param appData\n * @param eventSelector\n */\nexport function handleEvents(_document: Document,\n                             prebootData: PrebootData,\n                             appData: PrebootAppData,\n                             eventSelector: EventSelector) {\n  const serverRoot = appData.root.serverNode;\n\n  // don't do anything if no server root\n  if (!serverRoot) {\n    return;\n  }\n\n  // Attach delegated event listeners for each event selector.\n  // We need to use delegated events as only the top level server node\n  // exists at this point.\n  eventSelector.events.forEach((eventName: string) => {\n    // get the appropriate handler and add it as an event listener\n    const handler = createListenHandler(_document, prebootData, eventSelector, appData);\n    // attach the handler in the capture phase so that it fires even if\n    // one of the handlers below calls stopPropagation()\n    serverRoot.addEventListener(eventName, handler, true);\n\n    // need to keep track of listeners so we can do node.removeEventListener()\n    // when preboot done\n    if (prebootData.listeners) {\n      prebootData.listeners.push({\n        node: serverRoot,\n        eventName,\n        handler\n      });\n    }\n  });\n}\n\n/**\n * Create handler for events that we will record\n */\nexport function createListenHandler(\n  _document: Document,\n  prebootData: PrebootData,\n  eventSelector: EventSelector,\n  appData: PrebootAppData\n): EventListener {\n  const CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];\n  const CARET_NODES = ['INPUT', 'TEXTAREA'];\n\n  // Support: IE 9-11 only\n  // IE uses a prefixed `matches` version\n  const matches = _document.documentElement.matches ||\n    (_document.documentElement as any).msMatchesSelector;\n  const opts = prebootData.opts;\n\n  return function(event: DomEvent) {\n    const node: Element = event.target;\n\n    // a delegated handlers on document is used so we need to check if\n    // event target matches a desired selector\n    if (!matches.call(node, eventSelector.selector)) {\n      return;\n    }\n\n    const root = appData.root;\n    const eventName = event.type;\n\n    // if no node or no event name, just return\n    if (!node || !eventName) {\n      return;\n    }\n\n    // if key codes set for eventSelector, then don't do anything if event\n    // doesn't include key\n    const keyCodes = eventSelector.keyCodes;\n    if (keyCodes && keyCodes.length) {\n      const matchingKeyCodes = keyCodes.filter(keyCode => event.which === keyCode);\n\n      // if there are not matches (i.e. key entered NOT one of the key codes)\n      // then don't do anything\n      if (!matchingKeyCodes.length) {\n        return;\n      }\n    }\n\n    // if for a given set of events we are preventing default, do that\n    if (eventSelector.preventDefault) {\n      event.preventDefault();\n    }\n\n    // if an action handler passed in, use that\n    if (eventSelector.action) {\n      eventSelector.action(node, event);\n    }\n\n    // get the node key for a given node\n    const nodeKey = getNodeKeyForPreboot({ root: root, node: node });\n\n    // if event on input or text area, record active node\n    if (CARET_EVENTS.indexOf(eventName) >= 0 &&\n      CARET_NODES.indexOf(node.tagName ? node.tagName : '') >= 0) {\n      prebootData.activeNode = {\n        root: root,\n        node: node,\n        nodeKey: nodeKey,\n        selection: getSelection(node as HTMLInputElement)\n      };\n    } else if (eventName !== 'change' && eventName !== 'focusout') {\n      prebootData.activeNode = undefined;\n    }\n\n    // if overlay is not disabled and we are freezing the UI\n    if (opts && !opts.disableOverlay && eventSelector.freeze) {\n      const overlay = root.overlay as HTMLElement;\n\n      // show the overlay\n      overlay.style.display = 'block';\n\n      // hide the overlay after 10 seconds just in case preboot.complete() never\n      // called\n      setTimeout(() => {\n        overlay.style.display = 'none';\n      }, 10000);\n    }\n\n    // we will record events for later replay unless explicitly marked as\n    // doNotReplay\n    if (eventSelector.replay) {\n      appData.events.push({\n        node,\n        nodeKey,\n        event,\n        name: eventName\n      });\n    }\n  };\n}\n\n/**\n * Get the selection data that is later used to set the cursor after client view\n * is active\n */\nexport function getSelection(node: HTMLInputElement): PrebootSelection {\n  node = node || {} as HTMLInputElement;\n\n  const nodeValue = node.value || '';\n  const selection: PrebootSelection = {\n    start: nodeValue.length,\n    end: nodeValue.length,\n    direction: 'forward'\n  };\n\n  // if browser support selectionStart on node (Chrome, FireFox, IE9+)\n  try {\n    if (node.selectionStart || node.selectionStart === 0) {\n      selection.start = node.selectionStart;\n      selection.end = node.selectionEnd ? node.selectionEnd : 0;\n      selection.direction = node.selectionDirection ?\n        node.selectionDirection as PrebootSelectionDirection : 'none';\n    }\n  } catch (ex) {}\n\n  return selection;\n}\n\n/**\n * Create buffer for a given node\n *\n * @param root All the data related to a particular app\n * @returns Returns the root client node.\n */\nexport function createBuffer(root: ServerClientRoot): HTMLElement {\n  const serverNode = root.serverNode;\n\n  // if no rootServerNode OR the selector is on the entire html doc or the body\n  // OR no parentNode, don't buffer\n  if (!serverNode || !serverNode.parentNode ||\n    serverNode === document.documentElement || serverNode === document.body) {\n    return serverNode as HTMLElement;\n  }\n\n  // create shallow clone of server root\n  const rootClientNode = serverNode.cloneNode(false) as HTMLElement;\n  // we want the client to write to a hidden div until the time for switching\n  // the buffers\n  rootClientNode.style.display = 'none';\n\n  // insert the client node before the server and return it\n  serverNode.parentNode.insertBefore(rootClientNode, serverNode);\n\n  // mark server node as not to be touched by AngularJS - needed for ngUpgrade\n  serverNode.setAttribute('ng-non-bindable', '');\n\n  // return the rootClientNode\n  return rootClientNode;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {PrebootOptions} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nimport {\n  initAll,\n  start,\n  createOverlay,\n  getAppRoot,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n} from './event.recorder';\n\nconst eventRecorder = {\n  start,\n  createOverlay,\n  getAppRoot,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n};\n\nexport const initFunctionName = 'prebootInitFn';\n\n// exporting default options in case developer wants to use these + custom on\n// top\nexport const defaultOptions = <PrebootOptions>{\n  buffer: true,\n  replay: true,\n  disableOverlay: false,\n\n  // these are the default events are are listening for an transferring from\n  // server view to client view\n  eventSelectors: [\n    // for recording changes in form elements\n    {\n      selector: 'input,textarea',\n      events: ['keypress', 'keyup', 'keydown', 'input', 'change']\n    },\n    { selector: 'select,option', events: ['change'] },\n\n    // when user hits return button in an input box\n    {\n      selector: 'input',\n      events: ['keyup'],\n      preventDefault: true,\n      keyCodes: [13],\n      freeze: true\n    },\n\n    // when user submit form (press enter, click on button/input[type=\"submit\"])\n    {\n      selector: 'form',\n      events: ['submit'],\n      preventDefault: true,\n      freeze: true\n    },\n\n    // for tracking focus (no need to replay)\n    {\n      selector: 'input,textarea',\n      events: ['focusin', 'focusout', 'mousedown', 'mouseup'],\n      replay: false\n    },\n\n    // user clicks on a button\n    {\n      selector: 'button',\n      events: ['click'],\n      preventDefault: true,\n      freeze: true\n    }\n  ]\n};\n\n/**\n * Get the event recorder code based on all functions in event.recorder.ts\n * and the getNodeKeyForPreboot function.\n */\nexport function getEventRecorderCode(): string {\n  const eventRecorderFunctions: string[] = [];\n\n  for (const funcName in eventRecorder) {\n    if (eventRecorder.hasOwnProperty(funcName)) {\n      const fn = (<any>eventRecorder)[funcName].toString();\n      const fnCleaned = fn.replace('common_1.', '');\n      eventRecorderFunctions.push(fnCleaned);\n    }\n  }\n\n  // this is common function used to get the node key\n  eventRecorderFunctions.push(getNodeKeyForPreboot.toString());\n\n  // add new line characters for readability\n  return '\\n\\n' + eventRecorderFunctions.join('\\n\\n') + '\\n\\n';\n}\n\n/**\n * Used by the server side version of preboot. The main purpose is to get the\n * inline code that can be inserted into the server view.\n * Returns the definitions of the prebootInit function called in code returned by\n * getInlineInvocation for each server node separately.\n *\n * @param customOptions PrebootRecordOptions that override the defaults\n * @returns Generated inline preboot code with just functions definitions\n * to be used separately\n */\nexport function getInlineDefinition(customOptions?: PrebootOptions): string {\n  const opts = <PrebootOptions>assign({}, defaultOptions, customOptions);\n\n  // safety check to make sure options passed in are valid\n  validateOptions(opts);\n\n  const scriptCode = getEventRecorderCode();\n  const optsStr = stringifyWithFunctions(opts);\n\n  // wrap inline preboot code with a self executing function in order to create scope\n  const initAllStr = initAll.toString();\n  return `var ${initFunctionName} = (function() {\n      ${scriptCode}\n      return (${initAllStr.replace('common_1.', '')})(${optsStr});\n    })();`;\n}\n\n\n/**\n * Used by the server side version of preboot. The main purpose is to get the\n * inline code that can be inserted into the server view.\n * Invokes the prebootInit function defined in getInlineDefinition with proper\n * parameters. Each appRoot should get a separate inlined code from a separate\n * call to getInlineInvocation but only one inlined code from getInlineDefinition.\n *\n * @returns Generated inline preboot code with just invocations of functions from\n * getInlineDefinition\n */\nexport function getInlineInvocation(): string {\n  return `${initFunctionName}();`;\n}\n\n/**\n * Throw an error if issues with any options\n * @param opts\n */\nexport function validateOptions(opts: PrebootOptions) {\n  if (!opts.appRoot || !opts.appRoot.length) {\n    throw new Error(\n      'The appRoot is missing from preboot options. ' +\n        'This is needed to find the root of your application. ' +\n        'Set this value in the preboot options to be a selector for the root element of your app.'\n    );\n  }\n}\n\n/**\n * Object.assign() is not fully supporting in TypeScript, so\n * this is just a simple implementation of it\n *\n * @param target The target object\n * @param optionSets Any number of addition objects that are added on top of the\n * target\n * @returns A new object that contains all the merged values\n */\nexport function assign(target: Object, ...optionSets: any[]): Object {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  const output = Object(target);\n  for (let index = 0; index < optionSets.length; index++) {\n    const source = optionSets[index];\n    if (source !== undefined && source !== null) {\n      for (const nextKey in source) {\n        if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n/**\n * Stringify an object and include functions. This is needed since we are\n * letting users pass in options that include custom functions for things like\n * the freeze handler or action when an event occurs\n *\n * @param obj This is the object you want to stringify that includes some\n * functions\n * @returns The stringified version of an object\n */\nexport function stringifyWithFunctions(obj: Object): string {\n  const FUNC_START = 'START_FUNCTION_HERE';\n  const FUNC_STOP = 'STOP_FUNCTION_HERE';\n\n  // first stringify except mark off functions with markers\n  let str = JSON.stringify(obj, function(_key, value) {\n    // if the value is a function, we want to wrap it with markers\n    if (!!(value && value.constructor && value.call && value.apply)) {\n      return FUNC_START + value.toString() + FUNC_STOP;\n    } else {\n      return value;\n    }\n  });\n\n  // now we use the markers to replace function strings with actual functions\n  let startFuncIdx = str.indexOf(FUNC_START);\n  let stopFuncIdx: number;\n  let fn: string;\n  while (startFuncIdx >= 0) {\n    stopFuncIdx = str.indexOf(FUNC_STOP);\n\n    // pull string out\n    fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);\n    fn = fn.replace(/\\\\n/g, '\\n');\n\n    str = str.substring(0, startFuncIdx - 1) + fn +\n      str.substring(stopFuncIdx + FUNC_STOP.length + 1);\n    startFuncIdx = str.indexOf(FUNC_START);\n  }\n\n  return str;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport const rxSubscriber =\n  typeof Symbol === 'function'\n    ? Symbol('rxSubscriber')\n    : '@@rxSubscriber_' + Math.random();\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver, TeardownLogic } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any> | Subscriber<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    this._parentSubscription = null;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport function canReportError(observer: Subscriber<any> | Subject<any>): boolean {\n  while (observer) {\n    const { closed, destination, isStopped } = observer as any;\n    if (closed || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n  return true;\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/* tslint:enable:max-line-length */\n\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler  } from '../util/isScheduler';\nimport { isArray  } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\n\nconst NONE = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;\n\nexport function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;\nexport function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;\nexport function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;\nexport function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n * ## Examples\n * ### Combine two timer Observables\n * ```javascript\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * ### Combine an array of Observables\n * ```javascript\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000),   // emit 0 and then emit n after n seconds\n *     startWith(0),\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n *\n * ### Use project function to dynamically calculate the Body-Mass Index\n * ```javascript\n * * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest(weight, height).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<T, R>(...observables: Array<any | ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    (((...values: Array<any>) => R)) |\n                                                    SchedulerLike>): Observable<R> {\n  let resultSelector: (...values: Array<any>) => R =  null;\n  let scheduler: SchedulerLike = null;\n\n  if (isScheduler(observables[observables.length - 1])) {\n    scheduler = <SchedulerLike>observables.pop();\n  }\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    resultSelector = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = <Array<Observable<any>>>observables[0];\n  }\n\n  return fromArray(observables, scheduler).lift(new CombineLatestOperator<T, R>(resultSelector));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private resultSelector?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private resultSelector?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(NONE);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === NONE ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.resultSelector) {\n        this._tryResultSelector(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryResultSelector(values: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using {@link index/EMPTY} constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","export interface ArgumentOutOfRangeError extends Error {\n}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  new(): ArgumentOutOfRangeError;\n}\n\nfunction ArgumentOutOfRangeErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'argument out of range';\n  this.name = 'ArgumentOutOfRangeError';\n  return this;\n}\n\nArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = ArgumentOutOfRangeErrorImpl as any;","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n * Emit only click events whose target was a DIV element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```javascript\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  ApplicationRef,\n  Inject,\n  InjectionToken,\n  Optional,\n  PLATFORM_ID\n} from '@angular/core';\nimport {DOCUMENT, isPlatformBrowser, isPlatformServer} from '@angular/common';\nimport {filter, take} from 'rxjs/operators';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PREBOOT_NONCE} from './common/tokens';\nimport {getInlineDefinition, getInlineInvocation} from './api/inline.preboot.code';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {validateOptions} from './api';\n\nconst PREBOOT_SCRIPT_CLASS = 'preboot-inline-script';\nexport const PREBOOT_OPTIONS = new InjectionToken<PrebootOptions>('PrebootOptions');\n\nfunction createScriptFromCode(doc: Document, nonce: string|null, inlineCode: string) {\n  const script = doc.createElement('script');\n  if (nonce) {\n    (script as any).nonce = nonce;\n  }\n  script.className = PREBOOT_SCRIPT_CLASS;\n  script.textContent = inlineCode;\n\n  return script;\n}\n\nexport function PREBOOT_FACTORY(doc: Document,\n                                prebootOpts: PrebootOptions,\n                                nonce: string|null,\n                                platformId: Object,\n                                appRef: ApplicationRef,\n                                eventReplayer: EventReplayer) {\n  return () => {\n    validateOptions(prebootOpts);\n\n    if (isPlatformServer(platformId)) {\n      const inlineCodeDefinition = getInlineDefinition(prebootOpts);\n      const scriptWithDefinition = createScriptFromCode(doc, nonce, inlineCodeDefinition);\n      const inlineCodeInvocation = getInlineInvocation();\n\n      const existingScripts = doc.getElementsByClassName(PREBOOT_SCRIPT_CLASS);\n\n      // Check to see if preboot scripts are already inlined before adding them\n      // to the DOM. If they are, update the nonce to be current.\n      if (existingScripts.length === 0) {\n        const baseList: string[] = [];\n        const appRootSelectors = baseList.concat(prebootOpts.appRoot);\n        doc.head.appendChild(scriptWithDefinition);\n        appRootSelectors\n          .map(selector => ({\n            selector,\n            appRootElem: doc.querySelector(selector)\n          }))\n          .forEach(({selector, appRootElem}) => {\n            if (!appRootElem) {\n              console.log(`No server node found for selector: ${selector}`);\n              return;\n            }\n            const scriptWithInvocation = createScriptFromCode(doc, nonce, inlineCodeInvocation);\n            appRootElem.insertBefore(scriptWithInvocation, appRootElem.firstChild);\n          });\n      } else if (existingScripts.length > 0 && nonce) {\n        (existingScripts[0] as any).nonce = nonce;\n      }\n    }\n    if (isPlatformBrowser(platformId)) {\n      const replay = prebootOpts.replay != null ? prebootOpts.replay : true;\n      if (replay) {\n        appRef.isStable\n          .pipe(\n            filter(stable => stable),\n            take(1)\n          ).subscribe(() => {\n          eventReplayer.replayAll();\n        });\n      }\n    }\n  };\n}\n\nexport const PREBOOT_PROVIDER = {\n  provide: <InjectionToken<() => void>>APP_BOOTSTRAP_LISTENER,\n  useFactory: PREBOOT_FACTORY,\n  deps: [\n    DOCUMENT,\n    PREBOOT_OPTIONS,\n    [new Optional(), new Inject(PREBOOT_NONCE)],\n    PLATFORM_ID,\n    ApplicationRef,\n    EventReplayer,\n  ],\n  multi: true\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {PREBOOT_OPTIONS, PREBOOT_PROVIDER} from './provider';\n\n@NgModule({\n  providers: [EventReplayer, PREBOOT_PROVIDER]\n})\nexport class PrebootModule {\n  static withConfig(opts: PrebootOptions): ModuleWithProviders {\n    return {\n      ngModule: PrebootModule,\n      providers: [{provide: PREBOOT_OPTIONS, useValue: opts}]\n    };\n  }\n}\n"],"names":["getNodeKeyForPreboot","nodeContext","ancestors","root","node","temp","serverNode","clientNode","push","key","nodeName","i","length","childNodes","j","PREBOOT_NONCE","InjectionToken","_window","prebootData","getComputedStyle","window","document","this","EventReplayer","win","replayStarted","getWindow","apps","forEach","appData","_this","replayForApp","cleanup","events","event","replayEvent","ex","console","error","switchBuffer","prebootEvent","nodeKey","findClientNode","checked","selected","value","dispatchEvent","warn","type","serverView","clientView","display","gcs","getPropertyValue","remove","style","listeners","activeNode","setTimeout","setFocus","listeners_1","_i","listener","removeEventListener","eventName","handler","doc","prebootOverlay","getElementById","parentNode","removeChild","clientNodeCache","CustomEvent","completeEvent","focus","selection","setSelectionRange","start","end","direction","serverNodeContext","serverNodeKey","className","replace","trim","selector","tagName","id","rootClientNode","clientNodes","querySelectorAll","log","item","initAll","opts","theWindow","data","_document","currentScript","slice","call","getElementsByTagName","eventSelectors","getAppRoot","map","eventSelector","hasOwnProperty","replay","handleEvents","createOverlay","overlay","createElement","setAttribute","documentElement","appendChild","buffer","createBuffer","disableOverlay","serverRoot","createListenHandler","addEventListener","CARET_EVENTS","CARET_NODES","matches","msMatchesSelector","target","keyCodes","filter","keyCode","which","preventDefault","action","indexOf","getSelection","undefined","freeze","overlay_1","name","nodeValue","selectionStart","selectionEnd","selectionDirection","body","cloneNode","insertBefore","eventRecorder","initFunctionName","defaultOptions","getEventRecorderCode","eventRecorderFunctions","funcName","fnCleaned","toString","join","getInlineDefinition","customOptions","assign","validateOptions","scriptCode","optsStr","stringifyWithFunctions","initAllStr","getInlineInvocation","appRoot","Error","optionSets","TypeError","output","Object","index","source","nextKey","obj","stopFuncIdx","fn","FUNC_START","FUNC_STOP","str","JSON","stringify","_key","constructor","apply","startFuncIdx","substring","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","__extends","__","prototype","create","errorObject","tryCatchTarget","config","Promise","closed","next","isObject","UnsubscriptionErrorImpl","errors","Subscription","unsubscribe","hasErrors","_parent","_parents","isFunction","e","UnsubscriptionError","isArray","_subscriptions","len","sub","err","teardown","subscription","subscriptions","subscriptionIndex","parent","Math","Subscriber","_super","destination","destinationOrNext","syncErrorThrowable","tslib_1.__extends","subscriber","isStopped","_next","_error","_complete","SafeSubscriber","context","observerOrNext","complete","_context","_parentSubscriber","useDeprecatedSynchronousErrorHandling","__tryOrSetError","__tryOrUnsub","syncErrorValue","wrappedComplete","syncErrorThrown","hostReportError","Observable","subscribe","lift","operator","observable","sink","nextOrObserver","_subscribe","_a","closed_1","canReportError","promiseCtor","reject","operations","fns","input","toPromise","getPromiseCtor","scheduler","ArgumentOutOfRangeErrorImpl","message","FilterOperator","FilterSubscriber","thisArg","result","TakeOperator","total","TakeSubscriber","count","PREBOOT_SCRIPT_CLASS","PREBOOT_OPTIONS","createScriptFromCode","nonce","inlineCode","script","textContent","PREBOOT_FACTORY","prebootOpts","platformId","appRef","eventReplayer","isPlatformServer","inlineCodeDefinition","scriptWithDefinition","inlineCodeInvocation_1","existingScripts","getElementsByClassName","appRootSelectors","concat","head","appRootElem","querySelector","scriptWithInvocation","firstChild","isPlatformBrowser","isStable","pipe","stable","replayAll","PREBOOT_PROVIDER","provide","APP_BOOTSTRAP_LISTENER","useFactory","deps","DOCUMENT","Optional","Inject","PLATFORM_ID","ApplicationRef","multi","PrebootModule","ngModule","providers","useValue","NgModule"],"mappings":"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"}